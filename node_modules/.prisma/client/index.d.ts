
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Household
 * 
 */
export type Household = $Result.DefaultSelection<Prisma.$HouseholdPayload>
/**
 * Model HouseholdMember
 * 
 */
export type HouseholdMember = $Result.DefaultSelection<Prisma.$HouseholdMemberPayload>
/**
 * Model RecurrenceRule
 * 
 */
export type RecurrenceRule = $Result.DefaultSelection<Prisma.$RecurrenceRulePayload>
/**
 * Model Thread
 * 
 */
export type Thread = $Result.DefaultSelection<Prisma.$ThreadPayload>
/**
 * Model Message
 * 
 */
export type Message = $Result.DefaultSelection<Prisma.$MessagePayload>
/**
 * Model Reaction
 * 
 */
export type Reaction = $Result.DefaultSelection<Prisma.$ReactionPayload>
/**
 * Model Mention
 * 
 */
export type Mention = $Result.DefaultSelection<Prisma.$MentionPayload>
/**
 * Model Attachment
 * 
 */
export type Attachment = $Result.DefaultSelection<Prisma.$AttachmentPayload>
/**
 * Model MessageRead
 * 
 */
export type MessageRead = $Result.DefaultSelection<Prisma.$MessageReadPayload>
/**
 * Model Chore
 * 
 */
export type Chore = $Result.DefaultSelection<Prisma.$ChorePayload>
/**
 * Model Subtask
 * 
 */
export type Subtask = $Result.DefaultSelection<Prisma.$SubtaskPayload>
/**
 * Model ChoreAssignment
 * 
 */
export type ChoreAssignment = $Result.DefaultSelection<Prisma.$ChoreAssignmentPayload>
/**
 * Model ChoreSwapRequest
 * 
 */
export type ChoreSwapRequest = $Result.DefaultSelection<Prisma.$ChoreSwapRequestPayload>
/**
 * Model ChoreTemplate
 * 
 */
export type ChoreTemplate = $Result.DefaultSelection<Prisma.$ChoreTemplatePayload>
/**
 * Model SubtaskTemplate
 * 
 */
export type SubtaskTemplate = $Result.DefaultSelection<Prisma.$SubtaskTemplatePayload>
/**
 * Model ChoreHistory
 * 
 */
export type ChoreHistory = $Result.DefaultSelection<Prisma.$ChoreHistoryPayload>
/**
 * Model Expense
 * 
 */
export type Expense = $Result.DefaultSelection<Prisma.$ExpensePayload>
/**
 * Model ExpenseSplit
 * 
 */
export type ExpenseSplit = $Result.DefaultSelection<Prisma.$ExpenseSplitPayload>
/**
 * Model Transaction
 * 
 */
export type Transaction = $Result.DefaultSelection<Prisma.$TransactionPayload>
/**
 * Model Receipt
 * 
 */
export type Receipt = $Result.DefaultSelection<Prisma.$ReceiptPayload>
/**
 * Model ExpenseHistory
 * 
 */
export type ExpenseHistory = $Result.DefaultSelection<Prisma.$ExpenseHistoryPayload>
/**
 * Model Event
 * 
 */
export type Event = $Result.DefaultSelection<Prisma.$EventPayload>
/**
 * Model EventReminder
 * 
 */
export type EventReminder = $Result.DefaultSelection<Prisma.$EventReminderPayload>
/**
 * Model CalendarEventHistory
 * 
 */
export type CalendarEventHistory = $Result.DefaultSelection<Prisma.$CalendarEventHistoryPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model NotificationSettings
 * 
 */
export type NotificationSettings = $Result.DefaultSelection<Prisma.$NotificationSettingsPayload>
/**
 * Model OAuthIntegration
 * 
 */
export type OAuthIntegration = $Result.DefaultSelection<Prisma.$OAuthIntegrationPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const HouseholdRole: {
  ADMIN: 'ADMIN',
  MEMBER: 'MEMBER'
};

export type HouseholdRole = (typeof HouseholdRole)[keyof typeof HouseholdRole]


export const RecurrenceFrequency: {
  DAILY: 'DAILY',
  WEEKLY: 'WEEKLY',
  BIWEEKLY: 'BIWEEKLY',
  MONTHLY: 'MONTHLY',
  QUADRENNIAL: 'QUADRENNIAL',
  YEARLY: 'YEARLY'
};

export type RecurrenceFrequency = (typeof RecurrenceFrequency)[keyof typeof RecurrenceFrequency]


export const DaysOfWeek: {
  SUNDAY: 'SUNDAY',
  MONDAY: 'MONDAY',
  TUESDAY: 'TUESDAY',
  WEDNESDAY: 'WEDNESDAY',
  THURSDAY: 'THURSDAY',
  FRIDAY: 'FRIDAY',
  SATURDAY: 'SATURDAY'
};

export type DaysOfWeek = (typeof DaysOfWeek)[keyof typeof DaysOfWeek]


export const ReactionType: {
  LIKE: 'LIKE',
  LOVE: 'LOVE',
  HAHA: 'HAHA',
  WOW: 'WOW',
  SAD: 'SAD',
  ANGRY: 'ANGRY'
};

export type ReactionType = (typeof ReactionType)[keyof typeof ReactionType]


export const ChoreStatus: {
  PENDING: 'PENDING',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED'
};

export type ChoreStatus = (typeof ChoreStatus)[keyof typeof ChoreStatus]


export const SubtaskStatus: {
  PENDING: 'PENDING',
  COMPLETED: 'COMPLETED'
};

export type SubtaskStatus = (typeof SubtaskStatus)[keyof typeof SubtaskStatus]


export const ChoreSwapRequestStatus: {
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED'
};

export type ChoreSwapRequestStatus = (typeof ChoreSwapRequestStatus)[keyof typeof ChoreSwapRequestStatus]


export const ChoreAction: {
  CREATED: 'CREATED',
  UPDATED: 'UPDATED',
  COMPLETED: 'COMPLETED',
  ASSIGNED: 'ASSIGNED',
  DELETED: 'DELETED',
  SWAPPED: 'SWAPPED',
  TEMPLATE_CREATED: 'TEMPLATE_CREATED',
  TEMPLATE_UPDATED: 'TEMPLATE_UPDATED',
  TEMPLATE_DELETED: 'TEMPLATE_DELETED',
  RECURRENCE_CHANGED: 'RECURRENCE_CHANGED'
};

export type ChoreAction = (typeof ChoreAction)[keyof typeof ChoreAction]


export const ExpenseCategory: {
  FOOD: 'FOOD',
  TRANSPORTATION: 'TRANSPORTATION',
  HOUSING: 'HOUSING',
  UTILITIES: 'UTILITIES',
  ENTERTAINMENT: 'ENTERTAINMENT',
  OTHER: 'OTHER'
};

export type ExpenseCategory = (typeof ExpenseCategory)[keyof typeof ExpenseCategory]


export const TransactionStatus: {
  PENDING: 'PENDING',
  COMPLETED: 'COMPLETED'
};

export type TransactionStatus = (typeof TransactionStatus)[keyof typeof TransactionStatus]


export const ExpenseAction: {
  CREATED: 'CREATED',
  UPDATED: 'UPDATED',
  PAID: 'PAID',
  SPLIT: 'SPLIT',
  DELETED: 'DELETED',
  RECEIPT_UPLOADED: 'RECEIPT_UPLOADED'
};

export type ExpenseAction = (typeof ExpenseAction)[keyof typeof ExpenseAction]


export const EventCategory: {
  CHORE: 'CHORE',
  MEETING: 'MEETING',
  SOCIAL: 'SOCIAL',
  OTHER: 'OTHER'
};

export type EventCategory = (typeof EventCategory)[keyof typeof EventCategory]


export const EventStatus: {
  SCHEDULED: 'SCHEDULED',
  CANCELLED: 'CANCELLED',
  COMPLETED: 'COMPLETED'
};

export type EventStatus = (typeof EventStatus)[keyof typeof EventStatus]


export const EventReminderType: {
  PUSH_NOTIFICATION: 'PUSH_NOTIFICATION',
  EMAIL: 'EMAIL',
  SMS: 'SMS'
};

export type EventReminderType = (typeof EventReminderType)[keyof typeof EventReminderType]


export const CalendarEventAction: {
  CREATED: 'CREATED',
  UPDATED: 'UPDATED',
  DELETED: 'DELETED',
  STATUS_CHANGED: 'STATUS_CHANGED',
  RECURRENCE_CHANGED: 'RECURRENCE_CHANGED'
};

export type CalendarEventAction = (typeof CalendarEventAction)[keyof typeof CalendarEventAction]


export const NotificationType: {
  NEW_MESSAGE: 'NEW_MESSAGE',
  CHORE_ASSIGNED: 'CHORE_ASSIGNED',
  EXPENSE_UPDATED: 'EXPENSE_UPDATED',
  PAYMENT_REMINDER: 'PAYMENT_REMINDER',
  EVENT_REMINDER: 'EVENT_REMINDER',
  OTHER: 'OTHER'
};

export type NotificationType = (typeof NotificationType)[keyof typeof NotificationType]


export const Provider: {
  GOOGLE: 'GOOGLE',
  FACEBOOK: 'FACEBOOK',
  APPLE: 'APPLE'
};

export type Provider = (typeof Provider)[keyof typeof Provider]

}

export type HouseholdRole = $Enums.HouseholdRole

export const HouseholdRole: typeof $Enums.HouseholdRole

export type RecurrenceFrequency = $Enums.RecurrenceFrequency

export const RecurrenceFrequency: typeof $Enums.RecurrenceFrequency

export type DaysOfWeek = $Enums.DaysOfWeek

export const DaysOfWeek: typeof $Enums.DaysOfWeek

export type ReactionType = $Enums.ReactionType

export const ReactionType: typeof $Enums.ReactionType

export type ChoreStatus = $Enums.ChoreStatus

export const ChoreStatus: typeof $Enums.ChoreStatus

export type SubtaskStatus = $Enums.SubtaskStatus

export const SubtaskStatus: typeof $Enums.SubtaskStatus

export type ChoreSwapRequestStatus = $Enums.ChoreSwapRequestStatus

export const ChoreSwapRequestStatus: typeof $Enums.ChoreSwapRequestStatus

export type ChoreAction = $Enums.ChoreAction

export const ChoreAction: typeof $Enums.ChoreAction

export type ExpenseCategory = $Enums.ExpenseCategory

export const ExpenseCategory: typeof $Enums.ExpenseCategory

export type TransactionStatus = $Enums.TransactionStatus

export const TransactionStatus: typeof $Enums.TransactionStatus

export type ExpenseAction = $Enums.ExpenseAction

export const ExpenseAction: typeof $Enums.ExpenseAction

export type EventCategory = $Enums.EventCategory

export const EventCategory: typeof $Enums.EventCategory

export type EventStatus = $Enums.EventStatus

export const EventStatus: typeof $Enums.EventStatus

export type EventReminderType = $Enums.EventReminderType

export const EventReminderType: typeof $Enums.EventReminderType

export type CalendarEventAction = $Enums.CalendarEventAction

export const CalendarEventAction: typeof $Enums.CalendarEventAction

export type NotificationType = $Enums.NotificationType

export const NotificationType: typeof $Enums.NotificationType

export type Provider = $Enums.Provider

export const Provider: typeof $Enums.Provider

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.household`: Exposes CRUD operations for the **Household** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Households
    * const households = await prisma.household.findMany()
    * ```
    */
  get household(): Prisma.HouseholdDelegate<ExtArgs>;

  /**
   * `prisma.householdMember`: Exposes CRUD operations for the **HouseholdMember** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HouseholdMembers
    * const householdMembers = await prisma.householdMember.findMany()
    * ```
    */
  get householdMember(): Prisma.HouseholdMemberDelegate<ExtArgs>;

  /**
   * `prisma.recurrenceRule`: Exposes CRUD operations for the **RecurrenceRule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RecurrenceRules
    * const recurrenceRules = await prisma.recurrenceRule.findMany()
    * ```
    */
  get recurrenceRule(): Prisma.RecurrenceRuleDelegate<ExtArgs>;

  /**
   * `prisma.thread`: Exposes CRUD operations for the **Thread** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Threads
    * const threads = await prisma.thread.findMany()
    * ```
    */
  get thread(): Prisma.ThreadDelegate<ExtArgs>;

  /**
   * `prisma.message`: Exposes CRUD operations for the **Message** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messages
    * const messages = await prisma.message.findMany()
    * ```
    */
  get message(): Prisma.MessageDelegate<ExtArgs>;

  /**
   * `prisma.reaction`: Exposes CRUD operations for the **Reaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reactions
    * const reactions = await prisma.reaction.findMany()
    * ```
    */
  get reaction(): Prisma.ReactionDelegate<ExtArgs>;

  /**
   * `prisma.mention`: Exposes CRUD operations for the **Mention** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Mentions
    * const mentions = await prisma.mention.findMany()
    * ```
    */
  get mention(): Prisma.MentionDelegate<ExtArgs>;

  /**
   * `prisma.attachment`: Exposes CRUD operations for the **Attachment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Attachments
    * const attachments = await prisma.attachment.findMany()
    * ```
    */
  get attachment(): Prisma.AttachmentDelegate<ExtArgs>;

  /**
   * `prisma.messageRead`: Exposes CRUD operations for the **MessageRead** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MessageReads
    * const messageReads = await prisma.messageRead.findMany()
    * ```
    */
  get messageRead(): Prisma.MessageReadDelegate<ExtArgs>;

  /**
   * `prisma.chore`: Exposes CRUD operations for the **Chore** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Chores
    * const chores = await prisma.chore.findMany()
    * ```
    */
  get chore(): Prisma.ChoreDelegate<ExtArgs>;

  /**
   * `prisma.subtask`: Exposes CRUD operations for the **Subtask** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subtasks
    * const subtasks = await prisma.subtask.findMany()
    * ```
    */
  get subtask(): Prisma.SubtaskDelegate<ExtArgs>;

  /**
   * `prisma.choreAssignment`: Exposes CRUD operations for the **ChoreAssignment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChoreAssignments
    * const choreAssignments = await prisma.choreAssignment.findMany()
    * ```
    */
  get choreAssignment(): Prisma.ChoreAssignmentDelegate<ExtArgs>;

  /**
   * `prisma.choreSwapRequest`: Exposes CRUD operations for the **ChoreSwapRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChoreSwapRequests
    * const choreSwapRequests = await prisma.choreSwapRequest.findMany()
    * ```
    */
  get choreSwapRequest(): Prisma.ChoreSwapRequestDelegate<ExtArgs>;

  /**
   * `prisma.choreTemplate`: Exposes CRUD operations for the **ChoreTemplate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChoreTemplates
    * const choreTemplates = await prisma.choreTemplate.findMany()
    * ```
    */
  get choreTemplate(): Prisma.ChoreTemplateDelegate<ExtArgs>;

  /**
   * `prisma.subtaskTemplate`: Exposes CRUD operations for the **SubtaskTemplate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SubtaskTemplates
    * const subtaskTemplates = await prisma.subtaskTemplate.findMany()
    * ```
    */
  get subtaskTemplate(): Prisma.SubtaskTemplateDelegate<ExtArgs>;

  /**
   * `prisma.choreHistory`: Exposes CRUD operations for the **ChoreHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChoreHistories
    * const choreHistories = await prisma.choreHistory.findMany()
    * ```
    */
  get choreHistory(): Prisma.ChoreHistoryDelegate<ExtArgs>;

  /**
   * `prisma.expense`: Exposes CRUD operations for the **Expense** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Expenses
    * const expenses = await prisma.expense.findMany()
    * ```
    */
  get expense(): Prisma.ExpenseDelegate<ExtArgs>;

  /**
   * `prisma.expenseSplit`: Exposes CRUD operations for the **ExpenseSplit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExpenseSplits
    * const expenseSplits = await prisma.expenseSplit.findMany()
    * ```
    */
  get expenseSplit(): Prisma.ExpenseSplitDelegate<ExtArgs>;

  /**
   * `prisma.transaction`: Exposes CRUD operations for the **Transaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transactions
    * const transactions = await prisma.transaction.findMany()
    * ```
    */
  get transaction(): Prisma.TransactionDelegate<ExtArgs>;

  /**
   * `prisma.receipt`: Exposes CRUD operations for the **Receipt** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Receipts
    * const receipts = await prisma.receipt.findMany()
    * ```
    */
  get receipt(): Prisma.ReceiptDelegate<ExtArgs>;

  /**
   * `prisma.expenseHistory`: Exposes CRUD operations for the **ExpenseHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExpenseHistories
    * const expenseHistories = await prisma.expenseHistory.findMany()
    * ```
    */
  get expenseHistory(): Prisma.ExpenseHistoryDelegate<ExtArgs>;

  /**
   * `prisma.event`: Exposes CRUD operations for the **Event** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Events
    * const events = await prisma.event.findMany()
    * ```
    */
  get event(): Prisma.EventDelegate<ExtArgs>;

  /**
   * `prisma.eventReminder`: Exposes CRUD operations for the **EventReminder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EventReminders
    * const eventReminders = await prisma.eventReminder.findMany()
    * ```
    */
  get eventReminder(): Prisma.EventReminderDelegate<ExtArgs>;

  /**
   * `prisma.calendarEventHistory`: Exposes CRUD operations for the **CalendarEventHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CalendarEventHistories
    * const calendarEventHistories = await prisma.calendarEventHistory.findMany()
    * ```
    */
  get calendarEventHistory(): Prisma.CalendarEventHistoryDelegate<ExtArgs>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs>;

  /**
   * `prisma.notificationSettings`: Exposes CRUD operations for the **NotificationSettings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NotificationSettings
    * const notificationSettings = await prisma.notificationSettings.findMany()
    * ```
    */
  get notificationSettings(): Prisma.NotificationSettingsDelegate<ExtArgs>;

  /**
   * `prisma.oAuthIntegration`: Exposes CRUD operations for the **OAuthIntegration** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OAuthIntegrations
    * const oAuthIntegrations = await prisma.oAuthIntegration.findMany()
    * ```
    */
  get oAuthIntegration(): Prisma.OAuthIntegrationDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.19.1
   * Query Engine version: 69d742ee20b815d88e17e54db4a2a7a3b30324e3
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Household: 'Household',
    HouseholdMember: 'HouseholdMember',
    RecurrenceRule: 'RecurrenceRule',
    Thread: 'Thread',
    Message: 'Message',
    Reaction: 'Reaction',
    Mention: 'Mention',
    Attachment: 'Attachment',
    MessageRead: 'MessageRead',
    Chore: 'Chore',
    Subtask: 'Subtask',
    ChoreAssignment: 'ChoreAssignment',
    ChoreSwapRequest: 'ChoreSwapRequest',
    ChoreTemplate: 'ChoreTemplate',
    SubtaskTemplate: 'SubtaskTemplate',
    ChoreHistory: 'ChoreHistory',
    Expense: 'Expense',
    ExpenseSplit: 'ExpenseSplit',
    Transaction: 'Transaction',
    Receipt: 'Receipt',
    ExpenseHistory: 'ExpenseHistory',
    Event: 'Event',
    EventReminder: 'EventReminder',
    CalendarEventHistory: 'CalendarEventHistory',
    Notification: 'Notification',
    NotificationSettings: 'NotificationSettings',
    OAuthIntegration: 'OAuthIntegration'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "household" | "householdMember" | "recurrenceRule" | "thread" | "message" | "reaction" | "mention" | "attachment" | "messageRead" | "chore" | "subtask" | "choreAssignment" | "choreSwapRequest" | "choreTemplate" | "subtaskTemplate" | "choreHistory" | "expense" | "expenseSplit" | "transaction" | "receipt" | "expenseHistory" | "event" | "eventReminder" | "calendarEventHistory" | "notification" | "notificationSettings" | "oAuthIntegration"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Household: {
        payload: Prisma.$HouseholdPayload<ExtArgs>
        fields: Prisma.HouseholdFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HouseholdFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HouseholdPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HouseholdFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HouseholdPayload>
          }
          findFirst: {
            args: Prisma.HouseholdFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HouseholdPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HouseholdFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HouseholdPayload>
          }
          findMany: {
            args: Prisma.HouseholdFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HouseholdPayload>[]
          }
          create: {
            args: Prisma.HouseholdCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HouseholdPayload>
          }
          createMany: {
            args: Prisma.HouseholdCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HouseholdCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HouseholdPayload>[]
          }
          delete: {
            args: Prisma.HouseholdDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HouseholdPayload>
          }
          update: {
            args: Prisma.HouseholdUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HouseholdPayload>
          }
          deleteMany: {
            args: Prisma.HouseholdDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HouseholdUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.HouseholdUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HouseholdPayload>
          }
          aggregate: {
            args: Prisma.HouseholdAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHousehold>
          }
          groupBy: {
            args: Prisma.HouseholdGroupByArgs<ExtArgs>
            result: $Utils.Optional<HouseholdGroupByOutputType>[]
          }
          count: {
            args: Prisma.HouseholdCountArgs<ExtArgs>
            result: $Utils.Optional<HouseholdCountAggregateOutputType> | number
          }
        }
      }
      HouseholdMember: {
        payload: Prisma.$HouseholdMemberPayload<ExtArgs>
        fields: Prisma.HouseholdMemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HouseholdMemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HouseholdMemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HouseholdMemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HouseholdMemberPayload>
          }
          findFirst: {
            args: Prisma.HouseholdMemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HouseholdMemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HouseholdMemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HouseholdMemberPayload>
          }
          findMany: {
            args: Prisma.HouseholdMemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HouseholdMemberPayload>[]
          }
          create: {
            args: Prisma.HouseholdMemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HouseholdMemberPayload>
          }
          createMany: {
            args: Prisma.HouseholdMemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HouseholdMemberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HouseholdMemberPayload>[]
          }
          delete: {
            args: Prisma.HouseholdMemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HouseholdMemberPayload>
          }
          update: {
            args: Prisma.HouseholdMemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HouseholdMemberPayload>
          }
          deleteMany: {
            args: Prisma.HouseholdMemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HouseholdMemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.HouseholdMemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HouseholdMemberPayload>
          }
          aggregate: {
            args: Prisma.HouseholdMemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHouseholdMember>
          }
          groupBy: {
            args: Prisma.HouseholdMemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<HouseholdMemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.HouseholdMemberCountArgs<ExtArgs>
            result: $Utils.Optional<HouseholdMemberCountAggregateOutputType> | number
          }
        }
      }
      RecurrenceRule: {
        payload: Prisma.$RecurrenceRulePayload<ExtArgs>
        fields: Prisma.RecurrenceRuleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RecurrenceRuleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurrenceRulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RecurrenceRuleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurrenceRulePayload>
          }
          findFirst: {
            args: Prisma.RecurrenceRuleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurrenceRulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RecurrenceRuleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurrenceRulePayload>
          }
          findMany: {
            args: Prisma.RecurrenceRuleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurrenceRulePayload>[]
          }
          create: {
            args: Prisma.RecurrenceRuleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurrenceRulePayload>
          }
          createMany: {
            args: Prisma.RecurrenceRuleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RecurrenceRuleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurrenceRulePayload>[]
          }
          delete: {
            args: Prisma.RecurrenceRuleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurrenceRulePayload>
          }
          update: {
            args: Prisma.RecurrenceRuleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurrenceRulePayload>
          }
          deleteMany: {
            args: Prisma.RecurrenceRuleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RecurrenceRuleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RecurrenceRuleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurrenceRulePayload>
          }
          aggregate: {
            args: Prisma.RecurrenceRuleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRecurrenceRule>
          }
          groupBy: {
            args: Prisma.RecurrenceRuleGroupByArgs<ExtArgs>
            result: $Utils.Optional<RecurrenceRuleGroupByOutputType>[]
          }
          count: {
            args: Prisma.RecurrenceRuleCountArgs<ExtArgs>
            result: $Utils.Optional<RecurrenceRuleCountAggregateOutputType> | number
          }
        }
      }
      Thread: {
        payload: Prisma.$ThreadPayload<ExtArgs>
        fields: Prisma.ThreadFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ThreadFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThreadPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ThreadFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThreadPayload>
          }
          findFirst: {
            args: Prisma.ThreadFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThreadPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ThreadFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThreadPayload>
          }
          findMany: {
            args: Prisma.ThreadFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThreadPayload>[]
          }
          create: {
            args: Prisma.ThreadCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThreadPayload>
          }
          createMany: {
            args: Prisma.ThreadCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ThreadCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThreadPayload>[]
          }
          delete: {
            args: Prisma.ThreadDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThreadPayload>
          }
          update: {
            args: Prisma.ThreadUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThreadPayload>
          }
          deleteMany: {
            args: Prisma.ThreadDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ThreadUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ThreadUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThreadPayload>
          }
          aggregate: {
            args: Prisma.ThreadAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateThread>
          }
          groupBy: {
            args: Prisma.ThreadGroupByArgs<ExtArgs>
            result: $Utils.Optional<ThreadGroupByOutputType>[]
          }
          count: {
            args: Prisma.ThreadCountArgs<ExtArgs>
            result: $Utils.Optional<ThreadCountAggregateOutputType> | number
          }
        }
      }
      Message: {
        payload: Prisma.$MessagePayload<ExtArgs>
        fields: Prisma.MessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findFirst: {
            args: Prisma.MessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findMany: {
            args: Prisma.MessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          create: {
            args: Prisma.MessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          createMany: {
            args: Prisma.MessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          delete: {
            args: Prisma.MessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          update: {
            args: Prisma.MessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          deleteMany: {
            args: Prisma.MessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          aggregate: {
            args: Prisma.MessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessage>
          }
          groupBy: {
            args: Prisma.MessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageCountArgs<ExtArgs>
            result: $Utils.Optional<MessageCountAggregateOutputType> | number
          }
        }
      }
      Reaction: {
        payload: Prisma.$ReactionPayload<ExtArgs>
        fields: Prisma.ReactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReactionPayload>
          }
          findFirst: {
            args: Prisma.ReactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReactionPayload>
          }
          findMany: {
            args: Prisma.ReactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReactionPayload>[]
          }
          create: {
            args: Prisma.ReactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReactionPayload>
          }
          createMany: {
            args: Prisma.ReactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReactionPayload>[]
          }
          delete: {
            args: Prisma.ReactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReactionPayload>
          }
          update: {
            args: Prisma.ReactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReactionPayload>
          }
          deleteMany: {
            args: Prisma.ReactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ReactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReactionPayload>
          }
          aggregate: {
            args: Prisma.ReactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReaction>
          }
          groupBy: {
            args: Prisma.ReactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReactionCountArgs<ExtArgs>
            result: $Utils.Optional<ReactionCountAggregateOutputType> | number
          }
        }
      }
      Mention: {
        payload: Prisma.$MentionPayload<ExtArgs>
        fields: Prisma.MentionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MentionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MentionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentionPayload>
          }
          findFirst: {
            args: Prisma.MentionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MentionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentionPayload>
          }
          findMany: {
            args: Prisma.MentionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentionPayload>[]
          }
          create: {
            args: Prisma.MentionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentionPayload>
          }
          createMany: {
            args: Prisma.MentionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MentionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentionPayload>[]
          }
          delete: {
            args: Prisma.MentionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentionPayload>
          }
          update: {
            args: Prisma.MentionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentionPayload>
          }
          deleteMany: {
            args: Prisma.MentionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MentionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MentionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentionPayload>
          }
          aggregate: {
            args: Prisma.MentionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMention>
          }
          groupBy: {
            args: Prisma.MentionGroupByArgs<ExtArgs>
            result: $Utils.Optional<MentionGroupByOutputType>[]
          }
          count: {
            args: Prisma.MentionCountArgs<ExtArgs>
            result: $Utils.Optional<MentionCountAggregateOutputType> | number
          }
        }
      }
      Attachment: {
        payload: Prisma.$AttachmentPayload<ExtArgs>
        fields: Prisma.AttachmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AttachmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AttachmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>
          }
          findFirst: {
            args: Prisma.AttachmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AttachmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>
          }
          findMany: {
            args: Prisma.AttachmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>[]
          }
          create: {
            args: Prisma.AttachmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>
          }
          createMany: {
            args: Prisma.AttachmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AttachmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>[]
          }
          delete: {
            args: Prisma.AttachmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>
          }
          update: {
            args: Prisma.AttachmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>
          }
          deleteMany: {
            args: Prisma.AttachmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AttachmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AttachmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>
          }
          aggregate: {
            args: Prisma.AttachmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAttachment>
          }
          groupBy: {
            args: Prisma.AttachmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<AttachmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.AttachmentCountArgs<ExtArgs>
            result: $Utils.Optional<AttachmentCountAggregateOutputType> | number
          }
        }
      }
      MessageRead: {
        payload: Prisma.$MessageReadPayload<ExtArgs>
        fields: Prisma.MessageReadFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageReadFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageReadPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageReadFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageReadPayload>
          }
          findFirst: {
            args: Prisma.MessageReadFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageReadPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageReadFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageReadPayload>
          }
          findMany: {
            args: Prisma.MessageReadFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageReadPayload>[]
          }
          create: {
            args: Prisma.MessageReadCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageReadPayload>
          }
          createMany: {
            args: Prisma.MessageReadCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MessageReadCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageReadPayload>[]
          }
          delete: {
            args: Prisma.MessageReadDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageReadPayload>
          }
          update: {
            args: Prisma.MessageReadUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageReadPayload>
          }
          deleteMany: {
            args: Prisma.MessageReadDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageReadUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MessageReadUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageReadPayload>
          }
          aggregate: {
            args: Prisma.MessageReadAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessageRead>
          }
          groupBy: {
            args: Prisma.MessageReadGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageReadGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageReadCountArgs<ExtArgs>
            result: $Utils.Optional<MessageReadCountAggregateOutputType> | number
          }
        }
      }
      Chore: {
        payload: Prisma.$ChorePayload<ExtArgs>
        fields: Prisma.ChoreFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChoreFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChorePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChoreFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChorePayload>
          }
          findFirst: {
            args: Prisma.ChoreFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChorePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChoreFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChorePayload>
          }
          findMany: {
            args: Prisma.ChoreFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChorePayload>[]
          }
          create: {
            args: Prisma.ChoreCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChorePayload>
          }
          createMany: {
            args: Prisma.ChoreCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChoreCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChorePayload>[]
          }
          delete: {
            args: Prisma.ChoreDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChorePayload>
          }
          update: {
            args: Prisma.ChoreUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChorePayload>
          }
          deleteMany: {
            args: Prisma.ChoreDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChoreUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ChoreUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChorePayload>
          }
          aggregate: {
            args: Prisma.ChoreAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChore>
          }
          groupBy: {
            args: Prisma.ChoreGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChoreGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChoreCountArgs<ExtArgs>
            result: $Utils.Optional<ChoreCountAggregateOutputType> | number
          }
        }
      }
      Subtask: {
        payload: Prisma.$SubtaskPayload<ExtArgs>
        fields: Prisma.SubtaskFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubtaskFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubtaskPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubtaskFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubtaskPayload>
          }
          findFirst: {
            args: Prisma.SubtaskFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubtaskPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubtaskFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubtaskPayload>
          }
          findMany: {
            args: Prisma.SubtaskFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubtaskPayload>[]
          }
          create: {
            args: Prisma.SubtaskCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubtaskPayload>
          }
          createMany: {
            args: Prisma.SubtaskCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubtaskCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubtaskPayload>[]
          }
          delete: {
            args: Prisma.SubtaskDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubtaskPayload>
          }
          update: {
            args: Prisma.SubtaskUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubtaskPayload>
          }
          deleteMany: {
            args: Prisma.SubtaskDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubtaskUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SubtaskUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubtaskPayload>
          }
          aggregate: {
            args: Prisma.SubtaskAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubtask>
          }
          groupBy: {
            args: Prisma.SubtaskGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubtaskGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubtaskCountArgs<ExtArgs>
            result: $Utils.Optional<SubtaskCountAggregateOutputType> | number
          }
        }
      }
      ChoreAssignment: {
        payload: Prisma.$ChoreAssignmentPayload<ExtArgs>
        fields: Prisma.ChoreAssignmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChoreAssignmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChoreAssignmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChoreAssignmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChoreAssignmentPayload>
          }
          findFirst: {
            args: Prisma.ChoreAssignmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChoreAssignmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChoreAssignmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChoreAssignmentPayload>
          }
          findMany: {
            args: Prisma.ChoreAssignmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChoreAssignmentPayload>[]
          }
          create: {
            args: Prisma.ChoreAssignmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChoreAssignmentPayload>
          }
          createMany: {
            args: Prisma.ChoreAssignmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChoreAssignmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChoreAssignmentPayload>[]
          }
          delete: {
            args: Prisma.ChoreAssignmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChoreAssignmentPayload>
          }
          update: {
            args: Prisma.ChoreAssignmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChoreAssignmentPayload>
          }
          deleteMany: {
            args: Prisma.ChoreAssignmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChoreAssignmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ChoreAssignmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChoreAssignmentPayload>
          }
          aggregate: {
            args: Prisma.ChoreAssignmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChoreAssignment>
          }
          groupBy: {
            args: Prisma.ChoreAssignmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChoreAssignmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChoreAssignmentCountArgs<ExtArgs>
            result: $Utils.Optional<ChoreAssignmentCountAggregateOutputType> | number
          }
        }
      }
      ChoreSwapRequest: {
        payload: Prisma.$ChoreSwapRequestPayload<ExtArgs>
        fields: Prisma.ChoreSwapRequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChoreSwapRequestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChoreSwapRequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChoreSwapRequestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChoreSwapRequestPayload>
          }
          findFirst: {
            args: Prisma.ChoreSwapRequestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChoreSwapRequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChoreSwapRequestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChoreSwapRequestPayload>
          }
          findMany: {
            args: Prisma.ChoreSwapRequestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChoreSwapRequestPayload>[]
          }
          create: {
            args: Prisma.ChoreSwapRequestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChoreSwapRequestPayload>
          }
          createMany: {
            args: Prisma.ChoreSwapRequestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChoreSwapRequestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChoreSwapRequestPayload>[]
          }
          delete: {
            args: Prisma.ChoreSwapRequestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChoreSwapRequestPayload>
          }
          update: {
            args: Prisma.ChoreSwapRequestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChoreSwapRequestPayload>
          }
          deleteMany: {
            args: Prisma.ChoreSwapRequestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChoreSwapRequestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ChoreSwapRequestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChoreSwapRequestPayload>
          }
          aggregate: {
            args: Prisma.ChoreSwapRequestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChoreSwapRequest>
          }
          groupBy: {
            args: Prisma.ChoreSwapRequestGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChoreSwapRequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChoreSwapRequestCountArgs<ExtArgs>
            result: $Utils.Optional<ChoreSwapRequestCountAggregateOutputType> | number
          }
        }
      }
      ChoreTemplate: {
        payload: Prisma.$ChoreTemplatePayload<ExtArgs>
        fields: Prisma.ChoreTemplateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChoreTemplateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChoreTemplatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChoreTemplateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChoreTemplatePayload>
          }
          findFirst: {
            args: Prisma.ChoreTemplateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChoreTemplatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChoreTemplateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChoreTemplatePayload>
          }
          findMany: {
            args: Prisma.ChoreTemplateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChoreTemplatePayload>[]
          }
          create: {
            args: Prisma.ChoreTemplateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChoreTemplatePayload>
          }
          createMany: {
            args: Prisma.ChoreTemplateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChoreTemplateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChoreTemplatePayload>[]
          }
          delete: {
            args: Prisma.ChoreTemplateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChoreTemplatePayload>
          }
          update: {
            args: Prisma.ChoreTemplateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChoreTemplatePayload>
          }
          deleteMany: {
            args: Prisma.ChoreTemplateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChoreTemplateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ChoreTemplateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChoreTemplatePayload>
          }
          aggregate: {
            args: Prisma.ChoreTemplateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChoreTemplate>
          }
          groupBy: {
            args: Prisma.ChoreTemplateGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChoreTemplateGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChoreTemplateCountArgs<ExtArgs>
            result: $Utils.Optional<ChoreTemplateCountAggregateOutputType> | number
          }
        }
      }
      SubtaskTemplate: {
        payload: Prisma.$SubtaskTemplatePayload<ExtArgs>
        fields: Prisma.SubtaskTemplateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubtaskTemplateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubtaskTemplatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubtaskTemplateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubtaskTemplatePayload>
          }
          findFirst: {
            args: Prisma.SubtaskTemplateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubtaskTemplatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubtaskTemplateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubtaskTemplatePayload>
          }
          findMany: {
            args: Prisma.SubtaskTemplateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubtaskTemplatePayload>[]
          }
          create: {
            args: Prisma.SubtaskTemplateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubtaskTemplatePayload>
          }
          createMany: {
            args: Prisma.SubtaskTemplateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubtaskTemplateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubtaskTemplatePayload>[]
          }
          delete: {
            args: Prisma.SubtaskTemplateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubtaskTemplatePayload>
          }
          update: {
            args: Prisma.SubtaskTemplateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubtaskTemplatePayload>
          }
          deleteMany: {
            args: Prisma.SubtaskTemplateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubtaskTemplateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SubtaskTemplateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubtaskTemplatePayload>
          }
          aggregate: {
            args: Prisma.SubtaskTemplateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubtaskTemplate>
          }
          groupBy: {
            args: Prisma.SubtaskTemplateGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubtaskTemplateGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubtaskTemplateCountArgs<ExtArgs>
            result: $Utils.Optional<SubtaskTemplateCountAggregateOutputType> | number
          }
        }
      }
      ChoreHistory: {
        payload: Prisma.$ChoreHistoryPayload<ExtArgs>
        fields: Prisma.ChoreHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChoreHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChoreHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChoreHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChoreHistoryPayload>
          }
          findFirst: {
            args: Prisma.ChoreHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChoreHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChoreHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChoreHistoryPayload>
          }
          findMany: {
            args: Prisma.ChoreHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChoreHistoryPayload>[]
          }
          create: {
            args: Prisma.ChoreHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChoreHistoryPayload>
          }
          createMany: {
            args: Prisma.ChoreHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChoreHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChoreHistoryPayload>[]
          }
          delete: {
            args: Prisma.ChoreHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChoreHistoryPayload>
          }
          update: {
            args: Prisma.ChoreHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChoreHistoryPayload>
          }
          deleteMany: {
            args: Prisma.ChoreHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChoreHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ChoreHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChoreHistoryPayload>
          }
          aggregate: {
            args: Prisma.ChoreHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChoreHistory>
          }
          groupBy: {
            args: Prisma.ChoreHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChoreHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChoreHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<ChoreHistoryCountAggregateOutputType> | number
          }
        }
      }
      Expense: {
        payload: Prisma.$ExpensePayload<ExtArgs>
        fields: Prisma.ExpenseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExpenseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExpenseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          findFirst: {
            args: Prisma.ExpenseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExpenseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          findMany: {
            args: Prisma.ExpenseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>[]
          }
          create: {
            args: Prisma.ExpenseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          createMany: {
            args: Prisma.ExpenseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExpenseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>[]
          }
          delete: {
            args: Prisma.ExpenseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          update: {
            args: Prisma.ExpenseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          deleteMany: {
            args: Prisma.ExpenseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExpenseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ExpenseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          aggregate: {
            args: Prisma.ExpenseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExpense>
          }
          groupBy: {
            args: Prisma.ExpenseGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExpenseGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExpenseCountArgs<ExtArgs>
            result: $Utils.Optional<ExpenseCountAggregateOutputType> | number
          }
        }
      }
      ExpenseSplit: {
        payload: Prisma.$ExpenseSplitPayload<ExtArgs>
        fields: Prisma.ExpenseSplitFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExpenseSplitFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseSplitPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExpenseSplitFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseSplitPayload>
          }
          findFirst: {
            args: Prisma.ExpenseSplitFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseSplitPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExpenseSplitFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseSplitPayload>
          }
          findMany: {
            args: Prisma.ExpenseSplitFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseSplitPayload>[]
          }
          create: {
            args: Prisma.ExpenseSplitCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseSplitPayload>
          }
          createMany: {
            args: Prisma.ExpenseSplitCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExpenseSplitCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseSplitPayload>[]
          }
          delete: {
            args: Prisma.ExpenseSplitDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseSplitPayload>
          }
          update: {
            args: Prisma.ExpenseSplitUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseSplitPayload>
          }
          deleteMany: {
            args: Prisma.ExpenseSplitDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExpenseSplitUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ExpenseSplitUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseSplitPayload>
          }
          aggregate: {
            args: Prisma.ExpenseSplitAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExpenseSplit>
          }
          groupBy: {
            args: Prisma.ExpenseSplitGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExpenseSplitGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExpenseSplitCountArgs<ExtArgs>
            result: $Utils.Optional<ExpenseSplitCountAggregateOutputType> | number
          }
        }
      }
      Transaction: {
        payload: Prisma.$TransactionPayload<ExtArgs>
        fields: Prisma.TransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findFirst: {
            args: Prisma.TransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findMany: {
            args: Prisma.TransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          create: {
            args: Prisma.TransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          createMany: {
            args: Prisma.TransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          delete: {
            args: Prisma.TransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          update: {
            args: Prisma.TransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          deleteMany: {
            args: Prisma.TransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          aggregate: {
            args: Prisma.TransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransaction>
          }
          groupBy: {
            args: Prisma.TransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransactionCountArgs<ExtArgs>
            result: $Utils.Optional<TransactionCountAggregateOutputType> | number
          }
        }
      }
      Receipt: {
        payload: Prisma.$ReceiptPayload<ExtArgs>
        fields: Prisma.ReceiptFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReceiptFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceiptPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReceiptFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceiptPayload>
          }
          findFirst: {
            args: Prisma.ReceiptFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceiptPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReceiptFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceiptPayload>
          }
          findMany: {
            args: Prisma.ReceiptFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceiptPayload>[]
          }
          create: {
            args: Prisma.ReceiptCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceiptPayload>
          }
          createMany: {
            args: Prisma.ReceiptCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReceiptCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceiptPayload>[]
          }
          delete: {
            args: Prisma.ReceiptDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceiptPayload>
          }
          update: {
            args: Prisma.ReceiptUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceiptPayload>
          }
          deleteMany: {
            args: Prisma.ReceiptDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReceiptUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ReceiptUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceiptPayload>
          }
          aggregate: {
            args: Prisma.ReceiptAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReceipt>
          }
          groupBy: {
            args: Prisma.ReceiptGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReceiptGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReceiptCountArgs<ExtArgs>
            result: $Utils.Optional<ReceiptCountAggregateOutputType> | number
          }
        }
      }
      ExpenseHistory: {
        payload: Prisma.$ExpenseHistoryPayload<ExtArgs>
        fields: Prisma.ExpenseHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExpenseHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExpenseHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseHistoryPayload>
          }
          findFirst: {
            args: Prisma.ExpenseHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExpenseHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseHistoryPayload>
          }
          findMany: {
            args: Prisma.ExpenseHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseHistoryPayload>[]
          }
          create: {
            args: Prisma.ExpenseHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseHistoryPayload>
          }
          createMany: {
            args: Prisma.ExpenseHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExpenseHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseHistoryPayload>[]
          }
          delete: {
            args: Prisma.ExpenseHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseHistoryPayload>
          }
          update: {
            args: Prisma.ExpenseHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseHistoryPayload>
          }
          deleteMany: {
            args: Prisma.ExpenseHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExpenseHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ExpenseHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseHistoryPayload>
          }
          aggregate: {
            args: Prisma.ExpenseHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExpenseHistory>
          }
          groupBy: {
            args: Prisma.ExpenseHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExpenseHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExpenseHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<ExpenseHistoryCountAggregateOutputType> | number
          }
        }
      }
      Event: {
        payload: Prisma.$EventPayload<ExtArgs>
        fields: Prisma.EventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          findFirst: {
            args: Prisma.EventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          findMany: {
            args: Prisma.EventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>[]
          }
          create: {
            args: Prisma.EventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          createMany: {
            args: Prisma.EventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>[]
          }
          delete: {
            args: Prisma.EventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          update: {
            args: Prisma.EventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          deleteMany: {
            args: Prisma.EventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          aggregate: {
            args: Prisma.EventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEvent>
          }
          groupBy: {
            args: Prisma.EventGroupByArgs<ExtArgs>
            result: $Utils.Optional<EventGroupByOutputType>[]
          }
          count: {
            args: Prisma.EventCountArgs<ExtArgs>
            result: $Utils.Optional<EventCountAggregateOutputType> | number
          }
        }
      }
      EventReminder: {
        payload: Prisma.$EventReminderPayload<ExtArgs>
        fields: Prisma.EventReminderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EventReminderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventReminderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EventReminderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventReminderPayload>
          }
          findFirst: {
            args: Prisma.EventReminderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventReminderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EventReminderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventReminderPayload>
          }
          findMany: {
            args: Prisma.EventReminderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventReminderPayload>[]
          }
          create: {
            args: Prisma.EventReminderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventReminderPayload>
          }
          createMany: {
            args: Prisma.EventReminderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EventReminderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventReminderPayload>[]
          }
          delete: {
            args: Prisma.EventReminderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventReminderPayload>
          }
          update: {
            args: Prisma.EventReminderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventReminderPayload>
          }
          deleteMany: {
            args: Prisma.EventReminderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EventReminderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EventReminderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventReminderPayload>
          }
          aggregate: {
            args: Prisma.EventReminderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEventReminder>
          }
          groupBy: {
            args: Prisma.EventReminderGroupByArgs<ExtArgs>
            result: $Utils.Optional<EventReminderGroupByOutputType>[]
          }
          count: {
            args: Prisma.EventReminderCountArgs<ExtArgs>
            result: $Utils.Optional<EventReminderCountAggregateOutputType> | number
          }
        }
      }
      CalendarEventHistory: {
        payload: Prisma.$CalendarEventHistoryPayload<ExtArgs>
        fields: Prisma.CalendarEventHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CalendarEventHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEventHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CalendarEventHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEventHistoryPayload>
          }
          findFirst: {
            args: Prisma.CalendarEventHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEventHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CalendarEventHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEventHistoryPayload>
          }
          findMany: {
            args: Prisma.CalendarEventHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEventHistoryPayload>[]
          }
          create: {
            args: Prisma.CalendarEventHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEventHistoryPayload>
          }
          createMany: {
            args: Prisma.CalendarEventHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CalendarEventHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEventHistoryPayload>[]
          }
          delete: {
            args: Prisma.CalendarEventHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEventHistoryPayload>
          }
          update: {
            args: Prisma.CalendarEventHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEventHistoryPayload>
          }
          deleteMany: {
            args: Prisma.CalendarEventHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CalendarEventHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CalendarEventHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEventHistoryPayload>
          }
          aggregate: {
            args: Prisma.CalendarEventHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCalendarEventHistory>
          }
          groupBy: {
            args: Prisma.CalendarEventHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CalendarEventHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CalendarEventHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<CalendarEventHistoryCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      NotificationSettings: {
        payload: Prisma.$NotificationSettingsPayload<ExtArgs>
        fields: Prisma.NotificationSettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationSettingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationSettingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSettingsPayload>
          }
          findFirst: {
            args: Prisma.NotificationSettingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationSettingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSettingsPayload>
          }
          findMany: {
            args: Prisma.NotificationSettingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSettingsPayload>[]
          }
          create: {
            args: Prisma.NotificationSettingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSettingsPayload>
          }
          createMany: {
            args: Prisma.NotificationSettingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationSettingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSettingsPayload>[]
          }
          delete: {
            args: Prisma.NotificationSettingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSettingsPayload>
          }
          update: {
            args: Prisma.NotificationSettingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSettingsPayload>
          }
          deleteMany: {
            args: Prisma.NotificationSettingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationSettingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NotificationSettingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSettingsPayload>
          }
          aggregate: {
            args: Prisma.NotificationSettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotificationSettings>
          }
          groupBy: {
            args: Prisma.NotificationSettingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationSettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationSettingsCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationSettingsCountAggregateOutputType> | number
          }
        }
      }
      OAuthIntegration: {
        payload: Prisma.$OAuthIntegrationPayload<ExtArgs>
        fields: Prisma.OAuthIntegrationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OAuthIntegrationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OAuthIntegrationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OAuthIntegrationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OAuthIntegrationPayload>
          }
          findFirst: {
            args: Prisma.OAuthIntegrationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OAuthIntegrationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OAuthIntegrationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OAuthIntegrationPayload>
          }
          findMany: {
            args: Prisma.OAuthIntegrationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OAuthIntegrationPayload>[]
          }
          create: {
            args: Prisma.OAuthIntegrationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OAuthIntegrationPayload>
          }
          createMany: {
            args: Prisma.OAuthIntegrationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OAuthIntegrationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OAuthIntegrationPayload>[]
          }
          delete: {
            args: Prisma.OAuthIntegrationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OAuthIntegrationPayload>
          }
          update: {
            args: Prisma.OAuthIntegrationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OAuthIntegrationPayload>
          }
          deleteMany: {
            args: Prisma.OAuthIntegrationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OAuthIntegrationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OAuthIntegrationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OAuthIntegrationPayload>
          }
          aggregate: {
            args: Prisma.OAuthIntegrationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOAuthIntegration>
          }
          groupBy: {
            args: Prisma.OAuthIntegrationGroupByArgs<ExtArgs>
            result: $Utils.Optional<OAuthIntegrationGroupByOutputType>[]
          }
          count: {
            args: Prisma.OAuthIntegrationCountArgs<ExtArgs>
            result: $Utils.Optional<OAuthIntegrationCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    households: number
    messages: number
    threads: number
    assignedChores: number
    expensesPaid: number
    expenseSplits: number
    transactionsFrom: number
    transactionsTo: number
    notifications: number
    oauthIntegrations: number
    eventsCreated: number
    choreSwapRequestsInitiated: number
    choreSwapRequestsReceived: number
    reactions: number
    mentions: number
    choreHistory: number
    notificationSettings: number
    calendarEventHistory: number
    expenseHistory: number
    messageReads: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    households?: boolean | UserCountOutputTypeCountHouseholdsArgs
    messages?: boolean | UserCountOutputTypeCountMessagesArgs
    threads?: boolean | UserCountOutputTypeCountThreadsArgs
    assignedChores?: boolean | UserCountOutputTypeCountAssignedChoresArgs
    expensesPaid?: boolean | UserCountOutputTypeCountExpensesPaidArgs
    expenseSplits?: boolean | UserCountOutputTypeCountExpenseSplitsArgs
    transactionsFrom?: boolean | UserCountOutputTypeCountTransactionsFromArgs
    transactionsTo?: boolean | UserCountOutputTypeCountTransactionsToArgs
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
    oauthIntegrations?: boolean | UserCountOutputTypeCountOauthIntegrationsArgs
    eventsCreated?: boolean | UserCountOutputTypeCountEventsCreatedArgs
    choreSwapRequestsInitiated?: boolean | UserCountOutputTypeCountChoreSwapRequestsInitiatedArgs
    choreSwapRequestsReceived?: boolean | UserCountOutputTypeCountChoreSwapRequestsReceivedArgs
    reactions?: boolean | UserCountOutputTypeCountReactionsArgs
    mentions?: boolean | UserCountOutputTypeCountMentionsArgs
    choreHistory?: boolean | UserCountOutputTypeCountChoreHistoryArgs
    notificationSettings?: boolean | UserCountOutputTypeCountNotificationSettingsArgs
    calendarEventHistory?: boolean | UserCountOutputTypeCountCalendarEventHistoryArgs
    expenseHistory?: boolean | UserCountOutputTypeCountExpenseHistoryArgs
    messageReads?: boolean | UserCountOutputTypeCountMessageReadsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountHouseholdsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HouseholdMemberWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountThreadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ThreadWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAssignedChoresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChoreAssignmentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountExpensesPaidArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpenseWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountExpenseSplitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpenseSplitWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTransactionsFromArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTransactionsToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOauthIntegrationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OAuthIntegrationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEventsCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountChoreSwapRequestsInitiatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChoreSwapRequestWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountChoreSwapRequestsReceivedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChoreSwapRequestWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReactionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMentionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MentionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountChoreHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChoreHistoryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationSettingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationSettingsWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCalendarEventHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CalendarEventHistoryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountExpenseHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpenseHistoryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMessageReadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageReadWhereInput
  }


  /**
   * Count Type HouseholdCountOutputType
   */

  export type HouseholdCountOutputType = {
    members: number
    threads: number
    chores: number
    expenses: number
    events: number
    choreTemplates: number
    notificationSettings: number
  }

  export type HouseholdCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | HouseholdCountOutputTypeCountMembersArgs
    threads?: boolean | HouseholdCountOutputTypeCountThreadsArgs
    chores?: boolean | HouseholdCountOutputTypeCountChoresArgs
    expenses?: boolean | HouseholdCountOutputTypeCountExpensesArgs
    events?: boolean | HouseholdCountOutputTypeCountEventsArgs
    choreTemplates?: boolean | HouseholdCountOutputTypeCountChoreTemplatesArgs
    notificationSettings?: boolean | HouseholdCountOutputTypeCountNotificationSettingsArgs
  }

  // Custom InputTypes
  /**
   * HouseholdCountOutputType without action
   */
  export type HouseholdCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HouseholdCountOutputType
     */
    select?: HouseholdCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * HouseholdCountOutputType without action
   */
  export type HouseholdCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HouseholdMemberWhereInput
  }

  /**
   * HouseholdCountOutputType without action
   */
  export type HouseholdCountOutputTypeCountThreadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ThreadWhereInput
  }

  /**
   * HouseholdCountOutputType without action
   */
  export type HouseholdCountOutputTypeCountChoresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChoreWhereInput
  }

  /**
   * HouseholdCountOutputType without action
   */
  export type HouseholdCountOutputTypeCountExpensesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpenseWhereInput
  }

  /**
   * HouseholdCountOutputType without action
   */
  export type HouseholdCountOutputTypeCountEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventWhereInput
  }

  /**
   * HouseholdCountOutputType without action
   */
  export type HouseholdCountOutputTypeCountChoreTemplatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChoreTemplateWhereInput
  }

  /**
   * HouseholdCountOutputType without action
   */
  export type HouseholdCountOutputTypeCountNotificationSettingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationSettingsWhereInput
  }


  /**
   * Count Type HouseholdMemberCountOutputType
   */

  export type HouseholdMemberCountOutputType = {
    threads: number
  }

  export type HouseholdMemberCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    threads?: boolean | HouseholdMemberCountOutputTypeCountThreadsArgs
  }

  // Custom InputTypes
  /**
   * HouseholdMemberCountOutputType without action
   */
  export type HouseholdMemberCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HouseholdMemberCountOutputType
     */
    select?: HouseholdMemberCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * HouseholdMemberCountOutputType without action
   */
  export type HouseholdMemberCountOutputTypeCountThreadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ThreadWhereInput
  }


  /**
   * Count Type RecurrenceRuleCountOutputType
   */

  export type RecurrenceRuleCountOutputType = {
    chores: number
    events: number
  }

  export type RecurrenceRuleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chores?: boolean | RecurrenceRuleCountOutputTypeCountChoresArgs
    events?: boolean | RecurrenceRuleCountOutputTypeCountEventsArgs
  }

  // Custom InputTypes
  /**
   * RecurrenceRuleCountOutputType without action
   */
  export type RecurrenceRuleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurrenceRuleCountOutputType
     */
    select?: RecurrenceRuleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RecurrenceRuleCountOutputType without action
   */
  export type RecurrenceRuleCountOutputTypeCountChoresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChoreWhereInput
  }

  /**
   * RecurrenceRuleCountOutputType without action
   */
  export type RecurrenceRuleCountOutputTypeCountEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventWhereInput
  }


  /**
   * Count Type ThreadCountOutputType
   */

  export type ThreadCountOutputType = {
    messages: number
    participants: number
  }

  export type ThreadCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | ThreadCountOutputTypeCountMessagesArgs
    participants?: boolean | ThreadCountOutputTypeCountParticipantsArgs
  }

  // Custom InputTypes
  /**
   * ThreadCountOutputType without action
   */
  export type ThreadCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThreadCountOutputType
     */
    select?: ThreadCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ThreadCountOutputType without action
   */
  export type ThreadCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }

  /**
   * ThreadCountOutputType without action
   */
  export type ThreadCountOutputTypeCountParticipantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HouseholdMemberWhereInput
  }


  /**
   * Count Type MessageCountOutputType
   */

  export type MessageCountOutputType = {
    attachments: number
    reactions: number
    mentions: number
    reads: number
  }

  export type MessageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attachments?: boolean | MessageCountOutputTypeCountAttachmentsArgs
    reactions?: boolean | MessageCountOutputTypeCountReactionsArgs
    mentions?: boolean | MessageCountOutputTypeCountMentionsArgs
    reads?: boolean | MessageCountOutputTypeCountReadsArgs
  }

  // Custom InputTypes
  /**
   * MessageCountOutputType without action
   */
  export type MessageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageCountOutputType
     */
    select?: MessageCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MessageCountOutputType without action
   */
  export type MessageCountOutputTypeCountAttachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttachmentWhereInput
  }

  /**
   * MessageCountOutputType without action
   */
  export type MessageCountOutputTypeCountReactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReactionWhereInput
  }

  /**
   * MessageCountOutputType without action
   */
  export type MessageCountOutputTypeCountMentionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MentionWhereInput
  }

  /**
   * MessageCountOutputType without action
   */
  export type MessageCountOutputTypeCountReadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageReadWhereInput
  }


  /**
   * Count Type ChoreCountOutputType
   */

  export type ChoreCountOutputType = {
    subtasks: number
    assignedUsers: number
    choreSwapRequests: number
    history: number
  }

  export type ChoreCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subtasks?: boolean | ChoreCountOutputTypeCountSubtasksArgs
    assignedUsers?: boolean | ChoreCountOutputTypeCountAssignedUsersArgs
    choreSwapRequests?: boolean | ChoreCountOutputTypeCountChoreSwapRequestsArgs
    history?: boolean | ChoreCountOutputTypeCountHistoryArgs
  }

  // Custom InputTypes
  /**
   * ChoreCountOutputType without action
   */
  export type ChoreCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChoreCountOutputType
     */
    select?: ChoreCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ChoreCountOutputType without action
   */
  export type ChoreCountOutputTypeCountSubtasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubtaskWhereInput
  }

  /**
   * ChoreCountOutputType without action
   */
  export type ChoreCountOutputTypeCountAssignedUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChoreAssignmentWhereInput
  }

  /**
   * ChoreCountOutputType without action
   */
  export type ChoreCountOutputTypeCountChoreSwapRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChoreSwapRequestWhereInput
  }

  /**
   * ChoreCountOutputType without action
   */
  export type ChoreCountOutputTypeCountHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChoreHistoryWhereInput
  }


  /**
   * Count Type ChoreTemplateCountOutputType
   */

  export type ChoreTemplateCountOutputType = {
    subtasks: number
  }

  export type ChoreTemplateCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subtasks?: boolean | ChoreTemplateCountOutputTypeCountSubtasksArgs
  }

  // Custom InputTypes
  /**
   * ChoreTemplateCountOutputType without action
   */
  export type ChoreTemplateCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChoreTemplateCountOutputType
     */
    select?: ChoreTemplateCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ChoreTemplateCountOutputType without action
   */
  export type ChoreTemplateCountOutputTypeCountSubtasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubtaskTemplateWhereInput
  }


  /**
   * Count Type ExpenseCountOutputType
   */

  export type ExpenseCountOutputType = {
    splits: number
    transactions: number
    receipts: number
    history: number
  }

  export type ExpenseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    splits?: boolean | ExpenseCountOutputTypeCountSplitsArgs
    transactions?: boolean | ExpenseCountOutputTypeCountTransactionsArgs
    receipts?: boolean | ExpenseCountOutputTypeCountReceiptsArgs
    history?: boolean | ExpenseCountOutputTypeCountHistoryArgs
  }

  // Custom InputTypes
  /**
   * ExpenseCountOutputType without action
   */
  export type ExpenseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseCountOutputType
     */
    select?: ExpenseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ExpenseCountOutputType without action
   */
  export type ExpenseCountOutputTypeCountSplitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpenseSplitWhereInput
  }

  /**
   * ExpenseCountOutputType without action
   */
  export type ExpenseCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }

  /**
   * ExpenseCountOutputType without action
   */
  export type ExpenseCountOutputTypeCountReceiptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReceiptWhereInput
  }

  /**
   * ExpenseCountOutputType without action
   */
  export type ExpenseCountOutputTypeCountHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpenseHistoryWhereInput
  }


  /**
   * Count Type EventCountOutputType
   */

  export type EventCountOutputType = {
    reminders: number
    history: number
  }

  export type EventCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reminders?: boolean | EventCountOutputTypeCountRemindersArgs
    history?: boolean | EventCountOutputTypeCountHistoryArgs
  }

  // Custom InputTypes
  /**
   * EventCountOutputType without action
   */
  export type EventCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventCountOutputType
     */
    select?: EventCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EventCountOutputType without action
   */
  export type EventCountOutputTypeCountRemindersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventReminderWhereInput
  }

  /**
   * EventCountOutputType without action
   */
  export type EventCountOutputTypeCountHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CalendarEventHistoryWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    passwordHash: string | null
    name: string | null
    profileImageURL: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    passwordHash: string | null
    name: string | null
    profileImageURL: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    passwordHash: number
    name: number
    profileImageURL: number
    createdAt: number
    updatedAt: number
    deviceTokens: number
    deletedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    name?: true
    profileImageURL?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    name?: true
    profileImageURL?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    name?: true
    profileImageURL?: true
    createdAt?: true
    updatedAt?: true
    deviceTokens?: true
    deletedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    passwordHash: string | null
    name: string
    profileImageURL: string | null
    createdAt: Date
    updatedAt: Date
    deviceTokens: string[]
    deletedAt: Date | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    name?: boolean
    profileImageURL?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deviceTokens?: boolean
    deletedAt?: boolean
    households?: boolean | User$householdsArgs<ExtArgs>
    messages?: boolean | User$messagesArgs<ExtArgs>
    threads?: boolean | User$threadsArgs<ExtArgs>
    assignedChores?: boolean | User$assignedChoresArgs<ExtArgs>
    expensesPaid?: boolean | User$expensesPaidArgs<ExtArgs>
    expenseSplits?: boolean | User$expenseSplitsArgs<ExtArgs>
    transactionsFrom?: boolean | User$transactionsFromArgs<ExtArgs>
    transactionsTo?: boolean | User$transactionsToArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    oauthIntegrations?: boolean | User$oauthIntegrationsArgs<ExtArgs>
    eventsCreated?: boolean | User$eventsCreatedArgs<ExtArgs>
    choreSwapRequestsInitiated?: boolean | User$choreSwapRequestsInitiatedArgs<ExtArgs>
    choreSwapRequestsReceived?: boolean | User$choreSwapRequestsReceivedArgs<ExtArgs>
    reactions?: boolean | User$reactionsArgs<ExtArgs>
    mentions?: boolean | User$mentionsArgs<ExtArgs>
    choreHistory?: boolean | User$choreHistoryArgs<ExtArgs>
    notificationSettings?: boolean | User$notificationSettingsArgs<ExtArgs>
    calendarEventHistory?: boolean | User$calendarEventHistoryArgs<ExtArgs>
    expenseHistory?: boolean | User$expenseHistoryArgs<ExtArgs>
    messageReads?: boolean | User$messageReadsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    name?: boolean
    profileImageURL?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deviceTokens?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    name?: boolean
    profileImageURL?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deviceTokens?: boolean
    deletedAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    households?: boolean | User$householdsArgs<ExtArgs>
    messages?: boolean | User$messagesArgs<ExtArgs>
    threads?: boolean | User$threadsArgs<ExtArgs>
    assignedChores?: boolean | User$assignedChoresArgs<ExtArgs>
    expensesPaid?: boolean | User$expensesPaidArgs<ExtArgs>
    expenseSplits?: boolean | User$expenseSplitsArgs<ExtArgs>
    transactionsFrom?: boolean | User$transactionsFromArgs<ExtArgs>
    transactionsTo?: boolean | User$transactionsToArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    oauthIntegrations?: boolean | User$oauthIntegrationsArgs<ExtArgs>
    eventsCreated?: boolean | User$eventsCreatedArgs<ExtArgs>
    choreSwapRequestsInitiated?: boolean | User$choreSwapRequestsInitiatedArgs<ExtArgs>
    choreSwapRequestsReceived?: boolean | User$choreSwapRequestsReceivedArgs<ExtArgs>
    reactions?: boolean | User$reactionsArgs<ExtArgs>
    mentions?: boolean | User$mentionsArgs<ExtArgs>
    choreHistory?: boolean | User$choreHistoryArgs<ExtArgs>
    notificationSettings?: boolean | User$notificationSettingsArgs<ExtArgs>
    calendarEventHistory?: boolean | User$calendarEventHistoryArgs<ExtArgs>
    expenseHistory?: boolean | User$expenseHistoryArgs<ExtArgs>
    messageReads?: boolean | User$messageReadsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      households: Prisma.$HouseholdMemberPayload<ExtArgs>[]
      messages: Prisma.$MessagePayload<ExtArgs>[]
      threads: Prisma.$ThreadPayload<ExtArgs>[]
      assignedChores: Prisma.$ChoreAssignmentPayload<ExtArgs>[]
      expensesPaid: Prisma.$ExpensePayload<ExtArgs>[]
      expenseSplits: Prisma.$ExpenseSplitPayload<ExtArgs>[]
      transactionsFrom: Prisma.$TransactionPayload<ExtArgs>[]
      transactionsTo: Prisma.$TransactionPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      oauthIntegrations: Prisma.$OAuthIntegrationPayload<ExtArgs>[]
      eventsCreated: Prisma.$EventPayload<ExtArgs>[]
      choreSwapRequestsInitiated: Prisma.$ChoreSwapRequestPayload<ExtArgs>[]
      choreSwapRequestsReceived: Prisma.$ChoreSwapRequestPayload<ExtArgs>[]
      reactions: Prisma.$ReactionPayload<ExtArgs>[]
      mentions: Prisma.$MentionPayload<ExtArgs>[]
      choreHistory: Prisma.$ChoreHistoryPayload<ExtArgs>[]
      notificationSettings: Prisma.$NotificationSettingsPayload<ExtArgs>[]
      calendarEventHistory: Prisma.$CalendarEventHistoryPayload<ExtArgs>[]
      expenseHistory: Prisma.$ExpenseHistoryPayload<ExtArgs>[]
      messageReads: Prisma.$MessageReadPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      passwordHash: string | null
      name: string
      profileImageURL: string | null
      createdAt: Date
      updatedAt: Date
      deviceTokens: string[]
      deletedAt: Date | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    households<T extends User$householdsArgs<ExtArgs> = {}>(args?: Subset<T, User$householdsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HouseholdMemberPayload<ExtArgs>, T, "findMany"> | Null>
    messages<T extends User$messagesArgs<ExtArgs> = {}>(args?: Subset<T, User$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany"> | Null>
    threads<T extends User$threadsArgs<ExtArgs> = {}>(args?: Subset<T, User$threadsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ThreadPayload<ExtArgs>, T, "findMany"> | Null>
    assignedChores<T extends User$assignedChoresArgs<ExtArgs> = {}>(args?: Subset<T, User$assignedChoresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChoreAssignmentPayload<ExtArgs>, T, "findMany"> | Null>
    expensesPaid<T extends User$expensesPaidArgs<ExtArgs> = {}>(args?: Subset<T, User$expensesPaidArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findMany"> | Null>
    expenseSplits<T extends User$expenseSplitsArgs<ExtArgs> = {}>(args?: Subset<T, User$expenseSplitsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpenseSplitPayload<ExtArgs>, T, "findMany"> | Null>
    transactionsFrom<T extends User$transactionsFromArgs<ExtArgs> = {}>(args?: Subset<T, User$transactionsFromArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany"> | Null>
    transactionsTo<T extends User$transactionsToArgs<ExtArgs> = {}>(args?: Subset<T, User$transactionsToArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany"> | Null>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany"> | Null>
    oauthIntegrations<T extends User$oauthIntegrationsArgs<ExtArgs> = {}>(args?: Subset<T, User$oauthIntegrationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OAuthIntegrationPayload<ExtArgs>, T, "findMany"> | Null>
    eventsCreated<T extends User$eventsCreatedArgs<ExtArgs> = {}>(args?: Subset<T, User$eventsCreatedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findMany"> | Null>
    choreSwapRequestsInitiated<T extends User$choreSwapRequestsInitiatedArgs<ExtArgs> = {}>(args?: Subset<T, User$choreSwapRequestsInitiatedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChoreSwapRequestPayload<ExtArgs>, T, "findMany"> | Null>
    choreSwapRequestsReceived<T extends User$choreSwapRequestsReceivedArgs<ExtArgs> = {}>(args?: Subset<T, User$choreSwapRequestsReceivedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChoreSwapRequestPayload<ExtArgs>, T, "findMany"> | Null>
    reactions<T extends User$reactionsArgs<ExtArgs> = {}>(args?: Subset<T, User$reactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReactionPayload<ExtArgs>, T, "findMany"> | Null>
    mentions<T extends User$mentionsArgs<ExtArgs> = {}>(args?: Subset<T, User$mentionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MentionPayload<ExtArgs>, T, "findMany"> | Null>
    choreHistory<T extends User$choreHistoryArgs<ExtArgs> = {}>(args?: Subset<T, User$choreHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChoreHistoryPayload<ExtArgs>, T, "findMany"> | Null>
    notificationSettings<T extends User$notificationSettingsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationSettingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationSettingsPayload<ExtArgs>, T, "findMany"> | Null>
    calendarEventHistory<T extends User$calendarEventHistoryArgs<ExtArgs> = {}>(args?: Subset<T, User$calendarEventHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CalendarEventHistoryPayload<ExtArgs>, T, "findMany"> | Null>
    expenseHistory<T extends User$expenseHistoryArgs<ExtArgs> = {}>(args?: Subset<T, User$expenseHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpenseHistoryPayload<ExtArgs>, T, "findMany"> | Null>
    messageReads<T extends User$messageReadsArgs<ExtArgs> = {}>(args?: Subset<T, User$messageReadsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageReadPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly profileImageURL: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly deviceTokens: FieldRef<"User", 'String[]'>
    readonly deletedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.households
   */
  export type User$householdsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HouseholdMember
     */
    select?: HouseholdMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HouseholdMemberInclude<ExtArgs> | null
    where?: HouseholdMemberWhereInput
    orderBy?: HouseholdMemberOrderByWithRelationInput | HouseholdMemberOrderByWithRelationInput[]
    cursor?: HouseholdMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HouseholdMemberScalarFieldEnum | HouseholdMemberScalarFieldEnum[]
  }

  /**
   * User.messages
   */
  export type User$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * User.threads
   */
  export type User$threadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Thread
     */
    select?: ThreadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThreadInclude<ExtArgs> | null
    where?: ThreadWhereInput
    orderBy?: ThreadOrderByWithRelationInput | ThreadOrderByWithRelationInput[]
    cursor?: ThreadWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ThreadScalarFieldEnum | ThreadScalarFieldEnum[]
  }

  /**
   * User.assignedChores
   */
  export type User$assignedChoresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChoreAssignment
     */
    select?: ChoreAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChoreAssignmentInclude<ExtArgs> | null
    where?: ChoreAssignmentWhereInput
    orderBy?: ChoreAssignmentOrderByWithRelationInput | ChoreAssignmentOrderByWithRelationInput[]
    cursor?: ChoreAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChoreAssignmentScalarFieldEnum | ChoreAssignmentScalarFieldEnum[]
  }

  /**
   * User.expensesPaid
   */
  export type User$expensesPaidArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    where?: ExpenseWhereInput
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    cursor?: ExpenseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }

  /**
   * User.expenseSplits
   */
  export type User$expenseSplitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseSplit
     */
    select?: ExpenseSplitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseSplitInclude<ExtArgs> | null
    where?: ExpenseSplitWhereInput
    orderBy?: ExpenseSplitOrderByWithRelationInput | ExpenseSplitOrderByWithRelationInput[]
    cursor?: ExpenseSplitWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExpenseSplitScalarFieldEnum | ExpenseSplitScalarFieldEnum[]
  }

  /**
   * User.transactionsFrom
   */
  export type User$transactionsFromArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * User.transactionsTo
   */
  export type User$transactionsToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.oauthIntegrations
   */
  export type User$oauthIntegrationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthIntegration
     */
    select?: OAuthIntegrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OAuthIntegrationInclude<ExtArgs> | null
    where?: OAuthIntegrationWhereInput
    orderBy?: OAuthIntegrationOrderByWithRelationInput | OAuthIntegrationOrderByWithRelationInput[]
    cursor?: OAuthIntegrationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OAuthIntegrationScalarFieldEnum | OAuthIntegrationScalarFieldEnum[]
  }

  /**
   * User.eventsCreated
   */
  export type User$eventsCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    where?: EventWhereInput
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    cursor?: EventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * User.choreSwapRequestsInitiated
   */
  export type User$choreSwapRequestsInitiatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChoreSwapRequest
     */
    select?: ChoreSwapRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChoreSwapRequestInclude<ExtArgs> | null
    where?: ChoreSwapRequestWhereInput
    orderBy?: ChoreSwapRequestOrderByWithRelationInput | ChoreSwapRequestOrderByWithRelationInput[]
    cursor?: ChoreSwapRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChoreSwapRequestScalarFieldEnum | ChoreSwapRequestScalarFieldEnum[]
  }

  /**
   * User.choreSwapRequestsReceived
   */
  export type User$choreSwapRequestsReceivedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChoreSwapRequest
     */
    select?: ChoreSwapRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChoreSwapRequestInclude<ExtArgs> | null
    where?: ChoreSwapRequestWhereInput
    orderBy?: ChoreSwapRequestOrderByWithRelationInput | ChoreSwapRequestOrderByWithRelationInput[]
    cursor?: ChoreSwapRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChoreSwapRequestScalarFieldEnum | ChoreSwapRequestScalarFieldEnum[]
  }

  /**
   * User.reactions
   */
  export type User$reactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reaction
     */
    select?: ReactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReactionInclude<ExtArgs> | null
    where?: ReactionWhereInput
    orderBy?: ReactionOrderByWithRelationInput | ReactionOrderByWithRelationInput[]
    cursor?: ReactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReactionScalarFieldEnum | ReactionScalarFieldEnum[]
  }

  /**
   * User.mentions
   */
  export type User$mentionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mention
     */
    select?: MentionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentionInclude<ExtArgs> | null
    where?: MentionWhereInput
    orderBy?: MentionOrderByWithRelationInput | MentionOrderByWithRelationInput[]
    cursor?: MentionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MentionScalarFieldEnum | MentionScalarFieldEnum[]
  }

  /**
   * User.choreHistory
   */
  export type User$choreHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChoreHistory
     */
    select?: ChoreHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChoreHistoryInclude<ExtArgs> | null
    where?: ChoreHistoryWhereInput
    orderBy?: ChoreHistoryOrderByWithRelationInput | ChoreHistoryOrderByWithRelationInput[]
    cursor?: ChoreHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChoreHistoryScalarFieldEnum | ChoreHistoryScalarFieldEnum[]
  }

  /**
   * User.notificationSettings
   */
  export type User$notificationSettingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSettings
     */
    select?: NotificationSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSettingsInclude<ExtArgs> | null
    where?: NotificationSettingsWhereInput
    orderBy?: NotificationSettingsOrderByWithRelationInput | NotificationSettingsOrderByWithRelationInput[]
    cursor?: NotificationSettingsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationSettingsScalarFieldEnum | NotificationSettingsScalarFieldEnum[]
  }

  /**
   * User.calendarEventHistory
   */
  export type User$calendarEventHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEventHistory
     */
    select?: CalendarEventHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventHistoryInclude<ExtArgs> | null
    where?: CalendarEventHistoryWhereInput
    orderBy?: CalendarEventHistoryOrderByWithRelationInput | CalendarEventHistoryOrderByWithRelationInput[]
    cursor?: CalendarEventHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CalendarEventHistoryScalarFieldEnum | CalendarEventHistoryScalarFieldEnum[]
  }

  /**
   * User.expenseHistory
   */
  export type User$expenseHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseHistory
     */
    select?: ExpenseHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseHistoryInclude<ExtArgs> | null
    where?: ExpenseHistoryWhereInput
    orderBy?: ExpenseHistoryOrderByWithRelationInput | ExpenseHistoryOrderByWithRelationInput[]
    cursor?: ExpenseHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExpenseHistoryScalarFieldEnum | ExpenseHistoryScalarFieldEnum[]
  }

  /**
   * User.messageReads
   */
  export type User$messageReadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageRead
     */
    select?: MessageReadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageReadInclude<ExtArgs> | null
    where?: MessageReadWhereInput
    orderBy?: MessageReadOrderByWithRelationInput | MessageReadOrderByWithRelationInput[]
    cursor?: MessageReadWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageReadScalarFieldEnum | MessageReadScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Household
   */

  export type AggregateHousehold = {
    _count: HouseholdCountAggregateOutputType | null
    _min: HouseholdMinAggregateOutputType | null
    _max: HouseholdMaxAggregateOutputType | null
  }

  export type HouseholdMinAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
    currency: string | null
    icon: string | null
    timezone: string | null
    language: string | null
    deletedAt: Date | null
  }

  export type HouseholdMaxAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
    currency: string | null
    icon: string | null
    timezone: string | null
    language: string | null
    deletedAt: Date | null
  }

  export type HouseholdCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    currency: number
    icon: number
    timezone: number
    language: number
    deletedAt: number
    _all: number
  }


  export type HouseholdMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    currency?: true
    icon?: true
    timezone?: true
    language?: true
    deletedAt?: true
  }

  export type HouseholdMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    currency?: true
    icon?: true
    timezone?: true
    language?: true
    deletedAt?: true
  }

  export type HouseholdCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    currency?: true
    icon?: true
    timezone?: true
    language?: true
    deletedAt?: true
    _all?: true
  }

  export type HouseholdAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Household to aggregate.
     */
    where?: HouseholdWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Households to fetch.
     */
    orderBy?: HouseholdOrderByWithRelationInput | HouseholdOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HouseholdWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Households from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Households.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Households
    **/
    _count?: true | HouseholdCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HouseholdMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HouseholdMaxAggregateInputType
  }

  export type GetHouseholdAggregateType<T extends HouseholdAggregateArgs> = {
        [P in keyof T & keyof AggregateHousehold]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHousehold[P]>
      : GetScalarType<T[P], AggregateHousehold[P]>
  }




  export type HouseholdGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HouseholdWhereInput
    orderBy?: HouseholdOrderByWithAggregationInput | HouseholdOrderByWithAggregationInput[]
    by: HouseholdScalarFieldEnum[] | HouseholdScalarFieldEnum
    having?: HouseholdScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HouseholdCountAggregateInputType | true
    _min?: HouseholdMinAggregateInputType
    _max?: HouseholdMaxAggregateInputType
  }

  export type HouseholdGroupByOutputType = {
    id: string
    name: string
    createdAt: Date
    updatedAt: Date
    currency: string
    icon: string | null
    timezone: string
    language: string
    deletedAt: Date | null
    _count: HouseholdCountAggregateOutputType | null
    _min: HouseholdMinAggregateOutputType | null
    _max: HouseholdMaxAggregateOutputType | null
  }

  type GetHouseholdGroupByPayload<T extends HouseholdGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HouseholdGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HouseholdGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HouseholdGroupByOutputType[P]>
            : GetScalarType<T[P], HouseholdGroupByOutputType[P]>
        }
      >
    >


  export type HouseholdSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    currency?: boolean
    icon?: boolean
    timezone?: boolean
    language?: boolean
    deletedAt?: boolean
    members?: boolean | Household$membersArgs<ExtArgs>
    threads?: boolean | Household$threadsArgs<ExtArgs>
    chores?: boolean | Household$choresArgs<ExtArgs>
    expenses?: boolean | Household$expensesArgs<ExtArgs>
    events?: boolean | Household$eventsArgs<ExtArgs>
    choreTemplates?: boolean | Household$choreTemplatesArgs<ExtArgs>
    notificationSettings?: boolean | Household$notificationSettingsArgs<ExtArgs>
    _count?: boolean | HouseholdCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["household"]>

  export type HouseholdSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    currency?: boolean
    icon?: boolean
    timezone?: boolean
    language?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["household"]>

  export type HouseholdSelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    currency?: boolean
    icon?: boolean
    timezone?: boolean
    language?: boolean
    deletedAt?: boolean
  }

  export type HouseholdInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | Household$membersArgs<ExtArgs>
    threads?: boolean | Household$threadsArgs<ExtArgs>
    chores?: boolean | Household$choresArgs<ExtArgs>
    expenses?: boolean | Household$expensesArgs<ExtArgs>
    events?: boolean | Household$eventsArgs<ExtArgs>
    choreTemplates?: boolean | Household$choreTemplatesArgs<ExtArgs>
    notificationSettings?: boolean | Household$notificationSettingsArgs<ExtArgs>
    _count?: boolean | HouseholdCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type HouseholdIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $HouseholdPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Household"
    objects: {
      members: Prisma.$HouseholdMemberPayload<ExtArgs>[]
      threads: Prisma.$ThreadPayload<ExtArgs>[]
      chores: Prisma.$ChorePayload<ExtArgs>[]
      expenses: Prisma.$ExpensePayload<ExtArgs>[]
      events: Prisma.$EventPayload<ExtArgs>[]
      choreTemplates: Prisma.$ChoreTemplatePayload<ExtArgs>[]
      notificationSettings: Prisma.$NotificationSettingsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      createdAt: Date
      updatedAt: Date
      currency: string
      icon: string | null
      timezone: string
      language: string
      deletedAt: Date | null
    }, ExtArgs["result"]["household"]>
    composites: {}
  }

  type HouseholdGetPayload<S extends boolean | null | undefined | HouseholdDefaultArgs> = $Result.GetResult<Prisma.$HouseholdPayload, S>

  type HouseholdCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<HouseholdFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: HouseholdCountAggregateInputType | true
    }

  export interface HouseholdDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Household'], meta: { name: 'Household' } }
    /**
     * Find zero or one Household that matches the filter.
     * @param {HouseholdFindUniqueArgs} args - Arguments to find a Household
     * @example
     * // Get one Household
     * const household = await prisma.household.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HouseholdFindUniqueArgs>(args: SelectSubset<T, HouseholdFindUniqueArgs<ExtArgs>>): Prisma__HouseholdClient<$Result.GetResult<Prisma.$HouseholdPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Household that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {HouseholdFindUniqueOrThrowArgs} args - Arguments to find a Household
     * @example
     * // Get one Household
     * const household = await prisma.household.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HouseholdFindUniqueOrThrowArgs>(args: SelectSubset<T, HouseholdFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HouseholdClient<$Result.GetResult<Prisma.$HouseholdPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Household that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HouseholdFindFirstArgs} args - Arguments to find a Household
     * @example
     * // Get one Household
     * const household = await prisma.household.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HouseholdFindFirstArgs>(args?: SelectSubset<T, HouseholdFindFirstArgs<ExtArgs>>): Prisma__HouseholdClient<$Result.GetResult<Prisma.$HouseholdPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Household that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HouseholdFindFirstOrThrowArgs} args - Arguments to find a Household
     * @example
     * // Get one Household
     * const household = await prisma.household.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HouseholdFindFirstOrThrowArgs>(args?: SelectSubset<T, HouseholdFindFirstOrThrowArgs<ExtArgs>>): Prisma__HouseholdClient<$Result.GetResult<Prisma.$HouseholdPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Households that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HouseholdFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Households
     * const households = await prisma.household.findMany()
     * 
     * // Get first 10 Households
     * const households = await prisma.household.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const householdWithIdOnly = await prisma.household.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HouseholdFindManyArgs>(args?: SelectSubset<T, HouseholdFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HouseholdPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Household.
     * @param {HouseholdCreateArgs} args - Arguments to create a Household.
     * @example
     * // Create one Household
     * const Household = await prisma.household.create({
     *   data: {
     *     // ... data to create a Household
     *   }
     * })
     * 
     */
    create<T extends HouseholdCreateArgs>(args: SelectSubset<T, HouseholdCreateArgs<ExtArgs>>): Prisma__HouseholdClient<$Result.GetResult<Prisma.$HouseholdPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Households.
     * @param {HouseholdCreateManyArgs} args - Arguments to create many Households.
     * @example
     * // Create many Households
     * const household = await prisma.household.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HouseholdCreateManyArgs>(args?: SelectSubset<T, HouseholdCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Households and returns the data saved in the database.
     * @param {HouseholdCreateManyAndReturnArgs} args - Arguments to create many Households.
     * @example
     * // Create many Households
     * const household = await prisma.household.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Households and only return the `id`
     * const householdWithIdOnly = await prisma.household.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HouseholdCreateManyAndReturnArgs>(args?: SelectSubset<T, HouseholdCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HouseholdPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Household.
     * @param {HouseholdDeleteArgs} args - Arguments to delete one Household.
     * @example
     * // Delete one Household
     * const Household = await prisma.household.delete({
     *   where: {
     *     // ... filter to delete one Household
     *   }
     * })
     * 
     */
    delete<T extends HouseholdDeleteArgs>(args: SelectSubset<T, HouseholdDeleteArgs<ExtArgs>>): Prisma__HouseholdClient<$Result.GetResult<Prisma.$HouseholdPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Household.
     * @param {HouseholdUpdateArgs} args - Arguments to update one Household.
     * @example
     * // Update one Household
     * const household = await prisma.household.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HouseholdUpdateArgs>(args: SelectSubset<T, HouseholdUpdateArgs<ExtArgs>>): Prisma__HouseholdClient<$Result.GetResult<Prisma.$HouseholdPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Households.
     * @param {HouseholdDeleteManyArgs} args - Arguments to filter Households to delete.
     * @example
     * // Delete a few Households
     * const { count } = await prisma.household.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HouseholdDeleteManyArgs>(args?: SelectSubset<T, HouseholdDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Households.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HouseholdUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Households
     * const household = await prisma.household.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HouseholdUpdateManyArgs>(args: SelectSubset<T, HouseholdUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Household.
     * @param {HouseholdUpsertArgs} args - Arguments to update or create a Household.
     * @example
     * // Update or create a Household
     * const household = await prisma.household.upsert({
     *   create: {
     *     // ... data to create a Household
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Household we want to update
     *   }
     * })
     */
    upsert<T extends HouseholdUpsertArgs>(args: SelectSubset<T, HouseholdUpsertArgs<ExtArgs>>): Prisma__HouseholdClient<$Result.GetResult<Prisma.$HouseholdPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Households.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HouseholdCountArgs} args - Arguments to filter Households to count.
     * @example
     * // Count the number of Households
     * const count = await prisma.household.count({
     *   where: {
     *     // ... the filter for the Households we want to count
     *   }
     * })
    **/
    count<T extends HouseholdCountArgs>(
      args?: Subset<T, HouseholdCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HouseholdCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Household.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HouseholdAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HouseholdAggregateArgs>(args: Subset<T, HouseholdAggregateArgs>): Prisma.PrismaPromise<GetHouseholdAggregateType<T>>

    /**
     * Group by Household.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HouseholdGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HouseholdGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HouseholdGroupByArgs['orderBy'] }
        : { orderBy?: HouseholdGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HouseholdGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHouseholdGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Household model
   */
  readonly fields: HouseholdFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Household.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HouseholdClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    members<T extends Household$membersArgs<ExtArgs> = {}>(args?: Subset<T, Household$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HouseholdMemberPayload<ExtArgs>, T, "findMany"> | Null>
    threads<T extends Household$threadsArgs<ExtArgs> = {}>(args?: Subset<T, Household$threadsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ThreadPayload<ExtArgs>, T, "findMany"> | Null>
    chores<T extends Household$choresArgs<ExtArgs> = {}>(args?: Subset<T, Household$choresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChorePayload<ExtArgs>, T, "findMany"> | Null>
    expenses<T extends Household$expensesArgs<ExtArgs> = {}>(args?: Subset<T, Household$expensesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findMany"> | Null>
    events<T extends Household$eventsArgs<ExtArgs> = {}>(args?: Subset<T, Household$eventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findMany"> | Null>
    choreTemplates<T extends Household$choreTemplatesArgs<ExtArgs> = {}>(args?: Subset<T, Household$choreTemplatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChoreTemplatePayload<ExtArgs>, T, "findMany"> | Null>
    notificationSettings<T extends Household$notificationSettingsArgs<ExtArgs> = {}>(args?: Subset<T, Household$notificationSettingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationSettingsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Household model
   */ 
  interface HouseholdFieldRefs {
    readonly id: FieldRef<"Household", 'String'>
    readonly name: FieldRef<"Household", 'String'>
    readonly createdAt: FieldRef<"Household", 'DateTime'>
    readonly updatedAt: FieldRef<"Household", 'DateTime'>
    readonly currency: FieldRef<"Household", 'String'>
    readonly icon: FieldRef<"Household", 'String'>
    readonly timezone: FieldRef<"Household", 'String'>
    readonly language: FieldRef<"Household", 'String'>
    readonly deletedAt: FieldRef<"Household", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Household findUnique
   */
  export type HouseholdFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Household
     */
    select?: HouseholdSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HouseholdInclude<ExtArgs> | null
    /**
     * Filter, which Household to fetch.
     */
    where: HouseholdWhereUniqueInput
  }

  /**
   * Household findUniqueOrThrow
   */
  export type HouseholdFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Household
     */
    select?: HouseholdSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HouseholdInclude<ExtArgs> | null
    /**
     * Filter, which Household to fetch.
     */
    where: HouseholdWhereUniqueInput
  }

  /**
   * Household findFirst
   */
  export type HouseholdFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Household
     */
    select?: HouseholdSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HouseholdInclude<ExtArgs> | null
    /**
     * Filter, which Household to fetch.
     */
    where?: HouseholdWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Households to fetch.
     */
    orderBy?: HouseholdOrderByWithRelationInput | HouseholdOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Households.
     */
    cursor?: HouseholdWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Households from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Households.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Households.
     */
    distinct?: HouseholdScalarFieldEnum | HouseholdScalarFieldEnum[]
  }

  /**
   * Household findFirstOrThrow
   */
  export type HouseholdFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Household
     */
    select?: HouseholdSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HouseholdInclude<ExtArgs> | null
    /**
     * Filter, which Household to fetch.
     */
    where?: HouseholdWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Households to fetch.
     */
    orderBy?: HouseholdOrderByWithRelationInput | HouseholdOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Households.
     */
    cursor?: HouseholdWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Households from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Households.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Households.
     */
    distinct?: HouseholdScalarFieldEnum | HouseholdScalarFieldEnum[]
  }

  /**
   * Household findMany
   */
  export type HouseholdFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Household
     */
    select?: HouseholdSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HouseholdInclude<ExtArgs> | null
    /**
     * Filter, which Households to fetch.
     */
    where?: HouseholdWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Households to fetch.
     */
    orderBy?: HouseholdOrderByWithRelationInput | HouseholdOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Households.
     */
    cursor?: HouseholdWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Households from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Households.
     */
    skip?: number
    distinct?: HouseholdScalarFieldEnum | HouseholdScalarFieldEnum[]
  }

  /**
   * Household create
   */
  export type HouseholdCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Household
     */
    select?: HouseholdSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HouseholdInclude<ExtArgs> | null
    /**
     * The data needed to create a Household.
     */
    data: XOR<HouseholdCreateInput, HouseholdUncheckedCreateInput>
  }

  /**
   * Household createMany
   */
  export type HouseholdCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Households.
     */
    data: HouseholdCreateManyInput | HouseholdCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Household createManyAndReturn
   */
  export type HouseholdCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Household
     */
    select?: HouseholdSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Households.
     */
    data: HouseholdCreateManyInput | HouseholdCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Household update
   */
  export type HouseholdUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Household
     */
    select?: HouseholdSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HouseholdInclude<ExtArgs> | null
    /**
     * The data needed to update a Household.
     */
    data: XOR<HouseholdUpdateInput, HouseholdUncheckedUpdateInput>
    /**
     * Choose, which Household to update.
     */
    where: HouseholdWhereUniqueInput
  }

  /**
   * Household updateMany
   */
  export type HouseholdUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Households.
     */
    data: XOR<HouseholdUpdateManyMutationInput, HouseholdUncheckedUpdateManyInput>
    /**
     * Filter which Households to update
     */
    where?: HouseholdWhereInput
  }

  /**
   * Household upsert
   */
  export type HouseholdUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Household
     */
    select?: HouseholdSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HouseholdInclude<ExtArgs> | null
    /**
     * The filter to search for the Household to update in case it exists.
     */
    where: HouseholdWhereUniqueInput
    /**
     * In case the Household found by the `where` argument doesn't exist, create a new Household with this data.
     */
    create: XOR<HouseholdCreateInput, HouseholdUncheckedCreateInput>
    /**
     * In case the Household was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HouseholdUpdateInput, HouseholdUncheckedUpdateInput>
  }

  /**
   * Household delete
   */
  export type HouseholdDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Household
     */
    select?: HouseholdSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HouseholdInclude<ExtArgs> | null
    /**
     * Filter which Household to delete.
     */
    where: HouseholdWhereUniqueInput
  }

  /**
   * Household deleteMany
   */
  export type HouseholdDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Households to delete
     */
    where?: HouseholdWhereInput
  }

  /**
   * Household.members
   */
  export type Household$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HouseholdMember
     */
    select?: HouseholdMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HouseholdMemberInclude<ExtArgs> | null
    where?: HouseholdMemberWhereInput
    orderBy?: HouseholdMemberOrderByWithRelationInput | HouseholdMemberOrderByWithRelationInput[]
    cursor?: HouseholdMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HouseholdMemberScalarFieldEnum | HouseholdMemberScalarFieldEnum[]
  }

  /**
   * Household.threads
   */
  export type Household$threadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Thread
     */
    select?: ThreadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThreadInclude<ExtArgs> | null
    where?: ThreadWhereInput
    orderBy?: ThreadOrderByWithRelationInput | ThreadOrderByWithRelationInput[]
    cursor?: ThreadWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ThreadScalarFieldEnum | ThreadScalarFieldEnum[]
  }

  /**
   * Household.chores
   */
  export type Household$choresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chore
     */
    select?: ChoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChoreInclude<ExtArgs> | null
    where?: ChoreWhereInput
    orderBy?: ChoreOrderByWithRelationInput | ChoreOrderByWithRelationInput[]
    cursor?: ChoreWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChoreScalarFieldEnum | ChoreScalarFieldEnum[]
  }

  /**
   * Household.expenses
   */
  export type Household$expensesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    where?: ExpenseWhereInput
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    cursor?: ExpenseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }

  /**
   * Household.events
   */
  export type Household$eventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    where?: EventWhereInput
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    cursor?: EventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Household.choreTemplates
   */
  export type Household$choreTemplatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChoreTemplate
     */
    select?: ChoreTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChoreTemplateInclude<ExtArgs> | null
    where?: ChoreTemplateWhereInput
    orderBy?: ChoreTemplateOrderByWithRelationInput | ChoreTemplateOrderByWithRelationInput[]
    cursor?: ChoreTemplateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChoreTemplateScalarFieldEnum | ChoreTemplateScalarFieldEnum[]
  }

  /**
   * Household.notificationSettings
   */
  export type Household$notificationSettingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSettings
     */
    select?: NotificationSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSettingsInclude<ExtArgs> | null
    where?: NotificationSettingsWhereInput
    orderBy?: NotificationSettingsOrderByWithRelationInput | NotificationSettingsOrderByWithRelationInput[]
    cursor?: NotificationSettingsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationSettingsScalarFieldEnum | NotificationSettingsScalarFieldEnum[]
  }

  /**
   * Household without action
   */
  export type HouseholdDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Household
     */
    select?: HouseholdSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HouseholdInclude<ExtArgs> | null
  }


  /**
   * Model HouseholdMember
   */

  export type AggregateHouseholdMember = {
    _count: HouseholdMemberCountAggregateOutputType | null
    _min: HouseholdMemberMinAggregateOutputType | null
    _max: HouseholdMemberMaxAggregateOutputType | null
  }

  export type HouseholdMemberMinAggregateOutputType = {
    id: string | null
    userId: string | null
    householdId: string | null
    role: $Enums.HouseholdRole | null
    joinedAt: Date | null
    leftAt: Date | null
    isInvited: boolean | null
    isAccepted: boolean | null
    isRejected: boolean | null
    isSelected: boolean | null
    lastAssignedChoreAt: Date | null
  }

  export type HouseholdMemberMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    householdId: string | null
    role: $Enums.HouseholdRole | null
    joinedAt: Date | null
    leftAt: Date | null
    isInvited: boolean | null
    isAccepted: boolean | null
    isRejected: boolean | null
    isSelected: boolean | null
    lastAssignedChoreAt: Date | null
  }

  export type HouseholdMemberCountAggregateOutputType = {
    id: number
    userId: number
    householdId: number
    role: number
    joinedAt: number
    leftAt: number
    isInvited: number
    isAccepted: number
    isRejected: number
    isSelected: number
    lastAssignedChoreAt: number
    _all: number
  }


  export type HouseholdMemberMinAggregateInputType = {
    id?: true
    userId?: true
    householdId?: true
    role?: true
    joinedAt?: true
    leftAt?: true
    isInvited?: true
    isAccepted?: true
    isRejected?: true
    isSelected?: true
    lastAssignedChoreAt?: true
  }

  export type HouseholdMemberMaxAggregateInputType = {
    id?: true
    userId?: true
    householdId?: true
    role?: true
    joinedAt?: true
    leftAt?: true
    isInvited?: true
    isAccepted?: true
    isRejected?: true
    isSelected?: true
    lastAssignedChoreAt?: true
  }

  export type HouseholdMemberCountAggregateInputType = {
    id?: true
    userId?: true
    householdId?: true
    role?: true
    joinedAt?: true
    leftAt?: true
    isInvited?: true
    isAccepted?: true
    isRejected?: true
    isSelected?: true
    lastAssignedChoreAt?: true
    _all?: true
  }

  export type HouseholdMemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HouseholdMember to aggregate.
     */
    where?: HouseholdMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HouseholdMembers to fetch.
     */
    orderBy?: HouseholdMemberOrderByWithRelationInput | HouseholdMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HouseholdMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HouseholdMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HouseholdMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HouseholdMembers
    **/
    _count?: true | HouseholdMemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HouseholdMemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HouseholdMemberMaxAggregateInputType
  }

  export type GetHouseholdMemberAggregateType<T extends HouseholdMemberAggregateArgs> = {
        [P in keyof T & keyof AggregateHouseholdMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHouseholdMember[P]>
      : GetScalarType<T[P], AggregateHouseholdMember[P]>
  }




  export type HouseholdMemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HouseholdMemberWhereInput
    orderBy?: HouseholdMemberOrderByWithAggregationInput | HouseholdMemberOrderByWithAggregationInput[]
    by: HouseholdMemberScalarFieldEnum[] | HouseholdMemberScalarFieldEnum
    having?: HouseholdMemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HouseholdMemberCountAggregateInputType | true
    _min?: HouseholdMemberMinAggregateInputType
    _max?: HouseholdMemberMaxAggregateInputType
  }

  export type HouseholdMemberGroupByOutputType = {
    id: string
    userId: string
    householdId: string
    role: $Enums.HouseholdRole
    joinedAt: Date
    leftAt: Date | null
    isInvited: boolean
    isAccepted: boolean
    isRejected: boolean
    isSelected: boolean
    lastAssignedChoreAt: Date | null
    _count: HouseholdMemberCountAggregateOutputType | null
    _min: HouseholdMemberMinAggregateOutputType | null
    _max: HouseholdMemberMaxAggregateOutputType | null
  }

  type GetHouseholdMemberGroupByPayload<T extends HouseholdMemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HouseholdMemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HouseholdMemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HouseholdMemberGroupByOutputType[P]>
            : GetScalarType<T[P], HouseholdMemberGroupByOutputType[P]>
        }
      >
    >


  export type HouseholdMemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    householdId?: boolean
    role?: boolean
    joinedAt?: boolean
    leftAt?: boolean
    isInvited?: boolean
    isAccepted?: boolean
    isRejected?: boolean
    isSelected?: boolean
    lastAssignedChoreAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    household?: boolean | HouseholdDefaultArgs<ExtArgs>
    threads?: boolean | HouseholdMember$threadsArgs<ExtArgs>
    _count?: boolean | HouseholdMemberCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["householdMember"]>

  export type HouseholdMemberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    householdId?: boolean
    role?: boolean
    joinedAt?: boolean
    leftAt?: boolean
    isInvited?: boolean
    isAccepted?: boolean
    isRejected?: boolean
    isSelected?: boolean
    lastAssignedChoreAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    household?: boolean | HouseholdDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["householdMember"]>

  export type HouseholdMemberSelectScalar = {
    id?: boolean
    userId?: boolean
    householdId?: boolean
    role?: boolean
    joinedAt?: boolean
    leftAt?: boolean
    isInvited?: boolean
    isAccepted?: boolean
    isRejected?: boolean
    isSelected?: boolean
    lastAssignedChoreAt?: boolean
  }

  export type HouseholdMemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    household?: boolean | HouseholdDefaultArgs<ExtArgs>
    threads?: boolean | HouseholdMember$threadsArgs<ExtArgs>
    _count?: boolean | HouseholdMemberCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type HouseholdMemberIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    household?: boolean | HouseholdDefaultArgs<ExtArgs>
  }

  export type $HouseholdMemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HouseholdMember"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      household: Prisma.$HouseholdPayload<ExtArgs>
      threads: Prisma.$ThreadPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      householdId: string
      role: $Enums.HouseholdRole
      joinedAt: Date
      leftAt: Date | null
      isInvited: boolean
      isAccepted: boolean
      isRejected: boolean
      isSelected: boolean
      lastAssignedChoreAt: Date | null
    }, ExtArgs["result"]["householdMember"]>
    composites: {}
  }

  type HouseholdMemberGetPayload<S extends boolean | null | undefined | HouseholdMemberDefaultArgs> = $Result.GetResult<Prisma.$HouseholdMemberPayload, S>

  type HouseholdMemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<HouseholdMemberFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: HouseholdMemberCountAggregateInputType | true
    }

  export interface HouseholdMemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HouseholdMember'], meta: { name: 'HouseholdMember' } }
    /**
     * Find zero or one HouseholdMember that matches the filter.
     * @param {HouseholdMemberFindUniqueArgs} args - Arguments to find a HouseholdMember
     * @example
     * // Get one HouseholdMember
     * const householdMember = await prisma.householdMember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HouseholdMemberFindUniqueArgs>(args: SelectSubset<T, HouseholdMemberFindUniqueArgs<ExtArgs>>): Prisma__HouseholdMemberClient<$Result.GetResult<Prisma.$HouseholdMemberPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one HouseholdMember that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {HouseholdMemberFindUniqueOrThrowArgs} args - Arguments to find a HouseholdMember
     * @example
     * // Get one HouseholdMember
     * const householdMember = await prisma.householdMember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HouseholdMemberFindUniqueOrThrowArgs>(args: SelectSubset<T, HouseholdMemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HouseholdMemberClient<$Result.GetResult<Prisma.$HouseholdMemberPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first HouseholdMember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HouseholdMemberFindFirstArgs} args - Arguments to find a HouseholdMember
     * @example
     * // Get one HouseholdMember
     * const householdMember = await prisma.householdMember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HouseholdMemberFindFirstArgs>(args?: SelectSubset<T, HouseholdMemberFindFirstArgs<ExtArgs>>): Prisma__HouseholdMemberClient<$Result.GetResult<Prisma.$HouseholdMemberPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first HouseholdMember that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HouseholdMemberFindFirstOrThrowArgs} args - Arguments to find a HouseholdMember
     * @example
     * // Get one HouseholdMember
     * const householdMember = await prisma.householdMember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HouseholdMemberFindFirstOrThrowArgs>(args?: SelectSubset<T, HouseholdMemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__HouseholdMemberClient<$Result.GetResult<Prisma.$HouseholdMemberPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more HouseholdMembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HouseholdMemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HouseholdMembers
     * const householdMembers = await prisma.householdMember.findMany()
     * 
     * // Get first 10 HouseholdMembers
     * const householdMembers = await prisma.householdMember.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const householdMemberWithIdOnly = await prisma.householdMember.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HouseholdMemberFindManyArgs>(args?: SelectSubset<T, HouseholdMemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HouseholdMemberPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a HouseholdMember.
     * @param {HouseholdMemberCreateArgs} args - Arguments to create a HouseholdMember.
     * @example
     * // Create one HouseholdMember
     * const HouseholdMember = await prisma.householdMember.create({
     *   data: {
     *     // ... data to create a HouseholdMember
     *   }
     * })
     * 
     */
    create<T extends HouseholdMemberCreateArgs>(args: SelectSubset<T, HouseholdMemberCreateArgs<ExtArgs>>): Prisma__HouseholdMemberClient<$Result.GetResult<Prisma.$HouseholdMemberPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many HouseholdMembers.
     * @param {HouseholdMemberCreateManyArgs} args - Arguments to create many HouseholdMembers.
     * @example
     * // Create many HouseholdMembers
     * const householdMember = await prisma.householdMember.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HouseholdMemberCreateManyArgs>(args?: SelectSubset<T, HouseholdMemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many HouseholdMembers and returns the data saved in the database.
     * @param {HouseholdMemberCreateManyAndReturnArgs} args - Arguments to create many HouseholdMembers.
     * @example
     * // Create many HouseholdMembers
     * const householdMember = await prisma.householdMember.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many HouseholdMembers and only return the `id`
     * const householdMemberWithIdOnly = await prisma.householdMember.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HouseholdMemberCreateManyAndReturnArgs>(args?: SelectSubset<T, HouseholdMemberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HouseholdMemberPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a HouseholdMember.
     * @param {HouseholdMemberDeleteArgs} args - Arguments to delete one HouseholdMember.
     * @example
     * // Delete one HouseholdMember
     * const HouseholdMember = await prisma.householdMember.delete({
     *   where: {
     *     // ... filter to delete one HouseholdMember
     *   }
     * })
     * 
     */
    delete<T extends HouseholdMemberDeleteArgs>(args: SelectSubset<T, HouseholdMemberDeleteArgs<ExtArgs>>): Prisma__HouseholdMemberClient<$Result.GetResult<Prisma.$HouseholdMemberPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one HouseholdMember.
     * @param {HouseholdMemberUpdateArgs} args - Arguments to update one HouseholdMember.
     * @example
     * // Update one HouseholdMember
     * const householdMember = await prisma.householdMember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HouseholdMemberUpdateArgs>(args: SelectSubset<T, HouseholdMemberUpdateArgs<ExtArgs>>): Prisma__HouseholdMemberClient<$Result.GetResult<Prisma.$HouseholdMemberPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more HouseholdMembers.
     * @param {HouseholdMemberDeleteManyArgs} args - Arguments to filter HouseholdMembers to delete.
     * @example
     * // Delete a few HouseholdMembers
     * const { count } = await prisma.householdMember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HouseholdMemberDeleteManyArgs>(args?: SelectSubset<T, HouseholdMemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HouseholdMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HouseholdMemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HouseholdMembers
     * const householdMember = await prisma.householdMember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HouseholdMemberUpdateManyArgs>(args: SelectSubset<T, HouseholdMemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one HouseholdMember.
     * @param {HouseholdMemberUpsertArgs} args - Arguments to update or create a HouseholdMember.
     * @example
     * // Update or create a HouseholdMember
     * const householdMember = await prisma.householdMember.upsert({
     *   create: {
     *     // ... data to create a HouseholdMember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HouseholdMember we want to update
     *   }
     * })
     */
    upsert<T extends HouseholdMemberUpsertArgs>(args: SelectSubset<T, HouseholdMemberUpsertArgs<ExtArgs>>): Prisma__HouseholdMemberClient<$Result.GetResult<Prisma.$HouseholdMemberPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of HouseholdMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HouseholdMemberCountArgs} args - Arguments to filter HouseholdMembers to count.
     * @example
     * // Count the number of HouseholdMembers
     * const count = await prisma.householdMember.count({
     *   where: {
     *     // ... the filter for the HouseholdMembers we want to count
     *   }
     * })
    **/
    count<T extends HouseholdMemberCountArgs>(
      args?: Subset<T, HouseholdMemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HouseholdMemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HouseholdMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HouseholdMemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HouseholdMemberAggregateArgs>(args: Subset<T, HouseholdMemberAggregateArgs>): Prisma.PrismaPromise<GetHouseholdMemberAggregateType<T>>

    /**
     * Group by HouseholdMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HouseholdMemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HouseholdMemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HouseholdMemberGroupByArgs['orderBy'] }
        : { orderBy?: HouseholdMemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HouseholdMemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHouseholdMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HouseholdMember model
   */
  readonly fields: HouseholdMemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HouseholdMember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HouseholdMemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    household<T extends HouseholdDefaultArgs<ExtArgs> = {}>(args?: Subset<T, HouseholdDefaultArgs<ExtArgs>>): Prisma__HouseholdClient<$Result.GetResult<Prisma.$HouseholdPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    threads<T extends HouseholdMember$threadsArgs<ExtArgs> = {}>(args?: Subset<T, HouseholdMember$threadsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ThreadPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HouseholdMember model
   */ 
  interface HouseholdMemberFieldRefs {
    readonly id: FieldRef<"HouseholdMember", 'String'>
    readonly userId: FieldRef<"HouseholdMember", 'String'>
    readonly householdId: FieldRef<"HouseholdMember", 'String'>
    readonly role: FieldRef<"HouseholdMember", 'HouseholdRole'>
    readonly joinedAt: FieldRef<"HouseholdMember", 'DateTime'>
    readonly leftAt: FieldRef<"HouseholdMember", 'DateTime'>
    readonly isInvited: FieldRef<"HouseholdMember", 'Boolean'>
    readonly isAccepted: FieldRef<"HouseholdMember", 'Boolean'>
    readonly isRejected: FieldRef<"HouseholdMember", 'Boolean'>
    readonly isSelected: FieldRef<"HouseholdMember", 'Boolean'>
    readonly lastAssignedChoreAt: FieldRef<"HouseholdMember", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * HouseholdMember findUnique
   */
  export type HouseholdMemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HouseholdMember
     */
    select?: HouseholdMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HouseholdMemberInclude<ExtArgs> | null
    /**
     * Filter, which HouseholdMember to fetch.
     */
    where: HouseholdMemberWhereUniqueInput
  }

  /**
   * HouseholdMember findUniqueOrThrow
   */
  export type HouseholdMemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HouseholdMember
     */
    select?: HouseholdMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HouseholdMemberInclude<ExtArgs> | null
    /**
     * Filter, which HouseholdMember to fetch.
     */
    where: HouseholdMemberWhereUniqueInput
  }

  /**
   * HouseholdMember findFirst
   */
  export type HouseholdMemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HouseholdMember
     */
    select?: HouseholdMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HouseholdMemberInclude<ExtArgs> | null
    /**
     * Filter, which HouseholdMember to fetch.
     */
    where?: HouseholdMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HouseholdMembers to fetch.
     */
    orderBy?: HouseholdMemberOrderByWithRelationInput | HouseholdMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HouseholdMembers.
     */
    cursor?: HouseholdMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HouseholdMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HouseholdMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HouseholdMembers.
     */
    distinct?: HouseholdMemberScalarFieldEnum | HouseholdMemberScalarFieldEnum[]
  }

  /**
   * HouseholdMember findFirstOrThrow
   */
  export type HouseholdMemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HouseholdMember
     */
    select?: HouseholdMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HouseholdMemberInclude<ExtArgs> | null
    /**
     * Filter, which HouseholdMember to fetch.
     */
    where?: HouseholdMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HouseholdMembers to fetch.
     */
    orderBy?: HouseholdMemberOrderByWithRelationInput | HouseholdMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HouseholdMembers.
     */
    cursor?: HouseholdMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HouseholdMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HouseholdMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HouseholdMembers.
     */
    distinct?: HouseholdMemberScalarFieldEnum | HouseholdMemberScalarFieldEnum[]
  }

  /**
   * HouseholdMember findMany
   */
  export type HouseholdMemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HouseholdMember
     */
    select?: HouseholdMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HouseholdMemberInclude<ExtArgs> | null
    /**
     * Filter, which HouseholdMembers to fetch.
     */
    where?: HouseholdMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HouseholdMembers to fetch.
     */
    orderBy?: HouseholdMemberOrderByWithRelationInput | HouseholdMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HouseholdMembers.
     */
    cursor?: HouseholdMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HouseholdMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HouseholdMembers.
     */
    skip?: number
    distinct?: HouseholdMemberScalarFieldEnum | HouseholdMemberScalarFieldEnum[]
  }

  /**
   * HouseholdMember create
   */
  export type HouseholdMemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HouseholdMember
     */
    select?: HouseholdMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HouseholdMemberInclude<ExtArgs> | null
    /**
     * The data needed to create a HouseholdMember.
     */
    data: XOR<HouseholdMemberCreateInput, HouseholdMemberUncheckedCreateInput>
  }

  /**
   * HouseholdMember createMany
   */
  export type HouseholdMemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HouseholdMembers.
     */
    data: HouseholdMemberCreateManyInput | HouseholdMemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * HouseholdMember createManyAndReturn
   */
  export type HouseholdMemberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HouseholdMember
     */
    select?: HouseholdMemberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many HouseholdMembers.
     */
    data: HouseholdMemberCreateManyInput | HouseholdMemberCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HouseholdMemberIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * HouseholdMember update
   */
  export type HouseholdMemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HouseholdMember
     */
    select?: HouseholdMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HouseholdMemberInclude<ExtArgs> | null
    /**
     * The data needed to update a HouseholdMember.
     */
    data: XOR<HouseholdMemberUpdateInput, HouseholdMemberUncheckedUpdateInput>
    /**
     * Choose, which HouseholdMember to update.
     */
    where: HouseholdMemberWhereUniqueInput
  }

  /**
   * HouseholdMember updateMany
   */
  export type HouseholdMemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HouseholdMembers.
     */
    data: XOR<HouseholdMemberUpdateManyMutationInput, HouseholdMemberUncheckedUpdateManyInput>
    /**
     * Filter which HouseholdMembers to update
     */
    where?: HouseholdMemberWhereInput
  }

  /**
   * HouseholdMember upsert
   */
  export type HouseholdMemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HouseholdMember
     */
    select?: HouseholdMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HouseholdMemberInclude<ExtArgs> | null
    /**
     * The filter to search for the HouseholdMember to update in case it exists.
     */
    where: HouseholdMemberWhereUniqueInput
    /**
     * In case the HouseholdMember found by the `where` argument doesn't exist, create a new HouseholdMember with this data.
     */
    create: XOR<HouseholdMemberCreateInput, HouseholdMemberUncheckedCreateInput>
    /**
     * In case the HouseholdMember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HouseholdMemberUpdateInput, HouseholdMemberUncheckedUpdateInput>
  }

  /**
   * HouseholdMember delete
   */
  export type HouseholdMemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HouseholdMember
     */
    select?: HouseholdMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HouseholdMemberInclude<ExtArgs> | null
    /**
     * Filter which HouseholdMember to delete.
     */
    where: HouseholdMemberWhereUniqueInput
  }

  /**
   * HouseholdMember deleteMany
   */
  export type HouseholdMemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HouseholdMembers to delete
     */
    where?: HouseholdMemberWhereInput
  }

  /**
   * HouseholdMember.threads
   */
  export type HouseholdMember$threadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Thread
     */
    select?: ThreadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThreadInclude<ExtArgs> | null
    where?: ThreadWhereInput
    orderBy?: ThreadOrderByWithRelationInput | ThreadOrderByWithRelationInput[]
    cursor?: ThreadWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ThreadScalarFieldEnum | ThreadScalarFieldEnum[]
  }

  /**
   * HouseholdMember without action
   */
  export type HouseholdMemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HouseholdMember
     */
    select?: HouseholdMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HouseholdMemberInclude<ExtArgs> | null
  }


  /**
   * Model RecurrenceRule
   */

  export type AggregateRecurrenceRule = {
    _count: RecurrenceRuleCountAggregateOutputType | null
    _avg: RecurrenceRuleAvgAggregateOutputType | null
    _sum: RecurrenceRuleSumAggregateOutputType | null
    _min: RecurrenceRuleMinAggregateOutputType | null
    _max: RecurrenceRuleMaxAggregateOutputType | null
  }

  export type RecurrenceRuleAvgAggregateOutputType = {
    interval: number | null
    byMonthDay: number | null
    bySetPos: number | null
    count: number | null
  }

  export type RecurrenceRuleSumAggregateOutputType = {
    interval: number | null
    byMonthDay: number[]
    bySetPos: number | null
    count: number | null
  }

  export type RecurrenceRuleMinAggregateOutputType = {
    id: string | null
    frequency: $Enums.RecurrenceFrequency | null
    interval: number | null
    bySetPos: number | null
    count: number | null
    until: Date | null
    customRuleString: string | null
  }

  export type RecurrenceRuleMaxAggregateOutputType = {
    id: string | null
    frequency: $Enums.RecurrenceFrequency | null
    interval: number | null
    bySetPos: number | null
    count: number | null
    until: Date | null
    customRuleString: string | null
  }

  export type RecurrenceRuleCountAggregateOutputType = {
    id: number
    frequency: number
    interval: number
    byWeekDay: number
    byMonthDay: number
    bySetPos: number
    count: number
    until: number
    customRuleString: number
    _all: number
  }


  export type RecurrenceRuleAvgAggregateInputType = {
    interval?: true
    byMonthDay?: true
    bySetPos?: true
    count?: true
  }

  export type RecurrenceRuleSumAggregateInputType = {
    interval?: true
    byMonthDay?: true
    bySetPos?: true
    count?: true
  }

  export type RecurrenceRuleMinAggregateInputType = {
    id?: true
    frequency?: true
    interval?: true
    bySetPos?: true
    count?: true
    until?: true
    customRuleString?: true
  }

  export type RecurrenceRuleMaxAggregateInputType = {
    id?: true
    frequency?: true
    interval?: true
    bySetPos?: true
    count?: true
    until?: true
    customRuleString?: true
  }

  export type RecurrenceRuleCountAggregateInputType = {
    id?: true
    frequency?: true
    interval?: true
    byWeekDay?: true
    byMonthDay?: true
    bySetPos?: true
    count?: true
    until?: true
    customRuleString?: true
    _all?: true
  }

  export type RecurrenceRuleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RecurrenceRule to aggregate.
     */
    where?: RecurrenceRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecurrenceRules to fetch.
     */
    orderBy?: RecurrenceRuleOrderByWithRelationInput | RecurrenceRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RecurrenceRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecurrenceRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecurrenceRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RecurrenceRules
    **/
    _count?: true | RecurrenceRuleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RecurrenceRuleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RecurrenceRuleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RecurrenceRuleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RecurrenceRuleMaxAggregateInputType
  }

  export type GetRecurrenceRuleAggregateType<T extends RecurrenceRuleAggregateArgs> = {
        [P in keyof T & keyof AggregateRecurrenceRule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRecurrenceRule[P]>
      : GetScalarType<T[P], AggregateRecurrenceRule[P]>
  }




  export type RecurrenceRuleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecurrenceRuleWhereInput
    orderBy?: RecurrenceRuleOrderByWithAggregationInput | RecurrenceRuleOrderByWithAggregationInput[]
    by: RecurrenceRuleScalarFieldEnum[] | RecurrenceRuleScalarFieldEnum
    having?: RecurrenceRuleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RecurrenceRuleCountAggregateInputType | true
    _avg?: RecurrenceRuleAvgAggregateInputType
    _sum?: RecurrenceRuleSumAggregateInputType
    _min?: RecurrenceRuleMinAggregateInputType
    _max?: RecurrenceRuleMaxAggregateInputType
  }

  export type RecurrenceRuleGroupByOutputType = {
    id: string
    frequency: $Enums.RecurrenceFrequency
    interval: number
    byWeekDay: $Enums.DaysOfWeek[]
    byMonthDay: number[]
    bySetPos: number | null
    count: number | null
    until: Date | null
    customRuleString: string | null
    _count: RecurrenceRuleCountAggregateOutputType | null
    _avg: RecurrenceRuleAvgAggregateOutputType | null
    _sum: RecurrenceRuleSumAggregateOutputType | null
    _min: RecurrenceRuleMinAggregateOutputType | null
    _max: RecurrenceRuleMaxAggregateOutputType | null
  }

  type GetRecurrenceRuleGroupByPayload<T extends RecurrenceRuleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RecurrenceRuleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RecurrenceRuleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RecurrenceRuleGroupByOutputType[P]>
            : GetScalarType<T[P], RecurrenceRuleGroupByOutputType[P]>
        }
      >
    >


  export type RecurrenceRuleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    frequency?: boolean
    interval?: boolean
    byWeekDay?: boolean
    byMonthDay?: boolean
    bySetPos?: boolean
    count?: boolean
    until?: boolean
    customRuleString?: boolean
    chores?: boolean | RecurrenceRule$choresArgs<ExtArgs>
    events?: boolean | RecurrenceRule$eventsArgs<ExtArgs>
    _count?: boolean | RecurrenceRuleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recurrenceRule"]>

  export type RecurrenceRuleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    frequency?: boolean
    interval?: boolean
    byWeekDay?: boolean
    byMonthDay?: boolean
    bySetPos?: boolean
    count?: boolean
    until?: boolean
    customRuleString?: boolean
  }, ExtArgs["result"]["recurrenceRule"]>

  export type RecurrenceRuleSelectScalar = {
    id?: boolean
    frequency?: boolean
    interval?: boolean
    byWeekDay?: boolean
    byMonthDay?: boolean
    bySetPos?: boolean
    count?: boolean
    until?: boolean
    customRuleString?: boolean
  }

  export type RecurrenceRuleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chores?: boolean | RecurrenceRule$choresArgs<ExtArgs>
    events?: boolean | RecurrenceRule$eventsArgs<ExtArgs>
    _count?: boolean | RecurrenceRuleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RecurrenceRuleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RecurrenceRulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RecurrenceRule"
    objects: {
      chores: Prisma.$ChorePayload<ExtArgs>[]
      events: Prisma.$EventPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      frequency: $Enums.RecurrenceFrequency
      interval: number
      byWeekDay: $Enums.DaysOfWeek[]
      byMonthDay: number[]
      bySetPos: number | null
      count: number | null
      until: Date | null
      customRuleString: string | null
    }, ExtArgs["result"]["recurrenceRule"]>
    composites: {}
  }

  type RecurrenceRuleGetPayload<S extends boolean | null | undefined | RecurrenceRuleDefaultArgs> = $Result.GetResult<Prisma.$RecurrenceRulePayload, S>

  type RecurrenceRuleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RecurrenceRuleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RecurrenceRuleCountAggregateInputType | true
    }

  export interface RecurrenceRuleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RecurrenceRule'], meta: { name: 'RecurrenceRule' } }
    /**
     * Find zero or one RecurrenceRule that matches the filter.
     * @param {RecurrenceRuleFindUniqueArgs} args - Arguments to find a RecurrenceRule
     * @example
     * // Get one RecurrenceRule
     * const recurrenceRule = await prisma.recurrenceRule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RecurrenceRuleFindUniqueArgs>(args: SelectSubset<T, RecurrenceRuleFindUniqueArgs<ExtArgs>>): Prisma__RecurrenceRuleClient<$Result.GetResult<Prisma.$RecurrenceRulePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RecurrenceRule that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RecurrenceRuleFindUniqueOrThrowArgs} args - Arguments to find a RecurrenceRule
     * @example
     * // Get one RecurrenceRule
     * const recurrenceRule = await prisma.recurrenceRule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RecurrenceRuleFindUniqueOrThrowArgs>(args: SelectSubset<T, RecurrenceRuleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RecurrenceRuleClient<$Result.GetResult<Prisma.$RecurrenceRulePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RecurrenceRule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecurrenceRuleFindFirstArgs} args - Arguments to find a RecurrenceRule
     * @example
     * // Get one RecurrenceRule
     * const recurrenceRule = await prisma.recurrenceRule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RecurrenceRuleFindFirstArgs>(args?: SelectSubset<T, RecurrenceRuleFindFirstArgs<ExtArgs>>): Prisma__RecurrenceRuleClient<$Result.GetResult<Prisma.$RecurrenceRulePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RecurrenceRule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecurrenceRuleFindFirstOrThrowArgs} args - Arguments to find a RecurrenceRule
     * @example
     * // Get one RecurrenceRule
     * const recurrenceRule = await prisma.recurrenceRule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RecurrenceRuleFindFirstOrThrowArgs>(args?: SelectSubset<T, RecurrenceRuleFindFirstOrThrowArgs<ExtArgs>>): Prisma__RecurrenceRuleClient<$Result.GetResult<Prisma.$RecurrenceRulePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RecurrenceRules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecurrenceRuleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RecurrenceRules
     * const recurrenceRules = await prisma.recurrenceRule.findMany()
     * 
     * // Get first 10 RecurrenceRules
     * const recurrenceRules = await prisma.recurrenceRule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const recurrenceRuleWithIdOnly = await prisma.recurrenceRule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RecurrenceRuleFindManyArgs>(args?: SelectSubset<T, RecurrenceRuleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecurrenceRulePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RecurrenceRule.
     * @param {RecurrenceRuleCreateArgs} args - Arguments to create a RecurrenceRule.
     * @example
     * // Create one RecurrenceRule
     * const RecurrenceRule = await prisma.recurrenceRule.create({
     *   data: {
     *     // ... data to create a RecurrenceRule
     *   }
     * })
     * 
     */
    create<T extends RecurrenceRuleCreateArgs>(args: SelectSubset<T, RecurrenceRuleCreateArgs<ExtArgs>>): Prisma__RecurrenceRuleClient<$Result.GetResult<Prisma.$RecurrenceRulePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RecurrenceRules.
     * @param {RecurrenceRuleCreateManyArgs} args - Arguments to create many RecurrenceRules.
     * @example
     * // Create many RecurrenceRules
     * const recurrenceRule = await prisma.recurrenceRule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RecurrenceRuleCreateManyArgs>(args?: SelectSubset<T, RecurrenceRuleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RecurrenceRules and returns the data saved in the database.
     * @param {RecurrenceRuleCreateManyAndReturnArgs} args - Arguments to create many RecurrenceRules.
     * @example
     * // Create many RecurrenceRules
     * const recurrenceRule = await prisma.recurrenceRule.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RecurrenceRules and only return the `id`
     * const recurrenceRuleWithIdOnly = await prisma.recurrenceRule.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RecurrenceRuleCreateManyAndReturnArgs>(args?: SelectSubset<T, RecurrenceRuleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecurrenceRulePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RecurrenceRule.
     * @param {RecurrenceRuleDeleteArgs} args - Arguments to delete one RecurrenceRule.
     * @example
     * // Delete one RecurrenceRule
     * const RecurrenceRule = await prisma.recurrenceRule.delete({
     *   where: {
     *     // ... filter to delete one RecurrenceRule
     *   }
     * })
     * 
     */
    delete<T extends RecurrenceRuleDeleteArgs>(args: SelectSubset<T, RecurrenceRuleDeleteArgs<ExtArgs>>): Prisma__RecurrenceRuleClient<$Result.GetResult<Prisma.$RecurrenceRulePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RecurrenceRule.
     * @param {RecurrenceRuleUpdateArgs} args - Arguments to update one RecurrenceRule.
     * @example
     * // Update one RecurrenceRule
     * const recurrenceRule = await prisma.recurrenceRule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RecurrenceRuleUpdateArgs>(args: SelectSubset<T, RecurrenceRuleUpdateArgs<ExtArgs>>): Prisma__RecurrenceRuleClient<$Result.GetResult<Prisma.$RecurrenceRulePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RecurrenceRules.
     * @param {RecurrenceRuleDeleteManyArgs} args - Arguments to filter RecurrenceRules to delete.
     * @example
     * // Delete a few RecurrenceRules
     * const { count } = await prisma.recurrenceRule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RecurrenceRuleDeleteManyArgs>(args?: SelectSubset<T, RecurrenceRuleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RecurrenceRules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecurrenceRuleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RecurrenceRules
     * const recurrenceRule = await prisma.recurrenceRule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RecurrenceRuleUpdateManyArgs>(args: SelectSubset<T, RecurrenceRuleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RecurrenceRule.
     * @param {RecurrenceRuleUpsertArgs} args - Arguments to update or create a RecurrenceRule.
     * @example
     * // Update or create a RecurrenceRule
     * const recurrenceRule = await prisma.recurrenceRule.upsert({
     *   create: {
     *     // ... data to create a RecurrenceRule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RecurrenceRule we want to update
     *   }
     * })
     */
    upsert<T extends RecurrenceRuleUpsertArgs>(args: SelectSubset<T, RecurrenceRuleUpsertArgs<ExtArgs>>): Prisma__RecurrenceRuleClient<$Result.GetResult<Prisma.$RecurrenceRulePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RecurrenceRules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecurrenceRuleCountArgs} args - Arguments to filter RecurrenceRules to count.
     * @example
     * // Count the number of RecurrenceRules
     * const count = await prisma.recurrenceRule.count({
     *   where: {
     *     // ... the filter for the RecurrenceRules we want to count
     *   }
     * })
    **/
    count<T extends RecurrenceRuleCountArgs>(
      args?: Subset<T, RecurrenceRuleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RecurrenceRuleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RecurrenceRule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecurrenceRuleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RecurrenceRuleAggregateArgs>(args: Subset<T, RecurrenceRuleAggregateArgs>): Prisma.PrismaPromise<GetRecurrenceRuleAggregateType<T>>

    /**
     * Group by RecurrenceRule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecurrenceRuleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RecurrenceRuleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RecurrenceRuleGroupByArgs['orderBy'] }
        : { orderBy?: RecurrenceRuleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RecurrenceRuleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRecurrenceRuleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RecurrenceRule model
   */
  readonly fields: RecurrenceRuleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RecurrenceRule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RecurrenceRuleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    chores<T extends RecurrenceRule$choresArgs<ExtArgs> = {}>(args?: Subset<T, RecurrenceRule$choresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChorePayload<ExtArgs>, T, "findMany"> | Null>
    events<T extends RecurrenceRule$eventsArgs<ExtArgs> = {}>(args?: Subset<T, RecurrenceRule$eventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RecurrenceRule model
   */ 
  interface RecurrenceRuleFieldRefs {
    readonly id: FieldRef<"RecurrenceRule", 'String'>
    readonly frequency: FieldRef<"RecurrenceRule", 'RecurrenceFrequency'>
    readonly interval: FieldRef<"RecurrenceRule", 'Int'>
    readonly byWeekDay: FieldRef<"RecurrenceRule", 'DaysOfWeek[]'>
    readonly byMonthDay: FieldRef<"RecurrenceRule", 'Int[]'>
    readonly bySetPos: FieldRef<"RecurrenceRule", 'Int'>
    readonly count: FieldRef<"RecurrenceRule", 'Int'>
    readonly until: FieldRef<"RecurrenceRule", 'DateTime'>
    readonly customRuleString: FieldRef<"RecurrenceRule", 'String'>
  }
    

  // Custom InputTypes
  /**
   * RecurrenceRule findUnique
   */
  export type RecurrenceRuleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurrenceRule
     */
    select?: RecurrenceRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurrenceRuleInclude<ExtArgs> | null
    /**
     * Filter, which RecurrenceRule to fetch.
     */
    where: RecurrenceRuleWhereUniqueInput
  }

  /**
   * RecurrenceRule findUniqueOrThrow
   */
  export type RecurrenceRuleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurrenceRule
     */
    select?: RecurrenceRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurrenceRuleInclude<ExtArgs> | null
    /**
     * Filter, which RecurrenceRule to fetch.
     */
    where: RecurrenceRuleWhereUniqueInput
  }

  /**
   * RecurrenceRule findFirst
   */
  export type RecurrenceRuleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurrenceRule
     */
    select?: RecurrenceRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurrenceRuleInclude<ExtArgs> | null
    /**
     * Filter, which RecurrenceRule to fetch.
     */
    where?: RecurrenceRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecurrenceRules to fetch.
     */
    orderBy?: RecurrenceRuleOrderByWithRelationInput | RecurrenceRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RecurrenceRules.
     */
    cursor?: RecurrenceRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecurrenceRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecurrenceRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RecurrenceRules.
     */
    distinct?: RecurrenceRuleScalarFieldEnum | RecurrenceRuleScalarFieldEnum[]
  }

  /**
   * RecurrenceRule findFirstOrThrow
   */
  export type RecurrenceRuleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurrenceRule
     */
    select?: RecurrenceRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurrenceRuleInclude<ExtArgs> | null
    /**
     * Filter, which RecurrenceRule to fetch.
     */
    where?: RecurrenceRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecurrenceRules to fetch.
     */
    orderBy?: RecurrenceRuleOrderByWithRelationInput | RecurrenceRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RecurrenceRules.
     */
    cursor?: RecurrenceRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecurrenceRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecurrenceRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RecurrenceRules.
     */
    distinct?: RecurrenceRuleScalarFieldEnum | RecurrenceRuleScalarFieldEnum[]
  }

  /**
   * RecurrenceRule findMany
   */
  export type RecurrenceRuleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurrenceRule
     */
    select?: RecurrenceRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurrenceRuleInclude<ExtArgs> | null
    /**
     * Filter, which RecurrenceRules to fetch.
     */
    where?: RecurrenceRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecurrenceRules to fetch.
     */
    orderBy?: RecurrenceRuleOrderByWithRelationInput | RecurrenceRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RecurrenceRules.
     */
    cursor?: RecurrenceRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecurrenceRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecurrenceRules.
     */
    skip?: number
    distinct?: RecurrenceRuleScalarFieldEnum | RecurrenceRuleScalarFieldEnum[]
  }

  /**
   * RecurrenceRule create
   */
  export type RecurrenceRuleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurrenceRule
     */
    select?: RecurrenceRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurrenceRuleInclude<ExtArgs> | null
    /**
     * The data needed to create a RecurrenceRule.
     */
    data: XOR<RecurrenceRuleCreateInput, RecurrenceRuleUncheckedCreateInput>
  }

  /**
   * RecurrenceRule createMany
   */
  export type RecurrenceRuleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RecurrenceRules.
     */
    data: RecurrenceRuleCreateManyInput | RecurrenceRuleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RecurrenceRule createManyAndReturn
   */
  export type RecurrenceRuleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurrenceRule
     */
    select?: RecurrenceRuleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RecurrenceRules.
     */
    data: RecurrenceRuleCreateManyInput | RecurrenceRuleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RecurrenceRule update
   */
  export type RecurrenceRuleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurrenceRule
     */
    select?: RecurrenceRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurrenceRuleInclude<ExtArgs> | null
    /**
     * The data needed to update a RecurrenceRule.
     */
    data: XOR<RecurrenceRuleUpdateInput, RecurrenceRuleUncheckedUpdateInput>
    /**
     * Choose, which RecurrenceRule to update.
     */
    where: RecurrenceRuleWhereUniqueInput
  }

  /**
   * RecurrenceRule updateMany
   */
  export type RecurrenceRuleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RecurrenceRules.
     */
    data: XOR<RecurrenceRuleUpdateManyMutationInput, RecurrenceRuleUncheckedUpdateManyInput>
    /**
     * Filter which RecurrenceRules to update
     */
    where?: RecurrenceRuleWhereInput
  }

  /**
   * RecurrenceRule upsert
   */
  export type RecurrenceRuleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurrenceRule
     */
    select?: RecurrenceRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurrenceRuleInclude<ExtArgs> | null
    /**
     * The filter to search for the RecurrenceRule to update in case it exists.
     */
    where: RecurrenceRuleWhereUniqueInput
    /**
     * In case the RecurrenceRule found by the `where` argument doesn't exist, create a new RecurrenceRule with this data.
     */
    create: XOR<RecurrenceRuleCreateInput, RecurrenceRuleUncheckedCreateInput>
    /**
     * In case the RecurrenceRule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RecurrenceRuleUpdateInput, RecurrenceRuleUncheckedUpdateInput>
  }

  /**
   * RecurrenceRule delete
   */
  export type RecurrenceRuleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurrenceRule
     */
    select?: RecurrenceRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurrenceRuleInclude<ExtArgs> | null
    /**
     * Filter which RecurrenceRule to delete.
     */
    where: RecurrenceRuleWhereUniqueInput
  }

  /**
   * RecurrenceRule deleteMany
   */
  export type RecurrenceRuleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RecurrenceRules to delete
     */
    where?: RecurrenceRuleWhereInput
  }

  /**
   * RecurrenceRule.chores
   */
  export type RecurrenceRule$choresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chore
     */
    select?: ChoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChoreInclude<ExtArgs> | null
    where?: ChoreWhereInput
    orderBy?: ChoreOrderByWithRelationInput | ChoreOrderByWithRelationInput[]
    cursor?: ChoreWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChoreScalarFieldEnum | ChoreScalarFieldEnum[]
  }

  /**
   * RecurrenceRule.events
   */
  export type RecurrenceRule$eventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    where?: EventWhereInput
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    cursor?: EventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * RecurrenceRule without action
   */
  export type RecurrenceRuleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurrenceRule
     */
    select?: RecurrenceRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurrenceRuleInclude<ExtArgs> | null
  }


  /**
   * Model Thread
   */

  export type AggregateThread = {
    _count: ThreadCountAggregateOutputType | null
    _min: ThreadMinAggregateOutputType | null
    _max: ThreadMaxAggregateOutputType | null
  }

  export type ThreadMinAggregateOutputType = {
    id: string | null
    householdId: string | null
    authorId: string | null
    title: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type ThreadMaxAggregateOutputType = {
    id: string | null
    householdId: string | null
    authorId: string | null
    title: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type ThreadCountAggregateOutputType = {
    id: number
    householdId: number
    authorId: number
    title: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type ThreadMinAggregateInputType = {
    id?: true
    householdId?: true
    authorId?: true
    title?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type ThreadMaxAggregateInputType = {
    id?: true
    householdId?: true
    authorId?: true
    title?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type ThreadCountAggregateInputType = {
    id?: true
    householdId?: true
    authorId?: true
    title?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type ThreadAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Thread to aggregate.
     */
    where?: ThreadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Threads to fetch.
     */
    orderBy?: ThreadOrderByWithRelationInput | ThreadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ThreadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Threads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Threads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Threads
    **/
    _count?: true | ThreadCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ThreadMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ThreadMaxAggregateInputType
  }

  export type GetThreadAggregateType<T extends ThreadAggregateArgs> = {
        [P in keyof T & keyof AggregateThread]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateThread[P]>
      : GetScalarType<T[P], AggregateThread[P]>
  }




  export type ThreadGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ThreadWhereInput
    orderBy?: ThreadOrderByWithAggregationInput | ThreadOrderByWithAggregationInput[]
    by: ThreadScalarFieldEnum[] | ThreadScalarFieldEnum
    having?: ThreadScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ThreadCountAggregateInputType | true
    _min?: ThreadMinAggregateInputType
    _max?: ThreadMaxAggregateInputType
  }

  export type ThreadGroupByOutputType = {
    id: string
    householdId: string
    authorId: string
    title: string | null
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: ThreadCountAggregateOutputType | null
    _min: ThreadMinAggregateOutputType | null
    _max: ThreadMaxAggregateOutputType | null
  }

  type GetThreadGroupByPayload<T extends ThreadGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ThreadGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ThreadGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ThreadGroupByOutputType[P]>
            : GetScalarType<T[P], ThreadGroupByOutputType[P]>
        }
      >
    >


  export type ThreadSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    householdId?: boolean
    authorId?: boolean
    title?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    household?: boolean | HouseholdDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
    messages?: boolean | Thread$messagesArgs<ExtArgs>
    participants?: boolean | Thread$participantsArgs<ExtArgs>
    _count?: boolean | ThreadCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["thread"]>

  export type ThreadSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    householdId?: boolean
    authorId?: boolean
    title?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    household?: boolean | HouseholdDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["thread"]>

  export type ThreadSelectScalar = {
    id?: boolean
    householdId?: boolean
    authorId?: boolean
    title?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type ThreadInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    household?: boolean | HouseholdDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
    messages?: boolean | Thread$messagesArgs<ExtArgs>
    participants?: boolean | Thread$participantsArgs<ExtArgs>
    _count?: boolean | ThreadCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ThreadIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    household?: boolean | HouseholdDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ThreadPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Thread"
    objects: {
      household: Prisma.$HouseholdPayload<ExtArgs>
      author: Prisma.$UserPayload<ExtArgs>
      messages: Prisma.$MessagePayload<ExtArgs>[]
      participants: Prisma.$HouseholdMemberPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      householdId: string
      authorId: string
      title: string | null
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["thread"]>
    composites: {}
  }

  type ThreadGetPayload<S extends boolean | null | undefined | ThreadDefaultArgs> = $Result.GetResult<Prisma.$ThreadPayload, S>

  type ThreadCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ThreadFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ThreadCountAggregateInputType | true
    }

  export interface ThreadDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Thread'], meta: { name: 'Thread' } }
    /**
     * Find zero or one Thread that matches the filter.
     * @param {ThreadFindUniqueArgs} args - Arguments to find a Thread
     * @example
     * // Get one Thread
     * const thread = await prisma.thread.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ThreadFindUniqueArgs>(args: SelectSubset<T, ThreadFindUniqueArgs<ExtArgs>>): Prisma__ThreadClient<$Result.GetResult<Prisma.$ThreadPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Thread that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ThreadFindUniqueOrThrowArgs} args - Arguments to find a Thread
     * @example
     * // Get one Thread
     * const thread = await prisma.thread.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ThreadFindUniqueOrThrowArgs>(args: SelectSubset<T, ThreadFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ThreadClient<$Result.GetResult<Prisma.$ThreadPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Thread that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadFindFirstArgs} args - Arguments to find a Thread
     * @example
     * // Get one Thread
     * const thread = await prisma.thread.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ThreadFindFirstArgs>(args?: SelectSubset<T, ThreadFindFirstArgs<ExtArgs>>): Prisma__ThreadClient<$Result.GetResult<Prisma.$ThreadPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Thread that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadFindFirstOrThrowArgs} args - Arguments to find a Thread
     * @example
     * // Get one Thread
     * const thread = await prisma.thread.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ThreadFindFirstOrThrowArgs>(args?: SelectSubset<T, ThreadFindFirstOrThrowArgs<ExtArgs>>): Prisma__ThreadClient<$Result.GetResult<Prisma.$ThreadPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Threads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Threads
     * const threads = await prisma.thread.findMany()
     * 
     * // Get first 10 Threads
     * const threads = await prisma.thread.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const threadWithIdOnly = await prisma.thread.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ThreadFindManyArgs>(args?: SelectSubset<T, ThreadFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ThreadPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Thread.
     * @param {ThreadCreateArgs} args - Arguments to create a Thread.
     * @example
     * // Create one Thread
     * const Thread = await prisma.thread.create({
     *   data: {
     *     // ... data to create a Thread
     *   }
     * })
     * 
     */
    create<T extends ThreadCreateArgs>(args: SelectSubset<T, ThreadCreateArgs<ExtArgs>>): Prisma__ThreadClient<$Result.GetResult<Prisma.$ThreadPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Threads.
     * @param {ThreadCreateManyArgs} args - Arguments to create many Threads.
     * @example
     * // Create many Threads
     * const thread = await prisma.thread.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ThreadCreateManyArgs>(args?: SelectSubset<T, ThreadCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Threads and returns the data saved in the database.
     * @param {ThreadCreateManyAndReturnArgs} args - Arguments to create many Threads.
     * @example
     * // Create many Threads
     * const thread = await prisma.thread.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Threads and only return the `id`
     * const threadWithIdOnly = await prisma.thread.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ThreadCreateManyAndReturnArgs>(args?: SelectSubset<T, ThreadCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ThreadPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Thread.
     * @param {ThreadDeleteArgs} args - Arguments to delete one Thread.
     * @example
     * // Delete one Thread
     * const Thread = await prisma.thread.delete({
     *   where: {
     *     // ... filter to delete one Thread
     *   }
     * })
     * 
     */
    delete<T extends ThreadDeleteArgs>(args: SelectSubset<T, ThreadDeleteArgs<ExtArgs>>): Prisma__ThreadClient<$Result.GetResult<Prisma.$ThreadPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Thread.
     * @param {ThreadUpdateArgs} args - Arguments to update one Thread.
     * @example
     * // Update one Thread
     * const thread = await prisma.thread.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ThreadUpdateArgs>(args: SelectSubset<T, ThreadUpdateArgs<ExtArgs>>): Prisma__ThreadClient<$Result.GetResult<Prisma.$ThreadPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Threads.
     * @param {ThreadDeleteManyArgs} args - Arguments to filter Threads to delete.
     * @example
     * // Delete a few Threads
     * const { count } = await prisma.thread.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ThreadDeleteManyArgs>(args?: SelectSubset<T, ThreadDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Threads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Threads
     * const thread = await prisma.thread.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ThreadUpdateManyArgs>(args: SelectSubset<T, ThreadUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Thread.
     * @param {ThreadUpsertArgs} args - Arguments to update or create a Thread.
     * @example
     * // Update or create a Thread
     * const thread = await prisma.thread.upsert({
     *   create: {
     *     // ... data to create a Thread
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Thread we want to update
     *   }
     * })
     */
    upsert<T extends ThreadUpsertArgs>(args: SelectSubset<T, ThreadUpsertArgs<ExtArgs>>): Prisma__ThreadClient<$Result.GetResult<Prisma.$ThreadPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Threads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadCountArgs} args - Arguments to filter Threads to count.
     * @example
     * // Count the number of Threads
     * const count = await prisma.thread.count({
     *   where: {
     *     // ... the filter for the Threads we want to count
     *   }
     * })
    **/
    count<T extends ThreadCountArgs>(
      args?: Subset<T, ThreadCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ThreadCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Thread.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ThreadAggregateArgs>(args: Subset<T, ThreadAggregateArgs>): Prisma.PrismaPromise<GetThreadAggregateType<T>>

    /**
     * Group by Thread.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ThreadGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ThreadGroupByArgs['orderBy'] }
        : { orderBy?: ThreadGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ThreadGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetThreadGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Thread model
   */
  readonly fields: ThreadFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Thread.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ThreadClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    household<T extends HouseholdDefaultArgs<ExtArgs> = {}>(args?: Subset<T, HouseholdDefaultArgs<ExtArgs>>): Prisma__HouseholdClient<$Result.GetResult<Prisma.$HouseholdPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    author<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    messages<T extends Thread$messagesArgs<ExtArgs> = {}>(args?: Subset<T, Thread$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany"> | Null>
    participants<T extends Thread$participantsArgs<ExtArgs> = {}>(args?: Subset<T, Thread$participantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HouseholdMemberPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Thread model
   */ 
  interface ThreadFieldRefs {
    readonly id: FieldRef<"Thread", 'String'>
    readonly householdId: FieldRef<"Thread", 'String'>
    readonly authorId: FieldRef<"Thread", 'String'>
    readonly title: FieldRef<"Thread", 'String'>
    readonly createdAt: FieldRef<"Thread", 'DateTime'>
    readonly updatedAt: FieldRef<"Thread", 'DateTime'>
    readonly deletedAt: FieldRef<"Thread", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Thread findUnique
   */
  export type ThreadFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Thread
     */
    select?: ThreadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThreadInclude<ExtArgs> | null
    /**
     * Filter, which Thread to fetch.
     */
    where: ThreadWhereUniqueInput
  }

  /**
   * Thread findUniqueOrThrow
   */
  export type ThreadFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Thread
     */
    select?: ThreadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThreadInclude<ExtArgs> | null
    /**
     * Filter, which Thread to fetch.
     */
    where: ThreadWhereUniqueInput
  }

  /**
   * Thread findFirst
   */
  export type ThreadFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Thread
     */
    select?: ThreadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThreadInclude<ExtArgs> | null
    /**
     * Filter, which Thread to fetch.
     */
    where?: ThreadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Threads to fetch.
     */
    orderBy?: ThreadOrderByWithRelationInput | ThreadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Threads.
     */
    cursor?: ThreadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Threads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Threads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Threads.
     */
    distinct?: ThreadScalarFieldEnum | ThreadScalarFieldEnum[]
  }

  /**
   * Thread findFirstOrThrow
   */
  export type ThreadFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Thread
     */
    select?: ThreadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThreadInclude<ExtArgs> | null
    /**
     * Filter, which Thread to fetch.
     */
    where?: ThreadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Threads to fetch.
     */
    orderBy?: ThreadOrderByWithRelationInput | ThreadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Threads.
     */
    cursor?: ThreadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Threads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Threads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Threads.
     */
    distinct?: ThreadScalarFieldEnum | ThreadScalarFieldEnum[]
  }

  /**
   * Thread findMany
   */
  export type ThreadFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Thread
     */
    select?: ThreadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThreadInclude<ExtArgs> | null
    /**
     * Filter, which Threads to fetch.
     */
    where?: ThreadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Threads to fetch.
     */
    orderBy?: ThreadOrderByWithRelationInput | ThreadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Threads.
     */
    cursor?: ThreadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Threads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Threads.
     */
    skip?: number
    distinct?: ThreadScalarFieldEnum | ThreadScalarFieldEnum[]
  }

  /**
   * Thread create
   */
  export type ThreadCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Thread
     */
    select?: ThreadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThreadInclude<ExtArgs> | null
    /**
     * The data needed to create a Thread.
     */
    data: XOR<ThreadCreateInput, ThreadUncheckedCreateInput>
  }

  /**
   * Thread createMany
   */
  export type ThreadCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Threads.
     */
    data: ThreadCreateManyInput | ThreadCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Thread createManyAndReturn
   */
  export type ThreadCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Thread
     */
    select?: ThreadSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Threads.
     */
    data: ThreadCreateManyInput | ThreadCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThreadIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Thread update
   */
  export type ThreadUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Thread
     */
    select?: ThreadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThreadInclude<ExtArgs> | null
    /**
     * The data needed to update a Thread.
     */
    data: XOR<ThreadUpdateInput, ThreadUncheckedUpdateInput>
    /**
     * Choose, which Thread to update.
     */
    where: ThreadWhereUniqueInput
  }

  /**
   * Thread updateMany
   */
  export type ThreadUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Threads.
     */
    data: XOR<ThreadUpdateManyMutationInput, ThreadUncheckedUpdateManyInput>
    /**
     * Filter which Threads to update
     */
    where?: ThreadWhereInput
  }

  /**
   * Thread upsert
   */
  export type ThreadUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Thread
     */
    select?: ThreadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThreadInclude<ExtArgs> | null
    /**
     * The filter to search for the Thread to update in case it exists.
     */
    where: ThreadWhereUniqueInput
    /**
     * In case the Thread found by the `where` argument doesn't exist, create a new Thread with this data.
     */
    create: XOR<ThreadCreateInput, ThreadUncheckedCreateInput>
    /**
     * In case the Thread was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ThreadUpdateInput, ThreadUncheckedUpdateInput>
  }

  /**
   * Thread delete
   */
  export type ThreadDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Thread
     */
    select?: ThreadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThreadInclude<ExtArgs> | null
    /**
     * Filter which Thread to delete.
     */
    where: ThreadWhereUniqueInput
  }

  /**
   * Thread deleteMany
   */
  export type ThreadDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Threads to delete
     */
    where?: ThreadWhereInput
  }

  /**
   * Thread.messages
   */
  export type Thread$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Thread.participants
   */
  export type Thread$participantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HouseholdMember
     */
    select?: HouseholdMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HouseholdMemberInclude<ExtArgs> | null
    where?: HouseholdMemberWhereInput
    orderBy?: HouseholdMemberOrderByWithRelationInput | HouseholdMemberOrderByWithRelationInput[]
    cursor?: HouseholdMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HouseholdMemberScalarFieldEnum | HouseholdMemberScalarFieldEnum[]
  }

  /**
   * Thread without action
   */
  export type ThreadDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Thread
     */
    select?: ThreadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThreadInclude<ExtArgs> | null
  }


  /**
   * Model Message
   */

  export type AggregateMessage = {
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  export type MessageMinAggregateOutputType = {
    id: string | null
    threadId: string | null
    authorId: string | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type MessageMaxAggregateOutputType = {
    id: string | null
    threadId: string | null
    authorId: string | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type MessageCountAggregateOutputType = {
    id: number
    threadId: number
    authorId: number
    content: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type MessageMinAggregateInputType = {
    id?: true
    threadId?: true
    authorId?: true
    content?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type MessageMaxAggregateInputType = {
    id?: true
    threadId?: true
    authorId?: true
    content?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type MessageCountAggregateInputType = {
    id?: true
    threadId?: true
    authorId?: true
    content?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type MessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Message to aggregate.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Messages
    **/
    _count?: true | MessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageMaxAggregateInputType
  }

  export type GetMessageAggregateType<T extends MessageAggregateArgs> = {
        [P in keyof T & keyof AggregateMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessage[P]>
      : GetScalarType<T[P], AggregateMessage[P]>
  }




  export type MessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithAggregationInput | MessageOrderByWithAggregationInput[]
    by: MessageScalarFieldEnum[] | MessageScalarFieldEnum
    having?: MessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageCountAggregateInputType | true
    _min?: MessageMinAggregateInputType
    _max?: MessageMaxAggregateInputType
  }

  export type MessageGroupByOutputType = {
    id: string
    threadId: string
    authorId: string
    content: string
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  type GetMessageGroupByPayload<T extends MessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageGroupByOutputType[P]>
            : GetScalarType<T[P], MessageGroupByOutputType[P]>
        }
      >
    >


  export type MessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    threadId?: boolean
    authorId?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    thread?: boolean | ThreadDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
    attachments?: boolean | Message$attachmentsArgs<ExtArgs>
    reactions?: boolean | Message$reactionsArgs<ExtArgs>
    mentions?: boolean | Message$mentionsArgs<ExtArgs>
    reads?: boolean | Message$readsArgs<ExtArgs>
    _count?: boolean | MessageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    threadId?: boolean
    authorId?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    thread?: boolean | ThreadDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectScalar = {
    id?: boolean
    threadId?: boolean
    authorId?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type MessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    thread?: boolean | ThreadDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
    attachments?: boolean | Message$attachmentsArgs<ExtArgs>
    reactions?: boolean | Message$reactionsArgs<ExtArgs>
    mentions?: boolean | Message$mentionsArgs<ExtArgs>
    reads?: boolean | Message$readsArgs<ExtArgs>
    _count?: boolean | MessageCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    thread?: boolean | ThreadDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Message"
    objects: {
      thread: Prisma.$ThreadPayload<ExtArgs>
      author: Prisma.$UserPayload<ExtArgs>
      attachments: Prisma.$AttachmentPayload<ExtArgs>[]
      reactions: Prisma.$ReactionPayload<ExtArgs>[]
      mentions: Prisma.$MentionPayload<ExtArgs>[]
      reads: Prisma.$MessageReadPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      threadId: string
      authorId: string
      content: string
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["message"]>
    composites: {}
  }

  type MessageGetPayload<S extends boolean | null | undefined | MessageDefaultArgs> = $Result.GetResult<Prisma.$MessagePayload, S>

  type MessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MessageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MessageCountAggregateInputType | true
    }

  export interface MessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Message'], meta: { name: 'Message' } }
    /**
     * Find zero or one Message that matches the filter.
     * @param {MessageFindUniqueArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageFindUniqueArgs>(args: SelectSubset<T, MessageFindUniqueArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Message that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MessageFindUniqueOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Message that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageFindFirstArgs>(args?: SelectSubset<T, MessageFindFirstArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Message that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages
     * const messages = await prisma.message.findMany()
     * 
     * // Get first 10 Messages
     * const messages = await prisma.message.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageWithIdOnly = await prisma.message.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageFindManyArgs>(args?: SelectSubset<T, MessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Message.
     * @param {MessageCreateArgs} args - Arguments to create a Message.
     * @example
     * // Create one Message
     * const Message = await prisma.message.create({
     *   data: {
     *     // ... data to create a Message
     *   }
     * })
     * 
     */
    create<T extends MessageCreateArgs>(args: SelectSubset<T, MessageCreateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Messages.
     * @param {MessageCreateManyArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageCreateManyArgs>(args?: SelectSubset<T, MessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Messages and returns the data saved in the database.
     * @param {MessageCreateManyAndReturnArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MessageCreateManyAndReturnArgs>(args?: SelectSubset<T, MessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Message.
     * @param {MessageDeleteArgs} args - Arguments to delete one Message.
     * @example
     * // Delete one Message
     * const Message = await prisma.message.delete({
     *   where: {
     *     // ... filter to delete one Message
     *   }
     * })
     * 
     */
    delete<T extends MessageDeleteArgs>(args: SelectSubset<T, MessageDeleteArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Message.
     * @param {MessageUpdateArgs} args - Arguments to update one Message.
     * @example
     * // Update one Message
     * const message = await prisma.message.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageUpdateArgs>(args: SelectSubset<T, MessageUpdateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Messages.
     * @param {MessageDeleteManyArgs} args - Arguments to filter Messages to delete.
     * @example
     * // Delete a few Messages
     * const { count } = await prisma.message.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageDeleteManyArgs>(args?: SelectSubset<T, MessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageUpdateManyArgs>(args: SelectSubset<T, MessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Message.
     * @param {MessageUpsertArgs} args - Arguments to update or create a Message.
     * @example
     * // Update or create a Message
     * const message = await prisma.message.upsert({
     *   create: {
     *     // ... data to create a Message
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Message we want to update
     *   }
     * })
     */
    upsert<T extends MessageUpsertArgs>(args: SelectSubset<T, MessageUpsertArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageCountArgs} args - Arguments to filter Messages to count.
     * @example
     * // Count the number of Messages
     * const count = await prisma.message.count({
     *   where: {
     *     // ... the filter for the Messages we want to count
     *   }
     * })
    **/
    count<T extends MessageCountArgs>(
      args?: Subset<T, MessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageAggregateArgs>(args: Subset<T, MessageAggregateArgs>): Prisma.PrismaPromise<GetMessageAggregateType<T>>

    /**
     * Group by Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageGroupByArgs['orderBy'] }
        : { orderBy?: MessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Message model
   */
  readonly fields: MessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Message.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    thread<T extends ThreadDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ThreadDefaultArgs<ExtArgs>>): Prisma__ThreadClient<$Result.GetResult<Prisma.$ThreadPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    author<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    attachments<T extends Message$attachmentsArgs<ExtArgs> = {}>(args?: Subset<T, Message$attachmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findMany"> | Null>
    reactions<T extends Message$reactionsArgs<ExtArgs> = {}>(args?: Subset<T, Message$reactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReactionPayload<ExtArgs>, T, "findMany"> | Null>
    mentions<T extends Message$mentionsArgs<ExtArgs> = {}>(args?: Subset<T, Message$mentionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MentionPayload<ExtArgs>, T, "findMany"> | Null>
    reads<T extends Message$readsArgs<ExtArgs> = {}>(args?: Subset<T, Message$readsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageReadPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Message model
   */ 
  interface MessageFieldRefs {
    readonly id: FieldRef<"Message", 'String'>
    readonly threadId: FieldRef<"Message", 'String'>
    readonly authorId: FieldRef<"Message", 'String'>
    readonly content: FieldRef<"Message", 'String'>
    readonly createdAt: FieldRef<"Message", 'DateTime'>
    readonly updatedAt: FieldRef<"Message", 'DateTime'>
    readonly deletedAt: FieldRef<"Message", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Message findUnique
   */
  export type MessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findUniqueOrThrow
   */
  export type MessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findFirst
   */
  export type MessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findFirstOrThrow
   */
  export type MessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findMany
   */
  export type MessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Messages to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message create
   */
  export type MessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to create a Message.
     */
    data: XOR<MessageCreateInput, MessageUncheckedCreateInput>
  }

  /**
   * Message createMany
   */
  export type MessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Message createManyAndReturn
   */
  export type MessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Message update
   */
  export type MessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to update a Message.
     */
    data: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
    /**
     * Choose, which Message to update.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message updateMany
   */
  export type MessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
  }

  /**
   * Message upsert
   */
  export type MessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The filter to search for the Message to update in case it exists.
     */
    where: MessageWhereUniqueInput
    /**
     * In case the Message found by the `where` argument doesn't exist, create a new Message with this data.
     */
    create: XOR<MessageCreateInput, MessageUncheckedCreateInput>
    /**
     * In case the Message was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
  }

  /**
   * Message delete
   */
  export type MessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter which Message to delete.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message deleteMany
   */
  export type MessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Messages to delete
     */
    where?: MessageWhereInput
  }

  /**
   * Message.attachments
   */
  export type Message$attachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    where?: AttachmentWhereInput
    orderBy?: AttachmentOrderByWithRelationInput | AttachmentOrderByWithRelationInput[]
    cursor?: AttachmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttachmentScalarFieldEnum | AttachmentScalarFieldEnum[]
  }

  /**
   * Message.reactions
   */
  export type Message$reactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reaction
     */
    select?: ReactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReactionInclude<ExtArgs> | null
    where?: ReactionWhereInput
    orderBy?: ReactionOrderByWithRelationInput | ReactionOrderByWithRelationInput[]
    cursor?: ReactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReactionScalarFieldEnum | ReactionScalarFieldEnum[]
  }

  /**
   * Message.mentions
   */
  export type Message$mentionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mention
     */
    select?: MentionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentionInclude<ExtArgs> | null
    where?: MentionWhereInput
    orderBy?: MentionOrderByWithRelationInput | MentionOrderByWithRelationInput[]
    cursor?: MentionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MentionScalarFieldEnum | MentionScalarFieldEnum[]
  }

  /**
   * Message.reads
   */
  export type Message$readsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageRead
     */
    select?: MessageReadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageReadInclude<ExtArgs> | null
    where?: MessageReadWhereInput
    orderBy?: MessageReadOrderByWithRelationInput | MessageReadOrderByWithRelationInput[]
    cursor?: MessageReadWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageReadScalarFieldEnum | MessageReadScalarFieldEnum[]
  }

  /**
   * Message without action
   */
  export type MessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
  }


  /**
   * Model Reaction
   */

  export type AggregateReaction = {
    _count: ReactionCountAggregateOutputType | null
    _min: ReactionMinAggregateOutputType | null
    _max: ReactionMaxAggregateOutputType | null
  }

  export type ReactionMinAggregateOutputType = {
    id: string | null
    messageId: string | null
    userId: string | null
    emoji: string | null
    type: $Enums.ReactionType | null
    createdAt: Date | null
  }

  export type ReactionMaxAggregateOutputType = {
    id: string | null
    messageId: string | null
    userId: string | null
    emoji: string | null
    type: $Enums.ReactionType | null
    createdAt: Date | null
  }

  export type ReactionCountAggregateOutputType = {
    id: number
    messageId: number
    userId: number
    emoji: number
    type: number
    createdAt: number
    _all: number
  }


  export type ReactionMinAggregateInputType = {
    id?: true
    messageId?: true
    userId?: true
    emoji?: true
    type?: true
    createdAt?: true
  }

  export type ReactionMaxAggregateInputType = {
    id?: true
    messageId?: true
    userId?: true
    emoji?: true
    type?: true
    createdAt?: true
  }

  export type ReactionCountAggregateInputType = {
    id?: true
    messageId?: true
    userId?: true
    emoji?: true
    type?: true
    createdAt?: true
    _all?: true
  }

  export type ReactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reaction to aggregate.
     */
    where?: ReactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reactions to fetch.
     */
    orderBy?: ReactionOrderByWithRelationInput | ReactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reactions
    **/
    _count?: true | ReactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReactionMaxAggregateInputType
  }

  export type GetReactionAggregateType<T extends ReactionAggregateArgs> = {
        [P in keyof T & keyof AggregateReaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReaction[P]>
      : GetScalarType<T[P], AggregateReaction[P]>
  }




  export type ReactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReactionWhereInput
    orderBy?: ReactionOrderByWithAggregationInput | ReactionOrderByWithAggregationInput[]
    by: ReactionScalarFieldEnum[] | ReactionScalarFieldEnum
    having?: ReactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReactionCountAggregateInputType | true
    _min?: ReactionMinAggregateInputType
    _max?: ReactionMaxAggregateInputType
  }

  export type ReactionGroupByOutputType = {
    id: string
    messageId: string
    userId: string
    emoji: string
    type: $Enums.ReactionType
    createdAt: Date
    _count: ReactionCountAggregateOutputType | null
    _min: ReactionMinAggregateOutputType | null
    _max: ReactionMaxAggregateOutputType | null
  }

  type GetReactionGroupByPayload<T extends ReactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReactionGroupByOutputType[P]>
            : GetScalarType<T[P], ReactionGroupByOutputType[P]>
        }
      >
    >


  export type ReactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    messageId?: boolean
    userId?: boolean
    emoji?: boolean
    type?: boolean
    createdAt?: boolean
    message?: boolean | MessageDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reaction"]>

  export type ReactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    messageId?: boolean
    userId?: boolean
    emoji?: boolean
    type?: boolean
    createdAt?: boolean
    message?: boolean | MessageDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reaction"]>

  export type ReactionSelectScalar = {
    id?: boolean
    messageId?: boolean
    userId?: boolean
    emoji?: boolean
    type?: boolean
    createdAt?: boolean
  }

  export type ReactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    message?: boolean | MessageDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ReactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    message?: boolean | MessageDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ReactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Reaction"
    objects: {
      message: Prisma.$MessagePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      messageId: string
      userId: string
      emoji: string
      type: $Enums.ReactionType
      createdAt: Date
    }, ExtArgs["result"]["reaction"]>
    composites: {}
  }

  type ReactionGetPayload<S extends boolean | null | undefined | ReactionDefaultArgs> = $Result.GetResult<Prisma.$ReactionPayload, S>

  type ReactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ReactionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ReactionCountAggregateInputType | true
    }

  export interface ReactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Reaction'], meta: { name: 'Reaction' } }
    /**
     * Find zero or one Reaction that matches the filter.
     * @param {ReactionFindUniqueArgs} args - Arguments to find a Reaction
     * @example
     * // Get one Reaction
     * const reaction = await prisma.reaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReactionFindUniqueArgs>(args: SelectSubset<T, ReactionFindUniqueArgs<ExtArgs>>): Prisma__ReactionClient<$Result.GetResult<Prisma.$ReactionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Reaction that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ReactionFindUniqueOrThrowArgs} args - Arguments to find a Reaction
     * @example
     * // Get one Reaction
     * const reaction = await prisma.reaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReactionFindUniqueOrThrowArgs>(args: SelectSubset<T, ReactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReactionClient<$Result.GetResult<Prisma.$ReactionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Reaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReactionFindFirstArgs} args - Arguments to find a Reaction
     * @example
     * // Get one Reaction
     * const reaction = await prisma.reaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReactionFindFirstArgs>(args?: SelectSubset<T, ReactionFindFirstArgs<ExtArgs>>): Prisma__ReactionClient<$Result.GetResult<Prisma.$ReactionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Reaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReactionFindFirstOrThrowArgs} args - Arguments to find a Reaction
     * @example
     * // Get one Reaction
     * const reaction = await prisma.reaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReactionFindFirstOrThrowArgs>(args?: SelectSubset<T, ReactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReactionClient<$Result.GetResult<Prisma.$ReactionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Reactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reactions
     * const reactions = await prisma.reaction.findMany()
     * 
     * // Get first 10 Reactions
     * const reactions = await prisma.reaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reactionWithIdOnly = await prisma.reaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReactionFindManyArgs>(args?: SelectSubset<T, ReactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReactionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Reaction.
     * @param {ReactionCreateArgs} args - Arguments to create a Reaction.
     * @example
     * // Create one Reaction
     * const Reaction = await prisma.reaction.create({
     *   data: {
     *     // ... data to create a Reaction
     *   }
     * })
     * 
     */
    create<T extends ReactionCreateArgs>(args: SelectSubset<T, ReactionCreateArgs<ExtArgs>>): Prisma__ReactionClient<$Result.GetResult<Prisma.$ReactionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Reactions.
     * @param {ReactionCreateManyArgs} args - Arguments to create many Reactions.
     * @example
     * // Create many Reactions
     * const reaction = await prisma.reaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReactionCreateManyArgs>(args?: SelectSubset<T, ReactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Reactions and returns the data saved in the database.
     * @param {ReactionCreateManyAndReturnArgs} args - Arguments to create many Reactions.
     * @example
     * // Create many Reactions
     * const reaction = await prisma.reaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Reactions and only return the `id`
     * const reactionWithIdOnly = await prisma.reaction.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReactionCreateManyAndReturnArgs>(args?: SelectSubset<T, ReactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReactionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Reaction.
     * @param {ReactionDeleteArgs} args - Arguments to delete one Reaction.
     * @example
     * // Delete one Reaction
     * const Reaction = await prisma.reaction.delete({
     *   where: {
     *     // ... filter to delete one Reaction
     *   }
     * })
     * 
     */
    delete<T extends ReactionDeleteArgs>(args: SelectSubset<T, ReactionDeleteArgs<ExtArgs>>): Prisma__ReactionClient<$Result.GetResult<Prisma.$ReactionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Reaction.
     * @param {ReactionUpdateArgs} args - Arguments to update one Reaction.
     * @example
     * // Update one Reaction
     * const reaction = await prisma.reaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReactionUpdateArgs>(args: SelectSubset<T, ReactionUpdateArgs<ExtArgs>>): Prisma__ReactionClient<$Result.GetResult<Prisma.$ReactionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Reactions.
     * @param {ReactionDeleteManyArgs} args - Arguments to filter Reactions to delete.
     * @example
     * // Delete a few Reactions
     * const { count } = await prisma.reaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReactionDeleteManyArgs>(args?: SelectSubset<T, ReactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reactions
     * const reaction = await prisma.reaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReactionUpdateManyArgs>(args: SelectSubset<T, ReactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Reaction.
     * @param {ReactionUpsertArgs} args - Arguments to update or create a Reaction.
     * @example
     * // Update or create a Reaction
     * const reaction = await prisma.reaction.upsert({
     *   create: {
     *     // ... data to create a Reaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Reaction we want to update
     *   }
     * })
     */
    upsert<T extends ReactionUpsertArgs>(args: SelectSubset<T, ReactionUpsertArgs<ExtArgs>>): Prisma__ReactionClient<$Result.GetResult<Prisma.$ReactionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Reactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReactionCountArgs} args - Arguments to filter Reactions to count.
     * @example
     * // Count the number of Reactions
     * const count = await prisma.reaction.count({
     *   where: {
     *     // ... the filter for the Reactions we want to count
     *   }
     * })
    **/
    count<T extends ReactionCountArgs>(
      args?: Subset<T, ReactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Reaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReactionAggregateArgs>(args: Subset<T, ReactionAggregateArgs>): Prisma.PrismaPromise<GetReactionAggregateType<T>>

    /**
     * Group by Reaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReactionGroupByArgs['orderBy'] }
        : { orderBy?: ReactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Reaction model
   */
  readonly fields: ReactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Reaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    message<T extends MessageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MessageDefaultArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Reaction model
   */ 
  interface ReactionFieldRefs {
    readonly id: FieldRef<"Reaction", 'String'>
    readonly messageId: FieldRef<"Reaction", 'String'>
    readonly userId: FieldRef<"Reaction", 'String'>
    readonly emoji: FieldRef<"Reaction", 'String'>
    readonly type: FieldRef<"Reaction", 'ReactionType'>
    readonly createdAt: FieldRef<"Reaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Reaction findUnique
   */
  export type ReactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reaction
     */
    select?: ReactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReactionInclude<ExtArgs> | null
    /**
     * Filter, which Reaction to fetch.
     */
    where: ReactionWhereUniqueInput
  }

  /**
   * Reaction findUniqueOrThrow
   */
  export type ReactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reaction
     */
    select?: ReactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReactionInclude<ExtArgs> | null
    /**
     * Filter, which Reaction to fetch.
     */
    where: ReactionWhereUniqueInput
  }

  /**
   * Reaction findFirst
   */
  export type ReactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reaction
     */
    select?: ReactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReactionInclude<ExtArgs> | null
    /**
     * Filter, which Reaction to fetch.
     */
    where?: ReactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reactions to fetch.
     */
    orderBy?: ReactionOrderByWithRelationInput | ReactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reactions.
     */
    cursor?: ReactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reactions.
     */
    distinct?: ReactionScalarFieldEnum | ReactionScalarFieldEnum[]
  }

  /**
   * Reaction findFirstOrThrow
   */
  export type ReactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reaction
     */
    select?: ReactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReactionInclude<ExtArgs> | null
    /**
     * Filter, which Reaction to fetch.
     */
    where?: ReactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reactions to fetch.
     */
    orderBy?: ReactionOrderByWithRelationInput | ReactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reactions.
     */
    cursor?: ReactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reactions.
     */
    distinct?: ReactionScalarFieldEnum | ReactionScalarFieldEnum[]
  }

  /**
   * Reaction findMany
   */
  export type ReactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reaction
     */
    select?: ReactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReactionInclude<ExtArgs> | null
    /**
     * Filter, which Reactions to fetch.
     */
    where?: ReactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reactions to fetch.
     */
    orderBy?: ReactionOrderByWithRelationInput | ReactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reactions.
     */
    cursor?: ReactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reactions.
     */
    skip?: number
    distinct?: ReactionScalarFieldEnum | ReactionScalarFieldEnum[]
  }

  /**
   * Reaction create
   */
  export type ReactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reaction
     */
    select?: ReactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReactionInclude<ExtArgs> | null
    /**
     * The data needed to create a Reaction.
     */
    data: XOR<ReactionCreateInput, ReactionUncheckedCreateInput>
  }

  /**
   * Reaction createMany
   */
  export type ReactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reactions.
     */
    data: ReactionCreateManyInput | ReactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Reaction createManyAndReturn
   */
  export type ReactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reaction
     */
    select?: ReactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Reactions.
     */
    data: ReactionCreateManyInput | ReactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Reaction update
   */
  export type ReactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reaction
     */
    select?: ReactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReactionInclude<ExtArgs> | null
    /**
     * The data needed to update a Reaction.
     */
    data: XOR<ReactionUpdateInput, ReactionUncheckedUpdateInput>
    /**
     * Choose, which Reaction to update.
     */
    where: ReactionWhereUniqueInput
  }

  /**
   * Reaction updateMany
   */
  export type ReactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reactions.
     */
    data: XOR<ReactionUpdateManyMutationInput, ReactionUncheckedUpdateManyInput>
    /**
     * Filter which Reactions to update
     */
    where?: ReactionWhereInput
  }

  /**
   * Reaction upsert
   */
  export type ReactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reaction
     */
    select?: ReactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReactionInclude<ExtArgs> | null
    /**
     * The filter to search for the Reaction to update in case it exists.
     */
    where: ReactionWhereUniqueInput
    /**
     * In case the Reaction found by the `where` argument doesn't exist, create a new Reaction with this data.
     */
    create: XOR<ReactionCreateInput, ReactionUncheckedCreateInput>
    /**
     * In case the Reaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReactionUpdateInput, ReactionUncheckedUpdateInput>
  }

  /**
   * Reaction delete
   */
  export type ReactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reaction
     */
    select?: ReactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReactionInclude<ExtArgs> | null
    /**
     * Filter which Reaction to delete.
     */
    where: ReactionWhereUniqueInput
  }

  /**
   * Reaction deleteMany
   */
  export type ReactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reactions to delete
     */
    where?: ReactionWhereInput
  }

  /**
   * Reaction without action
   */
  export type ReactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reaction
     */
    select?: ReactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReactionInclude<ExtArgs> | null
  }


  /**
   * Model Mention
   */

  export type AggregateMention = {
    _count: MentionCountAggregateOutputType | null
    _min: MentionMinAggregateOutputType | null
    _max: MentionMaxAggregateOutputType | null
  }

  export type MentionMinAggregateOutputType = {
    id: string | null
    messageId: string | null
    userId: string | null
    mentionedAt: Date | null
  }

  export type MentionMaxAggregateOutputType = {
    id: string | null
    messageId: string | null
    userId: string | null
    mentionedAt: Date | null
  }

  export type MentionCountAggregateOutputType = {
    id: number
    messageId: number
    userId: number
    mentionedAt: number
    _all: number
  }


  export type MentionMinAggregateInputType = {
    id?: true
    messageId?: true
    userId?: true
    mentionedAt?: true
  }

  export type MentionMaxAggregateInputType = {
    id?: true
    messageId?: true
    userId?: true
    mentionedAt?: true
  }

  export type MentionCountAggregateInputType = {
    id?: true
    messageId?: true
    userId?: true
    mentionedAt?: true
    _all?: true
  }

  export type MentionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Mention to aggregate.
     */
    where?: MentionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mentions to fetch.
     */
    orderBy?: MentionOrderByWithRelationInput | MentionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MentionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mentions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mentions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Mentions
    **/
    _count?: true | MentionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MentionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MentionMaxAggregateInputType
  }

  export type GetMentionAggregateType<T extends MentionAggregateArgs> = {
        [P in keyof T & keyof AggregateMention]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMention[P]>
      : GetScalarType<T[P], AggregateMention[P]>
  }




  export type MentionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MentionWhereInput
    orderBy?: MentionOrderByWithAggregationInput | MentionOrderByWithAggregationInput[]
    by: MentionScalarFieldEnum[] | MentionScalarFieldEnum
    having?: MentionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MentionCountAggregateInputType | true
    _min?: MentionMinAggregateInputType
    _max?: MentionMaxAggregateInputType
  }

  export type MentionGroupByOutputType = {
    id: string
    messageId: string
    userId: string
    mentionedAt: Date
    _count: MentionCountAggregateOutputType | null
    _min: MentionMinAggregateOutputType | null
    _max: MentionMaxAggregateOutputType | null
  }

  type GetMentionGroupByPayload<T extends MentionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MentionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MentionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MentionGroupByOutputType[P]>
            : GetScalarType<T[P], MentionGroupByOutputType[P]>
        }
      >
    >


  export type MentionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    messageId?: boolean
    userId?: boolean
    mentionedAt?: boolean
    message?: boolean | MessageDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mention"]>

  export type MentionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    messageId?: boolean
    userId?: boolean
    mentionedAt?: boolean
    message?: boolean | MessageDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mention"]>

  export type MentionSelectScalar = {
    id?: boolean
    messageId?: boolean
    userId?: boolean
    mentionedAt?: boolean
  }

  export type MentionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    message?: boolean | MessageDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MentionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    message?: boolean | MessageDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MentionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Mention"
    objects: {
      message: Prisma.$MessagePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      messageId: string
      userId: string
      mentionedAt: Date
    }, ExtArgs["result"]["mention"]>
    composites: {}
  }

  type MentionGetPayload<S extends boolean | null | undefined | MentionDefaultArgs> = $Result.GetResult<Prisma.$MentionPayload, S>

  type MentionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MentionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MentionCountAggregateInputType | true
    }

  export interface MentionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Mention'], meta: { name: 'Mention' } }
    /**
     * Find zero or one Mention that matches the filter.
     * @param {MentionFindUniqueArgs} args - Arguments to find a Mention
     * @example
     * // Get one Mention
     * const mention = await prisma.mention.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MentionFindUniqueArgs>(args: SelectSubset<T, MentionFindUniqueArgs<ExtArgs>>): Prisma__MentionClient<$Result.GetResult<Prisma.$MentionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Mention that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MentionFindUniqueOrThrowArgs} args - Arguments to find a Mention
     * @example
     * // Get one Mention
     * const mention = await prisma.mention.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MentionFindUniqueOrThrowArgs>(args: SelectSubset<T, MentionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MentionClient<$Result.GetResult<Prisma.$MentionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Mention that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentionFindFirstArgs} args - Arguments to find a Mention
     * @example
     * // Get one Mention
     * const mention = await prisma.mention.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MentionFindFirstArgs>(args?: SelectSubset<T, MentionFindFirstArgs<ExtArgs>>): Prisma__MentionClient<$Result.GetResult<Prisma.$MentionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Mention that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentionFindFirstOrThrowArgs} args - Arguments to find a Mention
     * @example
     * // Get one Mention
     * const mention = await prisma.mention.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MentionFindFirstOrThrowArgs>(args?: SelectSubset<T, MentionFindFirstOrThrowArgs<ExtArgs>>): Prisma__MentionClient<$Result.GetResult<Prisma.$MentionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Mentions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Mentions
     * const mentions = await prisma.mention.findMany()
     * 
     * // Get first 10 Mentions
     * const mentions = await prisma.mention.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mentionWithIdOnly = await prisma.mention.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MentionFindManyArgs>(args?: SelectSubset<T, MentionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MentionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Mention.
     * @param {MentionCreateArgs} args - Arguments to create a Mention.
     * @example
     * // Create one Mention
     * const Mention = await prisma.mention.create({
     *   data: {
     *     // ... data to create a Mention
     *   }
     * })
     * 
     */
    create<T extends MentionCreateArgs>(args: SelectSubset<T, MentionCreateArgs<ExtArgs>>): Prisma__MentionClient<$Result.GetResult<Prisma.$MentionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Mentions.
     * @param {MentionCreateManyArgs} args - Arguments to create many Mentions.
     * @example
     * // Create many Mentions
     * const mention = await prisma.mention.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MentionCreateManyArgs>(args?: SelectSubset<T, MentionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Mentions and returns the data saved in the database.
     * @param {MentionCreateManyAndReturnArgs} args - Arguments to create many Mentions.
     * @example
     * // Create many Mentions
     * const mention = await prisma.mention.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Mentions and only return the `id`
     * const mentionWithIdOnly = await prisma.mention.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MentionCreateManyAndReturnArgs>(args?: SelectSubset<T, MentionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MentionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Mention.
     * @param {MentionDeleteArgs} args - Arguments to delete one Mention.
     * @example
     * // Delete one Mention
     * const Mention = await prisma.mention.delete({
     *   where: {
     *     // ... filter to delete one Mention
     *   }
     * })
     * 
     */
    delete<T extends MentionDeleteArgs>(args: SelectSubset<T, MentionDeleteArgs<ExtArgs>>): Prisma__MentionClient<$Result.GetResult<Prisma.$MentionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Mention.
     * @param {MentionUpdateArgs} args - Arguments to update one Mention.
     * @example
     * // Update one Mention
     * const mention = await prisma.mention.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MentionUpdateArgs>(args: SelectSubset<T, MentionUpdateArgs<ExtArgs>>): Prisma__MentionClient<$Result.GetResult<Prisma.$MentionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Mentions.
     * @param {MentionDeleteManyArgs} args - Arguments to filter Mentions to delete.
     * @example
     * // Delete a few Mentions
     * const { count } = await prisma.mention.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MentionDeleteManyArgs>(args?: SelectSubset<T, MentionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Mentions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Mentions
     * const mention = await prisma.mention.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MentionUpdateManyArgs>(args: SelectSubset<T, MentionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Mention.
     * @param {MentionUpsertArgs} args - Arguments to update or create a Mention.
     * @example
     * // Update or create a Mention
     * const mention = await prisma.mention.upsert({
     *   create: {
     *     // ... data to create a Mention
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Mention we want to update
     *   }
     * })
     */
    upsert<T extends MentionUpsertArgs>(args: SelectSubset<T, MentionUpsertArgs<ExtArgs>>): Prisma__MentionClient<$Result.GetResult<Prisma.$MentionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Mentions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentionCountArgs} args - Arguments to filter Mentions to count.
     * @example
     * // Count the number of Mentions
     * const count = await prisma.mention.count({
     *   where: {
     *     // ... the filter for the Mentions we want to count
     *   }
     * })
    **/
    count<T extends MentionCountArgs>(
      args?: Subset<T, MentionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MentionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Mention.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MentionAggregateArgs>(args: Subset<T, MentionAggregateArgs>): Prisma.PrismaPromise<GetMentionAggregateType<T>>

    /**
     * Group by Mention.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MentionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MentionGroupByArgs['orderBy'] }
        : { orderBy?: MentionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MentionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMentionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Mention model
   */
  readonly fields: MentionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Mention.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MentionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    message<T extends MessageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MessageDefaultArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Mention model
   */ 
  interface MentionFieldRefs {
    readonly id: FieldRef<"Mention", 'String'>
    readonly messageId: FieldRef<"Mention", 'String'>
    readonly userId: FieldRef<"Mention", 'String'>
    readonly mentionedAt: FieldRef<"Mention", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Mention findUnique
   */
  export type MentionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mention
     */
    select?: MentionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentionInclude<ExtArgs> | null
    /**
     * Filter, which Mention to fetch.
     */
    where: MentionWhereUniqueInput
  }

  /**
   * Mention findUniqueOrThrow
   */
  export type MentionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mention
     */
    select?: MentionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentionInclude<ExtArgs> | null
    /**
     * Filter, which Mention to fetch.
     */
    where: MentionWhereUniqueInput
  }

  /**
   * Mention findFirst
   */
  export type MentionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mention
     */
    select?: MentionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentionInclude<ExtArgs> | null
    /**
     * Filter, which Mention to fetch.
     */
    where?: MentionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mentions to fetch.
     */
    orderBy?: MentionOrderByWithRelationInput | MentionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Mentions.
     */
    cursor?: MentionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mentions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mentions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Mentions.
     */
    distinct?: MentionScalarFieldEnum | MentionScalarFieldEnum[]
  }

  /**
   * Mention findFirstOrThrow
   */
  export type MentionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mention
     */
    select?: MentionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentionInclude<ExtArgs> | null
    /**
     * Filter, which Mention to fetch.
     */
    where?: MentionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mentions to fetch.
     */
    orderBy?: MentionOrderByWithRelationInput | MentionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Mentions.
     */
    cursor?: MentionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mentions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mentions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Mentions.
     */
    distinct?: MentionScalarFieldEnum | MentionScalarFieldEnum[]
  }

  /**
   * Mention findMany
   */
  export type MentionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mention
     */
    select?: MentionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentionInclude<ExtArgs> | null
    /**
     * Filter, which Mentions to fetch.
     */
    where?: MentionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mentions to fetch.
     */
    orderBy?: MentionOrderByWithRelationInput | MentionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Mentions.
     */
    cursor?: MentionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mentions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mentions.
     */
    skip?: number
    distinct?: MentionScalarFieldEnum | MentionScalarFieldEnum[]
  }

  /**
   * Mention create
   */
  export type MentionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mention
     */
    select?: MentionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentionInclude<ExtArgs> | null
    /**
     * The data needed to create a Mention.
     */
    data: XOR<MentionCreateInput, MentionUncheckedCreateInput>
  }

  /**
   * Mention createMany
   */
  export type MentionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Mentions.
     */
    data: MentionCreateManyInput | MentionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Mention createManyAndReturn
   */
  export type MentionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mention
     */
    select?: MentionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Mentions.
     */
    data: MentionCreateManyInput | MentionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Mention update
   */
  export type MentionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mention
     */
    select?: MentionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentionInclude<ExtArgs> | null
    /**
     * The data needed to update a Mention.
     */
    data: XOR<MentionUpdateInput, MentionUncheckedUpdateInput>
    /**
     * Choose, which Mention to update.
     */
    where: MentionWhereUniqueInput
  }

  /**
   * Mention updateMany
   */
  export type MentionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Mentions.
     */
    data: XOR<MentionUpdateManyMutationInput, MentionUncheckedUpdateManyInput>
    /**
     * Filter which Mentions to update
     */
    where?: MentionWhereInput
  }

  /**
   * Mention upsert
   */
  export type MentionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mention
     */
    select?: MentionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentionInclude<ExtArgs> | null
    /**
     * The filter to search for the Mention to update in case it exists.
     */
    where: MentionWhereUniqueInput
    /**
     * In case the Mention found by the `where` argument doesn't exist, create a new Mention with this data.
     */
    create: XOR<MentionCreateInput, MentionUncheckedCreateInput>
    /**
     * In case the Mention was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MentionUpdateInput, MentionUncheckedUpdateInput>
  }

  /**
   * Mention delete
   */
  export type MentionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mention
     */
    select?: MentionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentionInclude<ExtArgs> | null
    /**
     * Filter which Mention to delete.
     */
    where: MentionWhereUniqueInput
  }

  /**
   * Mention deleteMany
   */
  export type MentionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Mentions to delete
     */
    where?: MentionWhereInput
  }

  /**
   * Mention without action
   */
  export type MentionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mention
     */
    select?: MentionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentionInclude<ExtArgs> | null
  }


  /**
   * Model Attachment
   */

  export type AggregateAttachment = {
    _count: AttachmentCountAggregateOutputType | null
    _min: AttachmentMinAggregateOutputType | null
    _max: AttachmentMaxAggregateOutputType | null
  }

  export type AttachmentMinAggregateOutputType = {
    id: string | null
    messageId: string | null
    url: string | null
    fileType: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type AttachmentMaxAggregateOutputType = {
    id: string | null
    messageId: string | null
    url: string | null
    fileType: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type AttachmentCountAggregateOutputType = {
    id: number
    messageId: number
    url: number
    fileType: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type AttachmentMinAggregateInputType = {
    id?: true
    messageId?: true
    url?: true
    fileType?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type AttachmentMaxAggregateInputType = {
    id?: true
    messageId?: true
    url?: true
    fileType?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type AttachmentCountAggregateInputType = {
    id?: true
    messageId?: true
    url?: true
    fileType?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type AttachmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Attachment to aggregate.
     */
    where?: AttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attachments to fetch.
     */
    orderBy?: AttachmentOrderByWithRelationInput | AttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Attachments
    **/
    _count?: true | AttachmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AttachmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AttachmentMaxAggregateInputType
  }

  export type GetAttachmentAggregateType<T extends AttachmentAggregateArgs> = {
        [P in keyof T & keyof AggregateAttachment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAttachment[P]>
      : GetScalarType<T[P], AggregateAttachment[P]>
  }




  export type AttachmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttachmentWhereInput
    orderBy?: AttachmentOrderByWithAggregationInput | AttachmentOrderByWithAggregationInput[]
    by: AttachmentScalarFieldEnum[] | AttachmentScalarFieldEnum
    having?: AttachmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AttachmentCountAggregateInputType | true
    _min?: AttachmentMinAggregateInputType
    _max?: AttachmentMaxAggregateInputType
  }

  export type AttachmentGroupByOutputType = {
    id: string
    messageId: string
    url: string
    fileType: string
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: AttachmentCountAggregateOutputType | null
    _min: AttachmentMinAggregateOutputType | null
    _max: AttachmentMaxAggregateOutputType | null
  }

  type GetAttachmentGroupByPayload<T extends AttachmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AttachmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AttachmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AttachmentGroupByOutputType[P]>
            : GetScalarType<T[P], AttachmentGroupByOutputType[P]>
        }
      >
    >


  export type AttachmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    messageId?: boolean
    url?: boolean
    fileType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    message?: boolean | MessageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attachment"]>

  export type AttachmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    messageId?: boolean
    url?: boolean
    fileType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    message?: boolean | MessageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attachment"]>

  export type AttachmentSelectScalar = {
    id?: boolean
    messageId?: boolean
    url?: boolean
    fileType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type AttachmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    message?: boolean | MessageDefaultArgs<ExtArgs>
  }
  export type AttachmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    message?: boolean | MessageDefaultArgs<ExtArgs>
  }

  export type $AttachmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Attachment"
    objects: {
      message: Prisma.$MessagePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      messageId: string
      url: string
      fileType: string
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["attachment"]>
    composites: {}
  }

  type AttachmentGetPayload<S extends boolean | null | undefined | AttachmentDefaultArgs> = $Result.GetResult<Prisma.$AttachmentPayload, S>

  type AttachmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AttachmentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AttachmentCountAggregateInputType | true
    }

  export interface AttachmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Attachment'], meta: { name: 'Attachment' } }
    /**
     * Find zero or one Attachment that matches the filter.
     * @param {AttachmentFindUniqueArgs} args - Arguments to find a Attachment
     * @example
     * // Get one Attachment
     * const attachment = await prisma.attachment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AttachmentFindUniqueArgs>(args: SelectSubset<T, AttachmentFindUniqueArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Attachment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AttachmentFindUniqueOrThrowArgs} args - Arguments to find a Attachment
     * @example
     * // Get one Attachment
     * const attachment = await prisma.attachment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AttachmentFindUniqueOrThrowArgs>(args: SelectSubset<T, AttachmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Attachment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentFindFirstArgs} args - Arguments to find a Attachment
     * @example
     * // Get one Attachment
     * const attachment = await prisma.attachment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AttachmentFindFirstArgs>(args?: SelectSubset<T, AttachmentFindFirstArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Attachment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentFindFirstOrThrowArgs} args - Arguments to find a Attachment
     * @example
     * // Get one Attachment
     * const attachment = await prisma.attachment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AttachmentFindFirstOrThrowArgs>(args?: SelectSubset<T, AttachmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Attachments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Attachments
     * const attachments = await prisma.attachment.findMany()
     * 
     * // Get first 10 Attachments
     * const attachments = await prisma.attachment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const attachmentWithIdOnly = await prisma.attachment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AttachmentFindManyArgs>(args?: SelectSubset<T, AttachmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Attachment.
     * @param {AttachmentCreateArgs} args - Arguments to create a Attachment.
     * @example
     * // Create one Attachment
     * const Attachment = await prisma.attachment.create({
     *   data: {
     *     // ... data to create a Attachment
     *   }
     * })
     * 
     */
    create<T extends AttachmentCreateArgs>(args: SelectSubset<T, AttachmentCreateArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Attachments.
     * @param {AttachmentCreateManyArgs} args - Arguments to create many Attachments.
     * @example
     * // Create many Attachments
     * const attachment = await prisma.attachment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AttachmentCreateManyArgs>(args?: SelectSubset<T, AttachmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Attachments and returns the data saved in the database.
     * @param {AttachmentCreateManyAndReturnArgs} args - Arguments to create many Attachments.
     * @example
     * // Create many Attachments
     * const attachment = await prisma.attachment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Attachments and only return the `id`
     * const attachmentWithIdOnly = await prisma.attachment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AttachmentCreateManyAndReturnArgs>(args?: SelectSubset<T, AttachmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Attachment.
     * @param {AttachmentDeleteArgs} args - Arguments to delete one Attachment.
     * @example
     * // Delete one Attachment
     * const Attachment = await prisma.attachment.delete({
     *   where: {
     *     // ... filter to delete one Attachment
     *   }
     * })
     * 
     */
    delete<T extends AttachmentDeleteArgs>(args: SelectSubset<T, AttachmentDeleteArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Attachment.
     * @param {AttachmentUpdateArgs} args - Arguments to update one Attachment.
     * @example
     * // Update one Attachment
     * const attachment = await prisma.attachment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AttachmentUpdateArgs>(args: SelectSubset<T, AttachmentUpdateArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Attachments.
     * @param {AttachmentDeleteManyArgs} args - Arguments to filter Attachments to delete.
     * @example
     * // Delete a few Attachments
     * const { count } = await prisma.attachment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AttachmentDeleteManyArgs>(args?: SelectSubset<T, AttachmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Attachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Attachments
     * const attachment = await prisma.attachment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AttachmentUpdateManyArgs>(args: SelectSubset<T, AttachmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Attachment.
     * @param {AttachmentUpsertArgs} args - Arguments to update or create a Attachment.
     * @example
     * // Update or create a Attachment
     * const attachment = await prisma.attachment.upsert({
     *   create: {
     *     // ... data to create a Attachment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Attachment we want to update
     *   }
     * })
     */
    upsert<T extends AttachmentUpsertArgs>(args: SelectSubset<T, AttachmentUpsertArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Attachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentCountArgs} args - Arguments to filter Attachments to count.
     * @example
     * // Count the number of Attachments
     * const count = await prisma.attachment.count({
     *   where: {
     *     // ... the filter for the Attachments we want to count
     *   }
     * })
    **/
    count<T extends AttachmentCountArgs>(
      args?: Subset<T, AttachmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AttachmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Attachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AttachmentAggregateArgs>(args: Subset<T, AttachmentAggregateArgs>): Prisma.PrismaPromise<GetAttachmentAggregateType<T>>

    /**
     * Group by Attachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AttachmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AttachmentGroupByArgs['orderBy'] }
        : { orderBy?: AttachmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AttachmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAttachmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Attachment model
   */
  readonly fields: AttachmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Attachment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AttachmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    message<T extends MessageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MessageDefaultArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Attachment model
   */ 
  interface AttachmentFieldRefs {
    readonly id: FieldRef<"Attachment", 'String'>
    readonly messageId: FieldRef<"Attachment", 'String'>
    readonly url: FieldRef<"Attachment", 'String'>
    readonly fileType: FieldRef<"Attachment", 'String'>
    readonly createdAt: FieldRef<"Attachment", 'DateTime'>
    readonly updatedAt: FieldRef<"Attachment", 'DateTime'>
    readonly deletedAt: FieldRef<"Attachment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Attachment findUnique
   */
  export type AttachmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * Filter, which Attachment to fetch.
     */
    where: AttachmentWhereUniqueInput
  }

  /**
   * Attachment findUniqueOrThrow
   */
  export type AttachmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * Filter, which Attachment to fetch.
     */
    where: AttachmentWhereUniqueInput
  }

  /**
   * Attachment findFirst
   */
  export type AttachmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * Filter, which Attachment to fetch.
     */
    where?: AttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attachments to fetch.
     */
    orderBy?: AttachmentOrderByWithRelationInput | AttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Attachments.
     */
    cursor?: AttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Attachments.
     */
    distinct?: AttachmentScalarFieldEnum | AttachmentScalarFieldEnum[]
  }

  /**
   * Attachment findFirstOrThrow
   */
  export type AttachmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * Filter, which Attachment to fetch.
     */
    where?: AttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attachments to fetch.
     */
    orderBy?: AttachmentOrderByWithRelationInput | AttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Attachments.
     */
    cursor?: AttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Attachments.
     */
    distinct?: AttachmentScalarFieldEnum | AttachmentScalarFieldEnum[]
  }

  /**
   * Attachment findMany
   */
  export type AttachmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * Filter, which Attachments to fetch.
     */
    where?: AttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attachments to fetch.
     */
    orderBy?: AttachmentOrderByWithRelationInput | AttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Attachments.
     */
    cursor?: AttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attachments.
     */
    skip?: number
    distinct?: AttachmentScalarFieldEnum | AttachmentScalarFieldEnum[]
  }

  /**
   * Attachment create
   */
  export type AttachmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Attachment.
     */
    data: XOR<AttachmentCreateInput, AttachmentUncheckedCreateInput>
  }

  /**
   * Attachment createMany
   */
  export type AttachmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Attachments.
     */
    data: AttachmentCreateManyInput | AttachmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Attachment createManyAndReturn
   */
  export type AttachmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Attachments.
     */
    data: AttachmentCreateManyInput | AttachmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Attachment update
   */
  export type AttachmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Attachment.
     */
    data: XOR<AttachmentUpdateInput, AttachmentUncheckedUpdateInput>
    /**
     * Choose, which Attachment to update.
     */
    where: AttachmentWhereUniqueInput
  }

  /**
   * Attachment updateMany
   */
  export type AttachmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Attachments.
     */
    data: XOR<AttachmentUpdateManyMutationInput, AttachmentUncheckedUpdateManyInput>
    /**
     * Filter which Attachments to update
     */
    where?: AttachmentWhereInput
  }

  /**
   * Attachment upsert
   */
  export type AttachmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Attachment to update in case it exists.
     */
    where: AttachmentWhereUniqueInput
    /**
     * In case the Attachment found by the `where` argument doesn't exist, create a new Attachment with this data.
     */
    create: XOR<AttachmentCreateInput, AttachmentUncheckedCreateInput>
    /**
     * In case the Attachment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AttachmentUpdateInput, AttachmentUncheckedUpdateInput>
  }

  /**
   * Attachment delete
   */
  export type AttachmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * Filter which Attachment to delete.
     */
    where: AttachmentWhereUniqueInput
  }

  /**
   * Attachment deleteMany
   */
  export type AttachmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Attachments to delete
     */
    where?: AttachmentWhereInput
  }

  /**
   * Attachment without action
   */
  export type AttachmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
  }


  /**
   * Model MessageRead
   */

  export type AggregateMessageRead = {
    _count: MessageReadCountAggregateOutputType | null
    _min: MessageReadMinAggregateOutputType | null
    _max: MessageReadMaxAggregateOutputType | null
  }

  export type MessageReadMinAggregateOutputType = {
    id: string | null
    messageId: string | null
    userId: string | null
    readAt: Date | null
  }

  export type MessageReadMaxAggregateOutputType = {
    id: string | null
    messageId: string | null
    userId: string | null
    readAt: Date | null
  }

  export type MessageReadCountAggregateOutputType = {
    id: number
    messageId: number
    userId: number
    readAt: number
    _all: number
  }


  export type MessageReadMinAggregateInputType = {
    id?: true
    messageId?: true
    userId?: true
    readAt?: true
  }

  export type MessageReadMaxAggregateInputType = {
    id?: true
    messageId?: true
    userId?: true
    readAt?: true
  }

  export type MessageReadCountAggregateInputType = {
    id?: true
    messageId?: true
    userId?: true
    readAt?: true
    _all?: true
  }

  export type MessageReadAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MessageRead to aggregate.
     */
    where?: MessageReadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageReads to fetch.
     */
    orderBy?: MessageReadOrderByWithRelationInput | MessageReadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageReadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageReads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageReads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MessageReads
    **/
    _count?: true | MessageReadCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageReadMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageReadMaxAggregateInputType
  }

  export type GetMessageReadAggregateType<T extends MessageReadAggregateArgs> = {
        [P in keyof T & keyof AggregateMessageRead]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessageRead[P]>
      : GetScalarType<T[P], AggregateMessageRead[P]>
  }




  export type MessageReadGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageReadWhereInput
    orderBy?: MessageReadOrderByWithAggregationInput | MessageReadOrderByWithAggregationInput[]
    by: MessageReadScalarFieldEnum[] | MessageReadScalarFieldEnum
    having?: MessageReadScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageReadCountAggregateInputType | true
    _min?: MessageReadMinAggregateInputType
    _max?: MessageReadMaxAggregateInputType
  }

  export type MessageReadGroupByOutputType = {
    id: string
    messageId: string
    userId: string
    readAt: Date
    _count: MessageReadCountAggregateOutputType | null
    _min: MessageReadMinAggregateOutputType | null
    _max: MessageReadMaxAggregateOutputType | null
  }

  type GetMessageReadGroupByPayload<T extends MessageReadGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageReadGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageReadGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageReadGroupByOutputType[P]>
            : GetScalarType<T[P], MessageReadGroupByOutputType[P]>
        }
      >
    >


  export type MessageReadSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    messageId?: boolean
    userId?: boolean
    readAt?: boolean
    message?: boolean | MessageDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["messageRead"]>

  export type MessageReadSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    messageId?: boolean
    userId?: boolean
    readAt?: boolean
    message?: boolean | MessageDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["messageRead"]>

  export type MessageReadSelectScalar = {
    id?: boolean
    messageId?: boolean
    userId?: boolean
    readAt?: boolean
  }

  export type MessageReadInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    message?: boolean | MessageDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MessageReadIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    message?: boolean | MessageDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MessageReadPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MessageRead"
    objects: {
      message: Prisma.$MessagePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      messageId: string
      userId: string
      readAt: Date
    }, ExtArgs["result"]["messageRead"]>
    composites: {}
  }

  type MessageReadGetPayload<S extends boolean | null | undefined | MessageReadDefaultArgs> = $Result.GetResult<Prisma.$MessageReadPayload, S>

  type MessageReadCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MessageReadFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MessageReadCountAggregateInputType | true
    }

  export interface MessageReadDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MessageRead'], meta: { name: 'MessageRead' } }
    /**
     * Find zero or one MessageRead that matches the filter.
     * @param {MessageReadFindUniqueArgs} args - Arguments to find a MessageRead
     * @example
     * // Get one MessageRead
     * const messageRead = await prisma.messageRead.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageReadFindUniqueArgs>(args: SelectSubset<T, MessageReadFindUniqueArgs<ExtArgs>>): Prisma__MessageReadClient<$Result.GetResult<Prisma.$MessageReadPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MessageRead that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MessageReadFindUniqueOrThrowArgs} args - Arguments to find a MessageRead
     * @example
     * // Get one MessageRead
     * const messageRead = await prisma.messageRead.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageReadFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageReadFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageReadClient<$Result.GetResult<Prisma.$MessageReadPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MessageRead that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageReadFindFirstArgs} args - Arguments to find a MessageRead
     * @example
     * // Get one MessageRead
     * const messageRead = await prisma.messageRead.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageReadFindFirstArgs>(args?: SelectSubset<T, MessageReadFindFirstArgs<ExtArgs>>): Prisma__MessageReadClient<$Result.GetResult<Prisma.$MessageReadPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MessageRead that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageReadFindFirstOrThrowArgs} args - Arguments to find a MessageRead
     * @example
     * // Get one MessageRead
     * const messageRead = await prisma.messageRead.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageReadFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageReadFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageReadClient<$Result.GetResult<Prisma.$MessageReadPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MessageReads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageReadFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MessageReads
     * const messageReads = await prisma.messageRead.findMany()
     * 
     * // Get first 10 MessageReads
     * const messageReads = await prisma.messageRead.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageReadWithIdOnly = await prisma.messageRead.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageReadFindManyArgs>(args?: SelectSubset<T, MessageReadFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageReadPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MessageRead.
     * @param {MessageReadCreateArgs} args - Arguments to create a MessageRead.
     * @example
     * // Create one MessageRead
     * const MessageRead = await prisma.messageRead.create({
     *   data: {
     *     // ... data to create a MessageRead
     *   }
     * })
     * 
     */
    create<T extends MessageReadCreateArgs>(args: SelectSubset<T, MessageReadCreateArgs<ExtArgs>>): Prisma__MessageReadClient<$Result.GetResult<Prisma.$MessageReadPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MessageReads.
     * @param {MessageReadCreateManyArgs} args - Arguments to create many MessageReads.
     * @example
     * // Create many MessageReads
     * const messageRead = await prisma.messageRead.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageReadCreateManyArgs>(args?: SelectSubset<T, MessageReadCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MessageReads and returns the data saved in the database.
     * @param {MessageReadCreateManyAndReturnArgs} args - Arguments to create many MessageReads.
     * @example
     * // Create many MessageReads
     * const messageRead = await prisma.messageRead.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MessageReads and only return the `id`
     * const messageReadWithIdOnly = await prisma.messageRead.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MessageReadCreateManyAndReturnArgs>(args?: SelectSubset<T, MessageReadCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageReadPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MessageRead.
     * @param {MessageReadDeleteArgs} args - Arguments to delete one MessageRead.
     * @example
     * // Delete one MessageRead
     * const MessageRead = await prisma.messageRead.delete({
     *   where: {
     *     // ... filter to delete one MessageRead
     *   }
     * })
     * 
     */
    delete<T extends MessageReadDeleteArgs>(args: SelectSubset<T, MessageReadDeleteArgs<ExtArgs>>): Prisma__MessageReadClient<$Result.GetResult<Prisma.$MessageReadPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MessageRead.
     * @param {MessageReadUpdateArgs} args - Arguments to update one MessageRead.
     * @example
     * // Update one MessageRead
     * const messageRead = await prisma.messageRead.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageReadUpdateArgs>(args: SelectSubset<T, MessageReadUpdateArgs<ExtArgs>>): Prisma__MessageReadClient<$Result.GetResult<Prisma.$MessageReadPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MessageReads.
     * @param {MessageReadDeleteManyArgs} args - Arguments to filter MessageReads to delete.
     * @example
     * // Delete a few MessageReads
     * const { count } = await prisma.messageRead.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageReadDeleteManyArgs>(args?: SelectSubset<T, MessageReadDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MessageReads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageReadUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MessageReads
     * const messageRead = await prisma.messageRead.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageReadUpdateManyArgs>(args: SelectSubset<T, MessageReadUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MessageRead.
     * @param {MessageReadUpsertArgs} args - Arguments to update or create a MessageRead.
     * @example
     * // Update or create a MessageRead
     * const messageRead = await prisma.messageRead.upsert({
     *   create: {
     *     // ... data to create a MessageRead
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MessageRead we want to update
     *   }
     * })
     */
    upsert<T extends MessageReadUpsertArgs>(args: SelectSubset<T, MessageReadUpsertArgs<ExtArgs>>): Prisma__MessageReadClient<$Result.GetResult<Prisma.$MessageReadPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MessageReads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageReadCountArgs} args - Arguments to filter MessageReads to count.
     * @example
     * // Count the number of MessageReads
     * const count = await prisma.messageRead.count({
     *   where: {
     *     // ... the filter for the MessageReads we want to count
     *   }
     * })
    **/
    count<T extends MessageReadCountArgs>(
      args?: Subset<T, MessageReadCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageReadCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MessageRead.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageReadAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageReadAggregateArgs>(args: Subset<T, MessageReadAggregateArgs>): Prisma.PrismaPromise<GetMessageReadAggregateType<T>>

    /**
     * Group by MessageRead.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageReadGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageReadGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageReadGroupByArgs['orderBy'] }
        : { orderBy?: MessageReadGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageReadGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageReadGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MessageRead model
   */
  readonly fields: MessageReadFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MessageRead.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageReadClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    message<T extends MessageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MessageDefaultArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MessageRead model
   */ 
  interface MessageReadFieldRefs {
    readonly id: FieldRef<"MessageRead", 'String'>
    readonly messageId: FieldRef<"MessageRead", 'String'>
    readonly userId: FieldRef<"MessageRead", 'String'>
    readonly readAt: FieldRef<"MessageRead", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MessageRead findUnique
   */
  export type MessageReadFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageRead
     */
    select?: MessageReadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageReadInclude<ExtArgs> | null
    /**
     * Filter, which MessageRead to fetch.
     */
    where: MessageReadWhereUniqueInput
  }

  /**
   * MessageRead findUniqueOrThrow
   */
  export type MessageReadFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageRead
     */
    select?: MessageReadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageReadInclude<ExtArgs> | null
    /**
     * Filter, which MessageRead to fetch.
     */
    where: MessageReadWhereUniqueInput
  }

  /**
   * MessageRead findFirst
   */
  export type MessageReadFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageRead
     */
    select?: MessageReadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageReadInclude<ExtArgs> | null
    /**
     * Filter, which MessageRead to fetch.
     */
    where?: MessageReadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageReads to fetch.
     */
    orderBy?: MessageReadOrderByWithRelationInput | MessageReadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MessageReads.
     */
    cursor?: MessageReadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageReads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageReads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MessageReads.
     */
    distinct?: MessageReadScalarFieldEnum | MessageReadScalarFieldEnum[]
  }

  /**
   * MessageRead findFirstOrThrow
   */
  export type MessageReadFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageRead
     */
    select?: MessageReadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageReadInclude<ExtArgs> | null
    /**
     * Filter, which MessageRead to fetch.
     */
    where?: MessageReadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageReads to fetch.
     */
    orderBy?: MessageReadOrderByWithRelationInput | MessageReadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MessageReads.
     */
    cursor?: MessageReadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageReads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageReads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MessageReads.
     */
    distinct?: MessageReadScalarFieldEnum | MessageReadScalarFieldEnum[]
  }

  /**
   * MessageRead findMany
   */
  export type MessageReadFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageRead
     */
    select?: MessageReadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageReadInclude<ExtArgs> | null
    /**
     * Filter, which MessageReads to fetch.
     */
    where?: MessageReadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageReads to fetch.
     */
    orderBy?: MessageReadOrderByWithRelationInput | MessageReadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MessageReads.
     */
    cursor?: MessageReadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageReads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageReads.
     */
    skip?: number
    distinct?: MessageReadScalarFieldEnum | MessageReadScalarFieldEnum[]
  }

  /**
   * MessageRead create
   */
  export type MessageReadCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageRead
     */
    select?: MessageReadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageReadInclude<ExtArgs> | null
    /**
     * The data needed to create a MessageRead.
     */
    data: XOR<MessageReadCreateInput, MessageReadUncheckedCreateInput>
  }

  /**
   * MessageRead createMany
   */
  export type MessageReadCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MessageReads.
     */
    data: MessageReadCreateManyInput | MessageReadCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MessageRead createManyAndReturn
   */
  export type MessageReadCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageRead
     */
    select?: MessageReadSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MessageReads.
     */
    data: MessageReadCreateManyInput | MessageReadCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageReadIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MessageRead update
   */
  export type MessageReadUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageRead
     */
    select?: MessageReadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageReadInclude<ExtArgs> | null
    /**
     * The data needed to update a MessageRead.
     */
    data: XOR<MessageReadUpdateInput, MessageReadUncheckedUpdateInput>
    /**
     * Choose, which MessageRead to update.
     */
    where: MessageReadWhereUniqueInput
  }

  /**
   * MessageRead updateMany
   */
  export type MessageReadUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MessageReads.
     */
    data: XOR<MessageReadUpdateManyMutationInput, MessageReadUncheckedUpdateManyInput>
    /**
     * Filter which MessageReads to update
     */
    where?: MessageReadWhereInput
  }

  /**
   * MessageRead upsert
   */
  export type MessageReadUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageRead
     */
    select?: MessageReadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageReadInclude<ExtArgs> | null
    /**
     * The filter to search for the MessageRead to update in case it exists.
     */
    where: MessageReadWhereUniqueInput
    /**
     * In case the MessageRead found by the `where` argument doesn't exist, create a new MessageRead with this data.
     */
    create: XOR<MessageReadCreateInput, MessageReadUncheckedCreateInput>
    /**
     * In case the MessageRead was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageReadUpdateInput, MessageReadUncheckedUpdateInput>
  }

  /**
   * MessageRead delete
   */
  export type MessageReadDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageRead
     */
    select?: MessageReadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageReadInclude<ExtArgs> | null
    /**
     * Filter which MessageRead to delete.
     */
    where: MessageReadWhereUniqueInput
  }

  /**
   * MessageRead deleteMany
   */
  export type MessageReadDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MessageReads to delete
     */
    where?: MessageReadWhereInput
  }

  /**
   * MessageRead without action
   */
  export type MessageReadDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageRead
     */
    select?: MessageReadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageReadInclude<ExtArgs> | null
  }


  /**
   * Model Chore
   */

  export type AggregateChore = {
    _count: ChoreCountAggregateOutputType | null
    _avg: ChoreAvgAggregateOutputType | null
    _sum: ChoreSumAggregateOutputType | null
    _min: ChoreMinAggregateOutputType | null
    _max: ChoreMaxAggregateOutputType | null
  }

  export type ChoreAvgAggregateOutputType = {
    priority: number | null
  }

  export type ChoreSumAggregateOutputType = {
    priority: number | null
  }

  export type ChoreMinAggregateOutputType = {
    id: string | null
    householdId: string | null
    title: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    dueDate: Date | null
    status: $Enums.ChoreStatus | null
    priority: number | null
    eventId: string | null
    recurrenceRuleId: string | null
    deletedAt: Date | null
  }

  export type ChoreMaxAggregateOutputType = {
    id: string | null
    householdId: string | null
    title: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    dueDate: Date | null
    status: $Enums.ChoreStatus | null
    priority: number | null
    eventId: string | null
    recurrenceRuleId: string | null
    deletedAt: Date | null
  }

  export type ChoreCountAggregateOutputType = {
    id: number
    householdId: number
    title: number
    description: number
    createdAt: number
    updatedAt: number
    dueDate: number
    status: number
    priority: number
    eventId: number
    recurrenceRuleId: number
    deletedAt: number
    _all: number
  }


  export type ChoreAvgAggregateInputType = {
    priority?: true
  }

  export type ChoreSumAggregateInputType = {
    priority?: true
  }

  export type ChoreMinAggregateInputType = {
    id?: true
    householdId?: true
    title?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    dueDate?: true
    status?: true
    priority?: true
    eventId?: true
    recurrenceRuleId?: true
    deletedAt?: true
  }

  export type ChoreMaxAggregateInputType = {
    id?: true
    householdId?: true
    title?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    dueDate?: true
    status?: true
    priority?: true
    eventId?: true
    recurrenceRuleId?: true
    deletedAt?: true
  }

  export type ChoreCountAggregateInputType = {
    id?: true
    householdId?: true
    title?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    dueDate?: true
    status?: true
    priority?: true
    eventId?: true
    recurrenceRuleId?: true
    deletedAt?: true
    _all?: true
  }

  export type ChoreAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Chore to aggregate.
     */
    where?: ChoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chores to fetch.
     */
    orderBy?: ChoreOrderByWithRelationInput | ChoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Chores
    **/
    _count?: true | ChoreCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChoreAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChoreSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChoreMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChoreMaxAggregateInputType
  }

  export type GetChoreAggregateType<T extends ChoreAggregateArgs> = {
        [P in keyof T & keyof AggregateChore]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChore[P]>
      : GetScalarType<T[P], AggregateChore[P]>
  }




  export type ChoreGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChoreWhereInput
    orderBy?: ChoreOrderByWithAggregationInput | ChoreOrderByWithAggregationInput[]
    by: ChoreScalarFieldEnum[] | ChoreScalarFieldEnum
    having?: ChoreScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChoreCountAggregateInputType | true
    _avg?: ChoreAvgAggregateInputType
    _sum?: ChoreSumAggregateInputType
    _min?: ChoreMinAggregateInputType
    _max?: ChoreMaxAggregateInputType
  }

  export type ChoreGroupByOutputType = {
    id: string
    householdId: string
    title: string
    description: string | null
    createdAt: Date
    updatedAt: Date
    dueDate: Date | null
    status: $Enums.ChoreStatus
    priority: number | null
    eventId: string | null
    recurrenceRuleId: string | null
    deletedAt: Date | null
    _count: ChoreCountAggregateOutputType | null
    _avg: ChoreAvgAggregateOutputType | null
    _sum: ChoreSumAggregateOutputType | null
    _min: ChoreMinAggregateOutputType | null
    _max: ChoreMaxAggregateOutputType | null
  }

  type GetChoreGroupByPayload<T extends ChoreGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChoreGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChoreGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChoreGroupByOutputType[P]>
            : GetScalarType<T[P], ChoreGroupByOutputType[P]>
        }
      >
    >


  export type ChoreSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    householdId?: boolean
    title?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    dueDate?: boolean
    status?: boolean
    priority?: boolean
    eventId?: boolean
    recurrenceRuleId?: boolean
    deletedAt?: boolean
    household?: boolean | HouseholdDefaultArgs<ExtArgs>
    subtasks?: boolean | Chore$subtasksArgs<ExtArgs>
    assignedUsers?: boolean | Chore$assignedUsersArgs<ExtArgs>
    event?: boolean | Chore$eventArgs<ExtArgs>
    choreSwapRequests?: boolean | Chore$choreSwapRequestsArgs<ExtArgs>
    recurrenceRule?: boolean | Chore$recurrenceRuleArgs<ExtArgs>
    history?: boolean | Chore$historyArgs<ExtArgs>
    _count?: boolean | ChoreCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chore"]>

  export type ChoreSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    householdId?: boolean
    title?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    dueDate?: boolean
    status?: boolean
    priority?: boolean
    eventId?: boolean
    recurrenceRuleId?: boolean
    deletedAt?: boolean
    household?: boolean | HouseholdDefaultArgs<ExtArgs>
    event?: boolean | Chore$eventArgs<ExtArgs>
    recurrenceRule?: boolean | Chore$recurrenceRuleArgs<ExtArgs>
  }, ExtArgs["result"]["chore"]>

  export type ChoreSelectScalar = {
    id?: boolean
    householdId?: boolean
    title?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    dueDate?: boolean
    status?: boolean
    priority?: boolean
    eventId?: boolean
    recurrenceRuleId?: boolean
    deletedAt?: boolean
  }

  export type ChoreInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    household?: boolean | HouseholdDefaultArgs<ExtArgs>
    subtasks?: boolean | Chore$subtasksArgs<ExtArgs>
    assignedUsers?: boolean | Chore$assignedUsersArgs<ExtArgs>
    event?: boolean | Chore$eventArgs<ExtArgs>
    choreSwapRequests?: boolean | Chore$choreSwapRequestsArgs<ExtArgs>
    recurrenceRule?: boolean | Chore$recurrenceRuleArgs<ExtArgs>
    history?: boolean | Chore$historyArgs<ExtArgs>
    _count?: boolean | ChoreCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ChoreIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    household?: boolean | HouseholdDefaultArgs<ExtArgs>
    event?: boolean | Chore$eventArgs<ExtArgs>
    recurrenceRule?: boolean | Chore$recurrenceRuleArgs<ExtArgs>
  }

  export type $ChorePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Chore"
    objects: {
      household: Prisma.$HouseholdPayload<ExtArgs>
      subtasks: Prisma.$SubtaskPayload<ExtArgs>[]
      assignedUsers: Prisma.$ChoreAssignmentPayload<ExtArgs>[]
      event: Prisma.$EventPayload<ExtArgs> | null
      choreSwapRequests: Prisma.$ChoreSwapRequestPayload<ExtArgs>[]
      recurrenceRule: Prisma.$RecurrenceRulePayload<ExtArgs> | null
      history: Prisma.$ChoreHistoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      householdId: string
      title: string
      description: string | null
      createdAt: Date
      updatedAt: Date
      dueDate: Date | null
      status: $Enums.ChoreStatus
      priority: number | null
      eventId: string | null
      recurrenceRuleId: string | null
      deletedAt: Date | null
    }, ExtArgs["result"]["chore"]>
    composites: {}
  }

  type ChoreGetPayload<S extends boolean | null | undefined | ChoreDefaultArgs> = $Result.GetResult<Prisma.$ChorePayload, S>

  type ChoreCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ChoreFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ChoreCountAggregateInputType | true
    }

  export interface ChoreDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Chore'], meta: { name: 'Chore' } }
    /**
     * Find zero or one Chore that matches the filter.
     * @param {ChoreFindUniqueArgs} args - Arguments to find a Chore
     * @example
     * // Get one Chore
     * const chore = await prisma.chore.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChoreFindUniqueArgs>(args: SelectSubset<T, ChoreFindUniqueArgs<ExtArgs>>): Prisma__ChoreClient<$Result.GetResult<Prisma.$ChorePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Chore that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ChoreFindUniqueOrThrowArgs} args - Arguments to find a Chore
     * @example
     * // Get one Chore
     * const chore = await prisma.chore.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChoreFindUniqueOrThrowArgs>(args: SelectSubset<T, ChoreFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChoreClient<$Result.GetResult<Prisma.$ChorePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Chore that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChoreFindFirstArgs} args - Arguments to find a Chore
     * @example
     * // Get one Chore
     * const chore = await prisma.chore.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChoreFindFirstArgs>(args?: SelectSubset<T, ChoreFindFirstArgs<ExtArgs>>): Prisma__ChoreClient<$Result.GetResult<Prisma.$ChorePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Chore that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChoreFindFirstOrThrowArgs} args - Arguments to find a Chore
     * @example
     * // Get one Chore
     * const chore = await prisma.chore.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChoreFindFirstOrThrowArgs>(args?: SelectSubset<T, ChoreFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChoreClient<$Result.GetResult<Prisma.$ChorePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Chores that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChoreFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Chores
     * const chores = await prisma.chore.findMany()
     * 
     * // Get first 10 Chores
     * const chores = await prisma.chore.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const choreWithIdOnly = await prisma.chore.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChoreFindManyArgs>(args?: SelectSubset<T, ChoreFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChorePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Chore.
     * @param {ChoreCreateArgs} args - Arguments to create a Chore.
     * @example
     * // Create one Chore
     * const Chore = await prisma.chore.create({
     *   data: {
     *     // ... data to create a Chore
     *   }
     * })
     * 
     */
    create<T extends ChoreCreateArgs>(args: SelectSubset<T, ChoreCreateArgs<ExtArgs>>): Prisma__ChoreClient<$Result.GetResult<Prisma.$ChorePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Chores.
     * @param {ChoreCreateManyArgs} args - Arguments to create many Chores.
     * @example
     * // Create many Chores
     * const chore = await prisma.chore.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChoreCreateManyArgs>(args?: SelectSubset<T, ChoreCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Chores and returns the data saved in the database.
     * @param {ChoreCreateManyAndReturnArgs} args - Arguments to create many Chores.
     * @example
     * // Create many Chores
     * const chore = await prisma.chore.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Chores and only return the `id`
     * const choreWithIdOnly = await prisma.chore.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChoreCreateManyAndReturnArgs>(args?: SelectSubset<T, ChoreCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChorePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Chore.
     * @param {ChoreDeleteArgs} args - Arguments to delete one Chore.
     * @example
     * // Delete one Chore
     * const Chore = await prisma.chore.delete({
     *   where: {
     *     // ... filter to delete one Chore
     *   }
     * })
     * 
     */
    delete<T extends ChoreDeleteArgs>(args: SelectSubset<T, ChoreDeleteArgs<ExtArgs>>): Prisma__ChoreClient<$Result.GetResult<Prisma.$ChorePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Chore.
     * @param {ChoreUpdateArgs} args - Arguments to update one Chore.
     * @example
     * // Update one Chore
     * const chore = await prisma.chore.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChoreUpdateArgs>(args: SelectSubset<T, ChoreUpdateArgs<ExtArgs>>): Prisma__ChoreClient<$Result.GetResult<Prisma.$ChorePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Chores.
     * @param {ChoreDeleteManyArgs} args - Arguments to filter Chores to delete.
     * @example
     * // Delete a few Chores
     * const { count } = await prisma.chore.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChoreDeleteManyArgs>(args?: SelectSubset<T, ChoreDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChoreUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Chores
     * const chore = await prisma.chore.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChoreUpdateManyArgs>(args: SelectSubset<T, ChoreUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Chore.
     * @param {ChoreUpsertArgs} args - Arguments to update or create a Chore.
     * @example
     * // Update or create a Chore
     * const chore = await prisma.chore.upsert({
     *   create: {
     *     // ... data to create a Chore
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Chore we want to update
     *   }
     * })
     */
    upsert<T extends ChoreUpsertArgs>(args: SelectSubset<T, ChoreUpsertArgs<ExtArgs>>): Prisma__ChoreClient<$Result.GetResult<Prisma.$ChorePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Chores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChoreCountArgs} args - Arguments to filter Chores to count.
     * @example
     * // Count the number of Chores
     * const count = await prisma.chore.count({
     *   where: {
     *     // ... the filter for the Chores we want to count
     *   }
     * })
    **/
    count<T extends ChoreCountArgs>(
      args?: Subset<T, ChoreCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChoreCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Chore.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChoreAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChoreAggregateArgs>(args: Subset<T, ChoreAggregateArgs>): Prisma.PrismaPromise<GetChoreAggregateType<T>>

    /**
     * Group by Chore.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChoreGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChoreGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChoreGroupByArgs['orderBy'] }
        : { orderBy?: ChoreGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChoreGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChoreGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Chore model
   */
  readonly fields: ChoreFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Chore.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChoreClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    household<T extends HouseholdDefaultArgs<ExtArgs> = {}>(args?: Subset<T, HouseholdDefaultArgs<ExtArgs>>): Prisma__HouseholdClient<$Result.GetResult<Prisma.$HouseholdPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    subtasks<T extends Chore$subtasksArgs<ExtArgs> = {}>(args?: Subset<T, Chore$subtasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubtaskPayload<ExtArgs>, T, "findMany"> | Null>
    assignedUsers<T extends Chore$assignedUsersArgs<ExtArgs> = {}>(args?: Subset<T, Chore$assignedUsersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChoreAssignmentPayload<ExtArgs>, T, "findMany"> | Null>
    event<T extends Chore$eventArgs<ExtArgs> = {}>(args?: Subset<T, Chore$eventArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    choreSwapRequests<T extends Chore$choreSwapRequestsArgs<ExtArgs> = {}>(args?: Subset<T, Chore$choreSwapRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChoreSwapRequestPayload<ExtArgs>, T, "findMany"> | Null>
    recurrenceRule<T extends Chore$recurrenceRuleArgs<ExtArgs> = {}>(args?: Subset<T, Chore$recurrenceRuleArgs<ExtArgs>>): Prisma__RecurrenceRuleClient<$Result.GetResult<Prisma.$RecurrenceRulePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    history<T extends Chore$historyArgs<ExtArgs> = {}>(args?: Subset<T, Chore$historyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChoreHistoryPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Chore model
   */ 
  interface ChoreFieldRefs {
    readonly id: FieldRef<"Chore", 'String'>
    readonly householdId: FieldRef<"Chore", 'String'>
    readonly title: FieldRef<"Chore", 'String'>
    readonly description: FieldRef<"Chore", 'String'>
    readonly createdAt: FieldRef<"Chore", 'DateTime'>
    readonly updatedAt: FieldRef<"Chore", 'DateTime'>
    readonly dueDate: FieldRef<"Chore", 'DateTime'>
    readonly status: FieldRef<"Chore", 'ChoreStatus'>
    readonly priority: FieldRef<"Chore", 'Int'>
    readonly eventId: FieldRef<"Chore", 'String'>
    readonly recurrenceRuleId: FieldRef<"Chore", 'String'>
    readonly deletedAt: FieldRef<"Chore", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Chore findUnique
   */
  export type ChoreFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chore
     */
    select?: ChoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChoreInclude<ExtArgs> | null
    /**
     * Filter, which Chore to fetch.
     */
    where: ChoreWhereUniqueInput
  }

  /**
   * Chore findUniqueOrThrow
   */
  export type ChoreFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chore
     */
    select?: ChoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChoreInclude<ExtArgs> | null
    /**
     * Filter, which Chore to fetch.
     */
    where: ChoreWhereUniqueInput
  }

  /**
   * Chore findFirst
   */
  export type ChoreFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chore
     */
    select?: ChoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChoreInclude<ExtArgs> | null
    /**
     * Filter, which Chore to fetch.
     */
    where?: ChoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chores to fetch.
     */
    orderBy?: ChoreOrderByWithRelationInput | ChoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Chores.
     */
    cursor?: ChoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Chores.
     */
    distinct?: ChoreScalarFieldEnum | ChoreScalarFieldEnum[]
  }

  /**
   * Chore findFirstOrThrow
   */
  export type ChoreFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chore
     */
    select?: ChoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChoreInclude<ExtArgs> | null
    /**
     * Filter, which Chore to fetch.
     */
    where?: ChoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chores to fetch.
     */
    orderBy?: ChoreOrderByWithRelationInput | ChoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Chores.
     */
    cursor?: ChoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Chores.
     */
    distinct?: ChoreScalarFieldEnum | ChoreScalarFieldEnum[]
  }

  /**
   * Chore findMany
   */
  export type ChoreFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chore
     */
    select?: ChoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChoreInclude<ExtArgs> | null
    /**
     * Filter, which Chores to fetch.
     */
    where?: ChoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chores to fetch.
     */
    orderBy?: ChoreOrderByWithRelationInput | ChoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Chores.
     */
    cursor?: ChoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chores.
     */
    skip?: number
    distinct?: ChoreScalarFieldEnum | ChoreScalarFieldEnum[]
  }

  /**
   * Chore create
   */
  export type ChoreCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chore
     */
    select?: ChoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChoreInclude<ExtArgs> | null
    /**
     * The data needed to create a Chore.
     */
    data: XOR<ChoreCreateInput, ChoreUncheckedCreateInput>
  }

  /**
   * Chore createMany
   */
  export type ChoreCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Chores.
     */
    data: ChoreCreateManyInput | ChoreCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Chore createManyAndReturn
   */
  export type ChoreCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chore
     */
    select?: ChoreSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Chores.
     */
    data: ChoreCreateManyInput | ChoreCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChoreIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Chore update
   */
  export type ChoreUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chore
     */
    select?: ChoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChoreInclude<ExtArgs> | null
    /**
     * The data needed to update a Chore.
     */
    data: XOR<ChoreUpdateInput, ChoreUncheckedUpdateInput>
    /**
     * Choose, which Chore to update.
     */
    where: ChoreWhereUniqueInput
  }

  /**
   * Chore updateMany
   */
  export type ChoreUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Chores.
     */
    data: XOR<ChoreUpdateManyMutationInput, ChoreUncheckedUpdateManyInput>
    /**
     * Filter which Chores to update
     */
    where?: ChoreWhereInput
  }

  /**
   * Chore upsert
   */
  export type ChoreUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chore
     */
    select?: ChoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChoreInclude<ExtArgs> | null
    /**
     * The filter to search for the Chore to update in case it exists.
     */
    where: ChoreWhereUniqueInput
    /**
     * In case the Chore found by the `where` argument doesn't exist, create a new Chore with this data.
     */
    create: XOR<ChoreCreateInput, ChoreUncheckedCreateInput>
    /**
     * In case the Chore was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChoreUpdateInput, ChoreUncheckedUpdateInput>
  }

  /**
   * Chore delete
   */
  export type ChoreDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chore
     */
    select?: ChoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChoreInclude<ExtArgs> | null
    /**
     * Filter which Chore to delete.
     */
    where: ChoreWhereUniqueInput
  }

  /**
   * Chore deleteMany
   */
  export type ChoreDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Chores to delete
     */
    where?: ChoreWhereInput
  }

  /**
   * Chore.subtasks
   */
  export type Chore$subtasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subtask
     */
    select?: SubtaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtaskInclude<ExtArgs> | null
    where?: SubtaskWhereInput
    orderBy?: SubtaskOrderByWithRelationInput | SubtaskOrderByWithRelationInput[]
    cursor?: SubtaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubtaskScalarFieldEnum | SubtaskScalarFieldEnum[]
  }

  /**
   * Chore.assignedUsers
   */
  export type Chore$assignedUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChoreAssignment
     */
    select?: ChoreAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChoreAssignmentInclude<ExtArgs> | null
    where?: ChoreAssignmentWhereInput
    orderBy?: ChoreAssignmentOrderByWithRelationInput | ChoreAssignmentOrderByWithRelationInput[]
    cursor?: ChoreAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChoreAssignmentScalarFieldEnum | ChoreAssignmentScalarFieldEnum[]
  }

  /**
   * Chore.event
   */
  export type Chore$eventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    where?: EventWhereInput
  }

  /**
   * Chore.choreSwapRequests
   */
  export type Chore$choreSwapRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChoreSwapRequest
     */
    select?: ChoreSwapRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChoreSwapRequestInclude<ExtArgs> | null
    where?: ChoreSwapRequestWhereInput
    orderBy?: ChoreSwapRequestOrderByWithRelationInput | ChoreSwapRequestOrderByWithRelationInput[]
    cursor?: ChoreSwapRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChoreSwapRequestScalarFieldEnum | ChoreSwapRequestScalarFieldEnum[]
  }

  /**
   * Chore.recurrenceRule
   */
  export type Chore$recurrenceRuleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurrenceRule
     */
    select?: RecurrenceRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurrenceRuleInclude<ExtArgs> | null
    where?: RecurrenceRuleWhereInput
  }

  /**
   * Chore.history
   */
  export type Chore$historyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChoreHistory
     */
    select?: ChoreHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChoreHistoryInclude<ExtArgs> | null
    where?: ChoreHistoryWhereInput
    orderBy?: ChoreHistoryOrderByWithRelationInput | ChoreHistoryOrderByWithRelationInput[]
    cursor?: ChoreHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChoreHistoryScalarFieldEnum | ChoreHistoryScalarFieldEnum[]
  }

  /**
   * Chore without action
   */
  export type ChoreDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chore
     */
    select?: ChoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChoreInclude<ExtArgs> | null
  }


  /**
   * Model Subtask
   */

  export type AggregateSubtask = {
    _count: SubtaskCountAggregateOutputType | null
    _min: SubtaskMinAggregateOutputType | null
    _max: SubtaskMaxAggregateOutputType | null
  }

  export type SubtaskMinAggregateOutputType = {
    id: string | null
    choreId: string | null
    title: string | null
    description: string | null
    status: $Enums.SubtaskStatus | null
  }

  export type SubtaskMaxAggregateOutputType = {
    id: string | null
    choreId: string | null
    title: string | null
    description: string | null
    status: $Enums.SubtaskStatus | null
  }

  export type SubtaskCountAggregateOutputType = {
    id: number
    choreId: number
    title: number
    description: number
    status: number
    _all: number
  }


  export type SubtaskMinAggregateInputType = {
    id?: true
    choreId?: true
    title?: true
    description?: true
    status?: true
  }

  export type SubtaskMaxAggregateInputType = {
    id?: true
    choreId?: true
    title?: true
    description?: true
    status?: true
  }

  export type SubtaskCountAggregateInputType = {
    id?: true
    choreId?: true
    title?: true
    description?: true
    status?: true
    _all?: true
  }

  export type SubtaskAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subtask to aggregate.
     */
    where?: SubtaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subtasks to fetch.
     */
    orderBy?: SubtaskOrderByWithRelationInput | SubtaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubtaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subtasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subtasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Subtasks
    **/
    _count?: true | SubtaskCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubtaskMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubtaskMaxAggregateInputType
  }

  export type GetSubtaskAggregateType<T extends SubtaskAggregateArgs> = {
        [P in keyof T & keyof AggregateSubtask]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubtask[P]>
      : GetScalarType<T[P], AggregateSubtask[P]>
  }




  export type SubtaskGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubtaskWhereInput
    orderBy?: SubtaskOrderByWithAggregationInput | SubtaskOrderByWithAggregationInput[]
    by: SubtaskScalarFieldEnum[] | SubtaskScalarFieldEnum
    having?: SubtaskScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubtaskCountAggregateInputType | true
    _min?: SubtaskMinAggregateInputType
    _max?: SubtaskMaxAggregateInputType
  }

  export type SubtaskGroupByOutputType = {
    id: string
    choreId: string
    title: string
    description: string | null
    status: $Enums.SubtaskStatus
    _count: SubtaskCountAggregateOutputType | null
    _min: SubtaskMinAggregateOutputType | null
    _max: SubtaskMaxAggregateOutputType | null
  }

  type GetSubtaskGroupByPayload<T extends SubtaskGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubtaskGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubtaskGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubtaskGroupByOutputType[P]>
            : GetScalarType<T[P], SubtaskGroupByOutputType[P]>
        }
      >
    >


  export type SubtaskSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    choreId?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    chore?: boolean | ChoreDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subtask"]>

  export type SubtaskSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    choreId?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    chore?: boolean | ChoreDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subtask"]>

  export type SubtaskSelectScalar = {
    id?: boolean
    choreId?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
  }

  export type SubtaskInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chore?: boolean | ChoreDefaultArgs<ExtArgs>
  }
  export type SubtaskIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chore?: boolean | ChoreDefaultArgs<ExtArgs>
  }

  export type $SubtaskPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Subtask"
    objects: {
      chore: Prisma.$ChorePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      choreId: string
      title: string
      description: string | null
      status: $Enums.SubtaskStatus
    }, ExtArgs["result"]["subtask"]>
    composites: {}
  }

  type SubtaskGetPayload<S extends boolean | null | undefined | SubtaskDefaultArgs> = $Result.GetResult<Prisma.$SubtaskPayload, S>

  type SubtaskCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SubtaskFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SubtaskCountAggregateInputType | true
    }

  export interface SubtaskDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Subtask'], meta: { name: 'Subtask' } }
    /**
     * Find zero or one Subtask that matches the filter.
     * @param {SubtaskFindUniqueArgs} args - Arguments to find a Subtask
     * @example
     * // Get one Subtask
     * const subtask = await prisma.subtask.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubtaskFindUniqueArgs>(args: SelectSubset<T, SubtaskFindUniqueArgs<ExtArgs>>): Prisma__SubtaskClient<$Result.GetResult<Prisma.$SubtaskPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Subtask that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SubtaskFindUniqueOrThrowArgs} args - Arguments to find a Subtask
     * @example
     * // Get one Subtask
     * const subtask = await prisma.subtask.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubtaskFindUniqueOrThrowArgs>(args: SelectSubset<T, SubtaskFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubtaskClient<$Result.GetResult<Prisma.$SubtaskPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Subtask that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubtaskFindFirstArgs} args - Arguments to find a Subtask
     * @example
     * // Get one Subtask
     * const subtask = await prisma.subtask.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubtaskFindFirstArgs>(args?: SelectSubset<T, SubtaskFindFirstArgs<ExtArgs>>): Prisma__SubtaskClient<$Result.GetResult<Prisma.$SubtaskPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Subtask that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubtaskFindFirstOrThrowArgs} args - Arguments to find a Subtask
     * @example
     * // Get one Subtask
     * const subtask = await prisma.subtask.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubtaskFindFirstOrThrowArgs>(args?: SelectSubset<T, SubtaskFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubtaskClient<$Result.GetResult<Prisma.$SubtaskPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Subtasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubtaskFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subtasks
     * const subtasks = await prisma.subtask.findMany()
     * 
     * // Get first 10 Subtasks
     * const subtasks = await prisma.subtask.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subtaskWithIdOnly = await prisma.subtask.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubtaskFindManyArgs>(args?: SelectSubset<T, SubtaskFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubtaskPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Subtask.
     * @param {SubtaskCreateArgs} args - Arguments to create a Subtask.
     * @example
     * // Create one Subtask
     * const Subtask = await prisma.subtask.create({
     *   data: {
     *     // ... data to create a Subtask
     *   }
     * })
     * 
     */
    create<T extends SubtaskCreateArgs>(args: SelectSubset<T, SubtaskCreateArgs<ExtArgs>>): Prisma__SubtaskClient<$Result.GetResult<Prisma.$SubtaskPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Subtasks.
     * @param {SubtaskCreateManyArgs} args - Arguments to create many Subtasks.
     * @example
     * // Create many Subtasks
     * const subtask = await prisma.subtask.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubtaskCreateManyArgs>(args?: SelectSubset<T, SubtaskCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Subtasks and returns the data saved in the database.
     * @param {SubtaskCreateManyAndReturnArgs} args - Arguments to create many Subtasks.
     * @example
     * // Create many Subtasks
     * const subtask = await prisma.subtask.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Subtasks and only return the `id`
     * const subtaskWithIdOnly = await prisma.subtask.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubtaskCreateManyAndReturnArgs>(args?: SelectSubset<T, SubtaskCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubtaskPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Subtask.
     * @param {SubtaskDeleteArgs} args - Arguments to delete one Subtask.
     * @example
     * // Delete one Subtask
     * const Subtask = await prisma.subtask.delete({
     *   where: {
     *     // ... filter to delete one Subtask
     *   }
     * })
     * 
     */
    delete<T extends SubtaskDeleteArgs>(args: SelectSubset<T, SubtaskDeleteArgs<ExtArgs>>): Prisma__SubtaskClient<$Result.GetResult<Prisma.$SubtaskPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Subtask.
     * @param {SubtaskUpdateArgs} args - Arguments to update one Subtask.
     * @example
     * // Update one Subtask
     * const subtask = await prisma.subtask.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubtaskUpdateArgs>(args: SelectSubset<T, SubtaskUpdateArgs<ExtArgs>>): Prisma__SubtaskClient<$Result.GetResult<Prisma.$SubtaskPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Subtasks.
     * @param {SubtaskDeleteManyArgs} args - Arguments to filter Subtasks to delete.
     * @example
     * // Delete a few Subtasks
     * const { count } = await prisma.subtask.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubtaskDeleteManyArgs>(args?: SelectSubset<T, SubtaskDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subtasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubtaskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subtasks
     * const subtask = await prisma.subtask.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubtaskUpdateManyArgs>(args: SelectSubset<T, SubtaskUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Subtask.
     * @param {SubtaskUpsertArgs} args - Arguments to update or create a Subtask.
     * @example
     * // Update or create a Subtask
     * const subtask = await prisma.subtask.upsert({
     *   create: {
     *     // ... data to create a Subtask
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subtask we want to update
     *   }
     * })
     */
    upsert<T extends SubtaskUpsertArgs>(args: SelectSubset<T, SubtaskUpsertArgs<ExtArgs>>): Prisma__SubtaskClient<$Result.GetResult<Prisma.$SubtaskPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Subtasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubtaskCountArgs} args - Arguments to filter Subtasks to count.
     * @example
     * // Count the number of Subtasks
     * const count = await prisma.subtask.count({
     *   where: {
     *     // ... the filter for the Subtasks we want to count
     *   }
     * })
    **/
    count<T extends SubtaskCountArgs>(
      args?: Subset<T, SubtaskCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubtaskCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subtask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubtaskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubtaskAggregateArgs>(args: Subset<T, SubtaskAggregateArgs>): Prisma.PrismaPromise<GetSubtaskAggregateType<T>>

    /**
     * Group by Subtask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubtaskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubtaskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubtaskGroupByArgs['orderBy'] }
        : { orderBy?: SubtaskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubtaskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubtaskGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Subtask model
   */
  readonly fields: SubtaskFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Subtask.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubtaskClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    chore<T extends ChoreDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChoreDefaultArgs<ExtArgs>>): Prisma__ChoreClient<$Result.GetResult<Prisma.$ChorePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Subtask model
   */ 
  interface SubtaskFieldRefs {
    readonly id: FieldRef<"Subtask", 'String'>
    readonly choreId: FieldRef<"Subtask", 'String'>
    readonly title: FieldRef<"Subtask", 'String'>
    readonly description: FieldRef<"Subtask", 'String'>
    readonly status: FieldRef<"Subtask", 'SubtaskStatus'>
  }
    

  // Custom InputTypes
  /**
   * Subtask findUnique
   */
  export type SubtaskFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subtask
     */
    select?: SubtaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtaskInclude<ExtArgs> | null
    /**
     * Filter, which Subtask to fetch.
     */
    where: SubtaskWhereUniqueInput
  }

  /**
   * Subtask findUniqueOrThrow
   */
  export type SubtaskFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subtask
     */
    select?: SubtaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtaskInclude<ExtArgs> | null
    /**
     * Filter, which Subtask to fetch.
     */
    where: SubtaskWhereUniqueInput
  }

  /**
   * Subtask findFirst
   */
  export type SubtaskFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subtask
     */
    select?: SubtaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtaskInclude<ExtArgs> | null
    /**
     * Filter, which Subtask to fetch.
     */
    where?: SubtaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subtasks to fetch.
     */
    orderBy?: SubtaskOrderByWithRelationInput | SubtaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subtasks.
     */
    cursor?: SubtaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subtasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subtasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subtasks.
     */
    distinct?: SubtaskScalarFieldEnum | SubtaskScalarFieldEnum[]
  }

  /**
   * Subtask findFirstOrThrow
   */
  export type SubtaskFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subtask
     */
    select?: SubtaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtaskInclude<ExtArgs> | null
    /**
     * Filter, which Subtask to fetch.
     */
    where?: SubtaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subtasks to fetch.
     */
    orderBy?: SubtaskOrderByWithRelationInput | SubtaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subtasks.
     */
    cursor?: SubtaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subtasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subtasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subtasks.
     */
    distinct?: SubtaskScalarFieldEnum | SubtaskScalarFieldEnum[]
  }

  /**
   * Subtask findMany
   */
  export type SubtaskFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subtask
     */
    select?: SubtaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtaskInclude<ExtArgs> | null
    /**
     * Filter, which Subtasks to fetch.
     */
    where?: SubtaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subtasks to fetch.
     */
    orderBy?: SubtaskOrderByWithRelationInput | SubtaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Subtasks.
     */
    cursor?: SubtaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subtasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subtasks.
     */
    skip?: number
    distinct?: SubtaskScalarFieldEnum | SubtaskScalarFieldEnum[]
  }

  /**
   * Subtask create
   */
  export type SubtaskCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subtask
     */
    select?: SubtaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtaskInclude<ExtArgs> | null
    /**
     * The data needed to create a Subtask.
     */
    data: XOR<SubtaskCreateInput, SubtaskUncheckedCreateInput>
  }

  /**
   * Subtask createMany
   */
  export type SubtaskCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Subtasks.
     */
    data: SubtaskCreateManyInput | SubtaskCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Subtask createManyAndReturn
   */
  export type SubtaskCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subtask
     */
    select?: SubtaskSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Subtasks.
     */
    data: SubtaskCreateManyInput | SubtaskCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtaskIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subtask update
   */
  export type SubtaskUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subtask
     */
    select?: SubtaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtaskInclude<ExtArgs> | null
    /**
     * The data needed to update a Subtask.
     */
    data: XOR<SubtaskUpdateInput, SubtaskUncheckedUpdateInput>
    /**
     * Choose, which Subtask to update.
     */
    where: SubtaskWhereUniqueInput
  }

  /**
   * Subtask updateMany
   */
  export type SubtaskUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Subtasks.
     */
    data: XOR<SubtaskUpdateManyMutationInput, SubtaskUncheckedUpdateManyInput>
    /**
     * Filter which Subtasks to update
     */
    where?: SubtaskWhereInput
  }

  /**
   * Subtask upsert
   */
  export type SubtaskUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subtask
     */
    select?: SubtaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtaskInclude<ExtArgs> | null
    /**
     * The filter to search for the Subtask to update in case it exists.
     */
    where: SubtaskWhereUniqueInput
    /**
     * In case the Subtask found by the `where` argument doesn't exist, create a new Subtask with this data.
     */
    create: XOR<SubtaskCreateInput, SubtaskUncheckedCreateInput>
    /**
     * In case the Subtask was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubtaskUpdateInput, SubtaskUncheckedUpdateInput>
  }

  /**
   * Subtask delete
   */
  export type SubtaskDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subtask
     */
    select?: SubtaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtaskInclude<ExtArgs> | null
    /**
     * Filter which Subtask to delete.
     */
    where: SubtaskWhereUniqueInput
  }

  /**
   * Subtask deleteMany
   */
  export type SubtaskDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subtasks to delete
     */
    where?: SubtaskWhereInput
  }

  /**
   * Subtask without action
   */
  export type SubtaskDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subtask
     */
    select?: SubtaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtaskInclude<ExtArgs> | null
  }


  /**
   * Model ChoreAssignment
   */

  export type AggregateChoreAssignment = {
    _count: ChoreAssignmentCountAggregateOutputType | null
    _min: ChoreAssignmentMinAggregateOutputType | null
    _max: ChoreAssignmentMaxAggregateOutputType | null
  }

  export type ChoreAssignmentMinAggregateOutputType = {
    id: string | null
    choreId: string | null
    userId: string | null
    assignedAt: Date | null
    completedAt: Date | null
  }

  export type ChoreAssignmentMaxAggregateOutputType = {
    id: string | null
    choreId: string | null
    userId: string | null
    assignedAt: Date | null
    completedAt: Date | null
  }

  export type ChoreAssignmentCountAggregateOutputType = {
    id: number
    choreId: number
    userId: number
    assignedAt: number
    completedAt: number
    _all: number
  }


  export type ChoreAssignmentMinAggregateInputType = {
    id?: true
    choreId?: true
    userId?: true
    assignedAt?: true
    completedAt?: true
  }

  export type ChoreAssignmentMaxAggregateInputType = {
    id?: true
    choreId?: true
    userId?: true
    assignedAt?: true
    completedAt?: true
  }

  export type ChoreAssignmentCountAggregateInputType = {
    id?: true
    choreId?: true
    userId?: true
    assignedAt?: true
    completedAt?: true
    _all?: true
  }

  export type ChoreAssignmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChoreAssignment to aggregate.
     */
    where?: ChoreAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChoreAssignments to fetch.
     */
    orderBy?: ChoreAssignmentOrderByWithRelationInput | ChoreAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChoreAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChoreAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChoreAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChoreAssignments
    **/
    _count?: true | ChoreAssignmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChoreAssignmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChoreAssignmentMaxAggregateInputType
  }

  export type GetChoreAssignmentAggregateType<T extends ChoreAssignmentAggregateArgs> = {
        [P in keyof T & keyof AggregateChoreAssignment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChoreAssignment[P]>
      : GetScalarType<T[P], AggregateChoreAssignment[P]>
  }




  export type ChoreAssignmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChoreAssignmentWhereInput
    orderBy?: ChoreAssignmentOrderByWithAggregationInput | ChoreAssignmentOrderByWithAggregationInput[]
    by: ChoreAssignmentScalarFieldEnum[] | ChoreAssignmentScalarFieldEnum
    having?: ChoreAssignmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChoreAssignmentCountAggregateInputType | true
    _min?: ChoreAssignmentMinAggregateInputType
    _max?: ChoreAssignmentMaxAggregateInputType
  }

  export type ChoreAssignmentGroupByOutputType = {
    id: string
    choreId: string
    userId: string
    assignedAt: Date
    completedAt: Date | null
    _count: ChoreAssignmentCountAggregateOutputType | null
    _min: ChoreAssignmentMinAggregateOutputType | null
    _max: ChoreAssignmentMaxAggregateOutputType | null
  }

  type GetChoreAssignmentGroupByPayload<T extends ChoreAssignmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChoreAssignmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChoreAssignmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChoreAssignmentGroupByOutputType[P]>
            : GetScalarType<T[P], ChoreAssignmentGroupByOutputType[P]>
        }
      >
    >


  export type ChoreAssignmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    choreId?: boolean
    userId?: boolean
    assignedAt?: boolean
    completedAt?: boolean
    chore?: boolean | ChoreDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["choreAssignment"]>

  export type ChoreAssignmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    choreId?: boolean
    userId?: boolean
    assignedAt?: boolean
    completedAt?: boolean
    chore?: boolean | ChoreDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["choreAssignment"]>

  export type ChoreAssignmentSelectScalar = {
    id?: boolean
    choreId?: boolean
    userId?: boolean
    assignedAt?: boolean
    completedAt?: boolean
  }

  export type ChoreAssignmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chore?: boolean | ChoreDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ChoreAssignmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chore?: boolean | ChoreDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ChoreAssignmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChoreAssignment"
    objects: {
      chore: Prisma.$ChorePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      choreId: string
      userId: string
      assignedAt: Date
      completedAt: Date | null
    }, ExtArgs["result"]["choreAssignment"]>
    composites: {}
  }

  type ChoreAssignmentGetPayload<S extends boolean | null | undefined | ChoreAssignmentDefaultArgs> = $Result.GetResult<Prisma.$ChoreAssignmentPayload, S>

  type ChoreAssignmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ChoreAssignmentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ChoreAssignmentCountAggregateInputType | true
    }

  export interface ChoreAssignmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChoreAssignment'], meta: { name: 'ChoreAssignment' } }
    /**
     * Find zero or one ChoreAssignment that matches the filter.
     * @param {ChoreAssignmentFindUniqueArgs} args - Arguments to find a ChoreAssignment
     * @example
     * // Get one ChoreAssignment
     * const choreAssignment = await prisma.choreAssignment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChoreAssignmentFindUniqueArgs>(args: SelectSubset<T, ChoreAssignmentFindUniqueArgs<ExtArgs>>): Prisma__ChoreAssignmentClient<$Result.GetResult<Prisma.$ChoreAssignmentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ChoreAssignment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ChoreAssignmentFindUniqueOrThrowArgs} args - Arguments to find a ChoreAssignment
     * @example
     * // Get one ChoreAssignment
     * const choreAssignment = await prisma.choreAssignment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChoreAssignmentFindUniqueOrThrowArgs>(args: SelectSubset<T, ChoreAssignmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChoreAssignmentClient<$Result.GetResult<Prisma.$ChoreAssignmentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ChoreAssignment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChoreAssignmentFindFirstArgs} args - Arguments to find a ChoreAssignment
     * @example
     * // Get one ChoreAssignment
     * const choreAssignment = await prisma.choreAssignment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChoreAssignmentFindFirstArgs>(args?: SelectSubset<T, ChoreAssignmentFindFirstArgs<ExtArgs>>): Prisma__ChoreAssignmentClient<$Result.GetResult<Prisma.$ChoreAssignmentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ChoreAssignment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChoreAssignmentFindFirstOrThrowArgs} args - Arguments to find a ChoreAssignment
     * @example
     * // Get one ChoreAssignment
     * const choreAssignment = await prisma.choreAssignment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChoreAssignmentFindFirstOrThrowArgs>(args?: SelectSubset<T, ChoreAssignmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChoreAssignmentClient<$Result.GetResult<Prisma.$ChoreAssignmentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ChoreAssignments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChoreAssignmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChoreAssignments
     * const choreAssignments = await prisma.choreAssignment.findMany()
     * 
     * // Get first 10 ChoreAssignments
     * const choreAssignments = await prisma.choreAssignment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const choreAssignmentWithIdOnly = await prisma.choreAssignment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChoreAssignmentFindManyArgs>(args?: SelectSubset<T, ChoreAssignmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChoreAssignmentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ChoreAssignment.
     * @param {ChoreAssignmentCreateArgs} args - Arguments to create a ChoreAssignment.
     * @example
     * // Create one ChoreAssignment
     * const ChoreAssignment = await prisma.choreAssignment.create({
     *   data: {
     *     // ... data to create a ChoreAssignment
     *   }
     * })
     * 
     */
    create<T extends ChoreAssignmentCreateArgs>(args: SelectSubset<T, ChoreAssignmentCreateArgs<ExtArgs>>): Prisma__ChoreAssignmentClient<$Result.GetResult<Prisma.$ChoreAssignmentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ChoreAssignments.
     * @param {ChoreAssignmentCreateManyArgs} args - Arguments to create many ChoreAssignments.
     * @example
     * // Create many ChoreAssignments
     * const choreAssignment = await prisma.choreAssignment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChoreAssignmentCreateManyArgs>(args?: SelectSubset<T, ChoreAssignmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChoreAssignments and returns the data saved in the database.
     * @param {ChoreAssignmentCreateManyAndReturnArgs} args - Arguments to create many ChoreAssignments.
     * @example
     * // Create many ChoreAssignments
     * const choreAssignment = await prisma.choreAssignment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChoreAssignments and only return the `id`
     * const choreAssignmentWithIdOnly = await prisma.choreAssignment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChoreAssignmentCreateManyAndReturnArgs>(args?: SelectSubset<T, ChoreAssignmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChoreAssignmentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ChoreAssignment.
     * @param {ChoreAssignmentDeleteArgs} args - Arguments to delete one ChoreAssignment.
     * @example
     * // Delete one ChoreAssignment
     * const ChoreAssignment = await prisma.choreAssignment.delete({
     *   where: {
     *     // ... filter to delete one ChoreAssignment
     *   }
     * })
     * 
     */
    delete<T extends ChoreAssignmentDeleteArgs>(args: SelectSubset<T, ChoreAssignmentDeleteArgs<ExtArgs>>): Prisma__ChoreAssignmentClient<$Result.GetResult<Prisma.$ChoreAssignmentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ChoreAssignment.
     * @param {ChoreAssignmentUpdateArgs} args - Arguments to update one ChoreAssignment.
     * @example
     * // Update one ChoreAssignment
     * const choreAssignment = await prisma.choreAssignment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChoreAssignmentUpdateArgs>(args: SelectSubset<T, ChoreAssignmentUpdateArgs<ExtArgs>>): Prisma__ChoreAssignmentClient<$Result.GetResult<Prisma.$ChoreAssignmentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ChoreAssignments.
     * @param {ChoreAssignmentDeleteManyArgs} args - Arguments to filter ChoreAssignments to delete.
     * @example
     * // Delete a few ChoreAssignments
     * const { count } = await prisma.choreAssignment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChoreAssignmentDeleteManyArgs>(args?: SelectSubset<T, ChoreAssignmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChoreAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChoreAssignmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChoreAssignments
     * const choreAssignment = await prisma.choreAssignment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChoreAssignmentUpdateManyArgs>(args: SelectSubset<T, ChoreAssignmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ChoreAssignment.
     * @param {ChoreAssignmentUpsertArgs} args - Arguments to update or create a ChoreAssignment.
     * @example
     * // Update or create a ChoreAssignment
     * const choreAssignment = await prisma.choreAssignment.upsert({
     *   create: {
     *     // ... data to create a ChoreAssignment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChoreAssignment we want to update
     *   }
     * })
     */
    upsert<T extends ChoreAssignmentUpsertArgs>(args: SelectSubset<T, ChoreAssignmentUpsertArgs<ExtArgs>>): Prisma__ChoreAssignmentClient<$Result.GetResult<Prisma.$ChoreAssignmentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ChoreAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChoreAssignmentCountArgs} args - Arguments to filter ChoreAssignments to count.
     * @example
     * // Count the number of ChoreAssignments
     * const count = await prisma.choreAssignment.count({
     *   where: {
     *     // ... the filter for the ChoreAssignments we want to count
     *   }
     * })
    **/
    count<T extends ChoreAssignmentCountArgs>(
      args?: Subset<T, ChoreAssignmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChoreAssignmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChoreAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChoreAssignmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChoreAssignmentAggregateArgs>(args: Subset<T, ChoreAssignmentAggregateArgs>): Prisma.PrismaPromise<GetChoreAssignmentAggregateType<T>>

    /**
     * Group by ChoreAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChoreAssignmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChoreAssignmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChoreAssignmentGroupByArgs['orderBy'] }
        : { orderBy?: ChoreAssignmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChoreAssignmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChoreAssignmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChoreAssignment model
   */
  readonly fields: ChoreAssignmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChoreAssignment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChoreAssignmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    chore<T extends ChoreDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChoreDefaultArgs<ExtArgs>>): Prisma__ChoreClient<$Result.GetResult<Prisma.$ChorePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChoreAssignment model
   */ 
  interface ChoreAssignmentFieldRefs {
    readonly id: FieldRef<"ChoreAssignment", 'String'>
    readonly choreId: FieldRef<"ChoreAssignment", 'String'>
    readonly userId: FieldRef<"ChoreAssignment", 'String'>
    readonly assignedAt: FieldRef<"ChoreAssignment", 'DateTime'>
    readonly completedAt: FieldRef<"ChoreAssignment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ChoreAssignment findUnique
   */
  export type ChoreAssignmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChoreAssignment
     */
    select?: ChoreAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChoreAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which ChoreAssignment to fetch.
     */
    where: ChoreAssignmentWhereUniqueInput
  }

  /**
   * ChoreAssignment findUniqueOrThrow
   */
  export type ChoreAssignmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChoreAssignment
     */
    select?: ChoreAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChoreAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which ChoreAssignment to fetch.
     */
    where: ChoreAssignmentWhereUniqueInput
  }

  /**
   * ChoreAssignment findFirst
   */
  export type ChoreAssignmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChoreAssignment
     */
    select?: ChoreAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChoreAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which ChoreAssignment to fetch.
     */
    where?: ChoreAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChoreAssignments to fetch.
     */
    orderBy?: ChoreAssignmentOrderByWithRelationInput | ChoreAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChoreAssignments.
     */
    cursor?: ChoreAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChoreAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChoreAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChoreAssignments.
     */
    distinct?: ChoreAssignmentScalarFieldEnum | ChoreAssignmentScalarFieldEnum[]
  }

  /**
   * ChoreAssignment findFirstOrThrow
   */
  export type ChoreAssignmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChoreAssignment
     */
    select?: ChoreAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChoreAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which ChoreAssignment to fetch.
     */
    where?: ChoreAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChoreAssignments to fetch.
     */
    orderBy?: ChoreAssignmentOrderByWithRelationInput | ChoreAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChoreAssignments.
     */
    cursor?: ChoreAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChoreAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChoreAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChoreAssignments.
     */
    distinct?: ChoreAssignmentScalarFieldEnum | ChoreAssignmentScalarFieldEnum[]
  }

  /**
   * ChoreAssignment findMany
   */
  export type ChoreAssignmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChoreAssignment
     */
    select?: ChoreAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChoreAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which ChoreAssignments to fetch.
     */
    where?: ChoreAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChoreAssignments to fetch.
     */
    orderBy?: ChoreAssignmentOrderByWithRelationInput | ChoreAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChoreAssignments.
     */
    cursor?: ChoreAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChoreAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChoreAssignments.
     */
    skip?: number
    distinct?: ChoreAssignmentScalarFieldEnum | ChoreAssignmentScalarFieldEnum[]
  }

  /**
   * ChoreAssignment create
   */
  export type ChoreAssignmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChoreAssignment
     */
    select?: ChoreAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChoreAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to create a ChoreAssignment.
     */
    data: XOR<ChoreAssignmentCreateInput, ChoreAssignmentUncheckedCreateInput>
  }

  /**
   * ChoreAssignment createMany
   */
  export type ChoreAssignmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChoreAssignments.
     */
    data: ChoreAssignmentCreateManyInput | ChoreAssignmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChoreAssignment createManyAndReturn
   */
  export type ChoreAssignmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChoreAssignment
     */
    select?: ChoreAssignmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ChoreAssignments.
     */
    data: ChoreAssignmentCreateManyInput | ChoreAssignmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChoreAssignmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChoreAssignment update
   */
  export type ChoreAssignmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChoreAssignment
     */
    select?: ChoreAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChoreAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to update a ChoreAssignment.
     */
    data: XOR<ChoreAssignmentUpdateInput, ChoreAssignmentUncheckedUpdateInput>
    /**
     * Choose, which ChoreAssignment to update.
     */
    where: ChoreAssignmentWhereUniqueInput
  }

  /**
   * ChoreAssignment updateMany
   */
  export type ChoreAssignmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChoreAssignments.
     */
    data: XOR<ChoreAssignmentUpdateManyMutationInput, ChoreAssignmentUncheckedUpdateManyInput>
    /**
     * Filter which ChoreAssignments to update
     */
    where?: ChoreAssignmentWhereInput
  }

  /**
   * ChoreAssignment upsert
   */
  export type ChoreAssignmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChoreAssignment
     */
    select?: ChoreAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChoreAssignmentInclude<ExtArgs> | null
    /**
     * The filter to search for the ChoreAssignment to update in case it exists.
     */
    where: ChoreAssignmentWhereUniqueInput
    /**
     * In case the ChoreAssignment found by the `where` argument doesn't exist, create a new ChoreAssignment with this data.
     */
    create: XOR<ChoreAssignmentCreateInput, ChoreAssignmentUncheckedCreateInput>
    /**
     * In case the ChoreAssignment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChoreAssignmentUpdateInput, ChoreAssignmentUncheckedUpdateInput>
  }

  /**
   * ChoreAssignment delete
   */
  export type ChoreAssignmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChoreAssignment
     */
    select?: ChoreAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChoreAssignmentInclude<ExtArgs> | null
    /**
     * Filter which ChoreAssignment to delete.
     */
    where: ChoreAssignmentWhereUniqueInput
  }

  /**
   * ChoreAssignment deleteMany
   */
  export type ChoreAssignmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChoreAssignments to delete
     */
    where?: ChoreAssignmentWhereInput
  }

  /**
   * ChoreAssignment without action
   */
  export type ChoreAssignmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChoreAssignment
     */
    select?: ChoreAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChoreAssignmentInclude<ExtArgs> | null
  }


  /**
   * Model ChoreSwapRequest
   */

  export type AggregateChoreSwapRequest = {
    _count: ChoreSwapRequestCountAggregateOutputType | null
    _min: ChoreSwapRequestMinAggregateOutputType | null
    _max: ChoreSwapRequestMaxAggregateOutputType | null
  }

  export type ChoreSwapRequestMinAggregateOutputType = {
    id: string | null
    choreId: string | null
    requestingUserId: string | null
    targetUserId: string | null
    status: $Enums.ChoreSwapRequestStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ChoreSwapRequestMaxAggregateOutputType = {
    id: string | null
    choreId: string | null
    requestingUserId: string | null
    targetUserId: string | null
    status: $Enums.ChoreSwapRequestStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ChoreSwapRequestCountAggregateOutputType = {
    id: number
    choreId: number
    requestingUserId: number
    targetUserId: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ChoreSwapRequestMinAggregateInputType = {
    id?: true
    choreId?: true
    requestingUserId?: true
    targetUserId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ChoreSwapRequestMaxAggregateInputType = {
    id?: true
    choreId?: true
    requestingUserId?: true
    targetUserId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ChoreSwapRequestCountAggregateInputType = {
    id?: true
    choreId?: true
    requestingUserId?: true
    targetUserId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ChoreSwapRequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChoreSwapRequest to aggregate.
     */
    where?: ChoreSwapRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChoreSwapRequests to fetch.
     */
    orderBy?: ChoreSwapRequestOrderByWithRelationInput | ChoreSwapRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChoreSwapRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChoreSwapRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChoreSwapRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChoreSwapRequests
    **/
    _count?: true | ChoreSwapRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChoreSwapRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChoreSwapRequestMaxAggregateInputType
  }

  export type GetChoreSwapRequestAggregateType<T extends ChoreSwapRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateChoreSwapRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChoreSwapRequest[P]>
      : GetScalarType<T[P], AggregateChoreSwapRequest[P]>
  }




  export type ChoreSwapRequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChoreSwapRequestWhereInput
    orderBy?: ChoreSwapRequestOrderByWithAggregationInput | ChoreSwapRequestOrderByWithAggregationInput[]
    by: ChoreSwapRequestScalarFieldEnum[] | ChoreSwapRequestScalarFieldEnum
    having?: ChoreSwapRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChoreSwapRequestCountAggregateInputType | true
    _min?: ChoreSwapRequestMinAggregateInputType
    _max?: ChoreSwapRequestMaxAggregateInputType
  }

  export type ChoreSwapRequestGroupByOutputType = {
    id: string
    choreId: string
    requestingUserId: string
    targetUserId: string
    status: $Enums.ChoreSwapRequestStatus
    createdAt: Date
    updatedAt: Date
    _count: ChoreSwapRequestCountAggregateOutputType | null
    _min: ChoreSwapRequestMinAggregateOutputType | null
    _max: ChoreSwapRequestMaxAggregateOutputType | null
  }

  type GetChoreSwapRequestGroupByPayload<T extends ChoreSwapRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChoreSwapRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChoreSwapRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChoreSwapRequestGroupByOutputType[P]>
            : GetScalarType<T[P], ChoreSwapRequestGroupByOutputType[P]>
        }
      >
    >


  export type ChoreSwapRequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    choreId?: boolean
    requestingUserId?: boolean
    targetUserId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    requestingUser?: boolean | UserDefaultArgs<ExtArgs>
    targetUser?: boolean | UserDefaultArgs<ExtArgs>
    chore?: boolean | ChoreDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["choreSwapRequest"]>

  export type ChoreSwapRequestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    choreId?: boolean
    requestingUserId?: boolean
    targetUserId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    requestingUser?: boolean | UserDefaultArgs<ExtArgs>
    targetUser?: boolean | UserDefaultArgs<ExtArgs>
    chore?: boolean | ChoreDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["choreSwapRequest"]>

  export type ChoreSwapRequestSelectScalar = {
    id?: boolean
    choreId?: boolean
    requestingUserId?: boolean
    targetUserId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ChoreSwapRequestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    requestingUser?: boolean | UserDefaultArgs<ExtArgs>
    targetUser?: boolean | UserDefaultArgs<ExtArgs>
    chore?: boolean | ChoreDefaultArgs<ExtArgs>
  }
  export type ChoreSwapRequestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    requestingUser?: boolean | UserDefaultArgs<ExtArgs>
    targetUser?: boolean | UserDefaultArgs<ExtArgs>
    chore?: boolean | ChoreDefaultArgs<ExtArgs>
  }

  export type $ChoreSwapRequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChoreSwapRequest"
    objects: {
      requestingUser: Prisma.$UserPayload<ExtArgs>
      targetUser: Prisma.$UserPayload<ExtArgs>
      chore: Prisma.$ChorePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      choreId: string
      requestingUserId: string
      targetUserId: string
      status: $Enums.ChoreSwapRequestStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["choreSwapRequest"]>
    composites: {}
  }

  type ChoreSwapRequestGetPayload<S extends boolean | null | undefined | ChoreSwapRequestDefaultArgs> = $Result.GetResult<Prisma.$ChoreSwapRequestPayload, S>

  type ChoreSwapRequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ChoreSwapRequestFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ChoreSwapRequestCountAggregateInputType | true
    }

  export interface ChoreSwapRequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChoreSwapRequest'], meta: { name: 'ChoreSwapRequest' } }
    /**
     * Find zero or one ChoreSwapRequest that matches the filter.
     * @param {ChoreSwapRequestFindUniqueArgs} args - Arguments to find a ChoreSwapRequest
     * @example
     * // Get one ChoreSwapRequest
     * const choreSwapRequest = await prisma.choreSwapRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChoreSwapRequestFindUniqueArgs>(args: SelectSubset<T, ChoreSwapRequestFindUniqueArgs<ExtArgs>>): Prisma__ChoreSwapRequestClient<$Result.GetResult<Prisma.$ChoreSwapRequestPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ChoreSwapRequest that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ChoreSwapRequestFindUniqueOrThrowArgs} args - Arguments to find a ChoreSwapRequest
     * @example
     * // Get one ChoreSwapRequest
     * const choreSwapRequest = await prisma.choreSwapRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChoreSwapRequestFindUniqueOrThrowArgs>(args: SelectSubset<T, ChoreSwapRequestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChoreSwapRequestClient<$Result.GetResult<Prisma.$ChoreSwapRequestPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ChoreSwapRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChoreSwapRequestFindFirstArgs} args - Arguments to find a ChoreSwapRequest
     * @example
     * // Get one ChoreSwapRequest
     * const choreSwapRequest = await prisma.choreSwapRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChoreSwapRequestFindFirstArgs>(args?: SelectSubset<T, ChoreSwapRequestFindFirstArgs<ExtArgs>>): Prisma__ChoreSwapRequestClient<$Result.GetResult<Prisma.$ChoreSwapRequestPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ChoreSwapRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChoreSwapRequestFindFirstOrThrowArgs} args - Arguments to find a ChoreSwapRequest
     * @example
     * // Get one ChoreSwapRequest
     * const choreSwapRequest = await prisma.choreSwapRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChoreSwapRequestFindFirstOrThrowArgs>(args?: SelectSubset<T, ChoreSwapRequestFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChoreSwapRequestClient<$Result.GetResult<Prisma.$ChoreSwapRequestPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ChoreSwapRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChoreSwapRequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChoreSwapRequests
     * const choreSwapRequests = await prisma.choreSwapRequest.findMany()
     * 
     * // Get first 10 ChoreSwapRequests
     * const choreSwapRequests = await prisma.choreSwapRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const choreSwapRequestWithIdOnly = await prisma.choreSwapRequest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChoreSwapRequestFindManyArgs>(args?: SelectSubset<T, ChoreSwapRequestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChoreSwapRequestPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ChoreSwapRequest.
     * @param {ChoreSwapRequestCreateArgs} args - Arguments to create a ChoreSwapRequest.
     * @example
     * // Create one ChoreSwapRequest
     * const ChoreSwapRequest = await prisma.choreSwapRequest.create({
     *   data: {
     *     // ... data to create a ChoreSwapRequest
     *   }
     * })
     * 
     */
    create<T extends ChoreSwapRequestCreateArgs>(args: SelectSubset<T, ChoreSwapRequestCreateArgs<ExtArgs>>): Prisma__ChoreSwapRequestClient<$Result.GetResult<Prisma.$ChoreSwapRequestPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ChoreSwapRequests.
     * @param {ChoreSwapRequestCreateManyArgs} args - Arguments to create many ChoreSwapRequests.
     * @example
     * // Create many ChoreSwapRequests
     * const choreSwapRequest = await prisma.choreSwapRequest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChoreSwapRequestCreateManyArgs>(args?: SelectSubset<T, ChoreSwapRequestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChoreSwapRequests and returns the data saved in the database.
     * @param {ChoreSwapRequestCreateManyAndReturnArgs} args - Arguments to create many ChoreSwapRequests.
     * @example
     * // Create many ChoreSwapRequests
     * const choreSwapRequest = await prisma.choreSwapRequest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChoreSwapRequests and only return the `id`
     * const choreSwapRequestWithIdOnly = await prisma.choreSwapRequest.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChoreSwapRequestCreateManyAndReturnArgs>(args?: SelectSubset<T, ChoreSwapRequestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChoreSwapRequestPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ChoreSwapRequest.
     * @param {ChoreSwapRequestDeleteArgs} args - Arguments to delete one ChoreSwapRequest.
     * @example
     * // Delete one ChoreSwapRequest
     * const ChoreSwapRequest = await prisma.choreSwapRequest.delete({
     *   where: {
     *     // ... filter to delete one ChoreSwapRequest
     *   }
     * })
     * 
     */
    delete<T extends ChoreSwapRequestDeleteArgs>(args: SelectSubset<T, ChoreSwapRequestDeleteArgs<ExtArgs>>): Prisma__ChoreSwapRequestClient<$Result.GetResult<Prisma.$ChoreSwapRequestPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ChoreSwapRequest.
     * @param {ChoreSwapRequestUpdateArgs} args - Arguments to update one ChoreSwapRequest.
     * @example
     * // Update one ChoreSwapRequest
     * const choreSwapRequest = await prisma.choreSwapRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChoreSwapRequestUpdateArgs>(args: SelectSubset<T, ChoreSwapRequestUpdateArgs<ExtArgs>>): Prisma__ChoreSwapRequestClient<$Result.GetResult<Prisma.$ChoreSwapRequestPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ChoreSwapRequests.
     * @param {ChoreSwapRequestDeleteManyArgs} args - Arguments to filter ChoreSwapRequests to delete.
     * @example
     * // Delete a few ChoreSwapRequests
     * const { count } = await prisma.choreSwapRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChoreSwapRequestDeleteManyArgs>(args?: SelectSubset<T, ChoreSwapRequestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChoreSwapRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChoreSwapRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChoreSwapRequests
     * const choreSwapRequest = await prisma.choreSwapRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChoreSwapRequestUpdateManyArgs>(args: SelectSubset<T, ChoreSwapRequestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ChoreSwapRequest.
     * @param {ChoreSwapRequestUpsertArgs} args - Arguments to update or create a ChoreSwapRequest.
     * @example
     * // Update or create a ChoreSwapRequest
     * const choreSwapRequest = await prisma.choreSwapRequest.upsert({
     *   create: {
     *     // ... data to create a ChoreSwapRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChoreSwapRequest we want to update
     *   }
     * })
     */
    upsert<T extends ChoreSwapRequestUpsertArgs>(args: SelectSubset<T, ChoreSwapRequestUpsertArgs<ExtArgs>>): Prisma__ChoreSwapRequestClient<$Result.GetResult<Prisma.$ChoreSwapRequestPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ChoreSwapRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChoreSwapRequestCountArgs} args - Arguments to filter ChoreSwapRequests to count.
     * @example
     * // Count the number of ChoreSwapRequests
     * const count = await prisma.choreSwapRequest.count({
     *   where: {
     *     // ... the filter for the ChoreSwapRequests we want to count
     *   }
     * })
    **/
    count<T extends ChoreSwapRequestCountArgs>(
      args?: Subset<T, ChoreSwapRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChoreSwapRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChoreSwapRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChoreSwapRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChoreSwapRequestAggregateArgs>(args: Subset<T, ChoreSwapRequestAggregateArgs>): Prisma.PrismaPromise<GetChoreSwapRequestAggregateType<T>>

    /**
     * Group by ChoreSwapRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChoreSwapRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChoreSwapRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChoreSwapRequestGroupByArgs['orderBy'] }
        : { orderBy?: ChoreSwapRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChoreSwapRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChoreSwapRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChoreSwapRequest model
   */
  readonly fields: ChoreSwapRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChoreSwapRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChoreSwapRequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    requestingUser<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    targetUser<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    chore<T extends ChoreDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChoreDefaultArgs<ExtArgs>>): Prisma__ChoreClient<$Result.GetResult<Prisma.$ChorePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChoreSwapRequest model
   */ 
  interface ChoreSwapRequestFieldRefs {
    readonly id: FieldRef<"ChoreSwapRequest", 'String'>
    readonly choreId: FieldRef<"ChoreSwapRequest", 'String'>
    readonly requestingUserId: FieldRef<"ChoreSwapRequest", 'String'>
    readonly targetUserId: FieldRef<"ChoreSwapRequest", 'String'>
    readonly status: FieldRef<"ChoreSwapRequest", 'ChoreSwapRequestStatus'>
    readonly createdAt: FieldRef<"ChoreSwapRequest", 'DateTime'>
    readonly updatedAt: FieldRef<"ChoreSwapRequest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ChoreSwapRequest findUnique
   */
  export type ChoreSwapRequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChoreSwapRequest
     */
    select?: ChoreSwapRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChoreSwapRequestInclude<ExtArgs> | null
    /**
     * Filter, which ChoreSwapRequest to fetch.
     */
    where: ChoreSwapRequestWhereUniqueInput
  }

  /**
   * ChoreSwapRequest findUniqueOrThrow
   */
  export type ChoreSwapRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChoreSwapRequest
     */
    select?: ChoreSwapRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChoreSwapRequestInclude<ExtArgs> | null
    /**
     * Filter, which ChoreSwapRequest to fetch.
     */
    where: ChoreSwapRequestWhereUniqueInput
  }

  /**
   * ChoreSwapRequest findFirst
   */
  export type ChoreSwapRequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChoreSwapRequest
     */
    select?: ChoreSwapRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChoreSwapRequestInclude<ExtArgs> | null
    /**
     * Filter, which ChoreSwapRequest to fetch.
     */
    where?: ChoreSwapRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChoreSwapRequests to fetch.
     */
    orderBy?: ChoreSwapRequestOrderByWithRelationInput | ChoreSwapRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChoreSwapRequests.
     */
    cursor?: ChoreSwapRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChoreSwapRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChoreSwapRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChoreSwapRequests.
     */
    distinct?: ChoreSwapRequestScalarFieldEnum | ChoreSwapRequestScalarFieldEnum[]
  }

  /**
   * ChoreSwapRequest findFirstOrThrow
   */
  export type ChoreSwapRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChoreSwapRequest
     */
    select?: ChoreSwapRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChoreSwapRequestInclude<ExtArgs> | null
    /**
     * Filter, which ChoreSwapRequest to fetch.
     */
    where?: ChoreSwapRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChoreSwapRequests to fetch.
     */
    orderBy?: ChoreSwapRequestOrderByWithRelationInput | ChoreSwapRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChoreSwapRequests.
     */
    cursor?: ChoreSwapRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChoreSwapRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChoreSwapRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChoreSwapRequests.
     */
    distinct?: ChoreSwapRequestScalarFieldEnum | ChoreSwapRequestScalarFieldEnum[]
  }

  /**
   * ChoreSwapRequest findMany
   */
  export type ChoreSwapRequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChoreSwapRequest
     */
    select?: ChoreSwapRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChoreSwapRequestInclude<ExtArgs> | null
    /**
     * Filter, which ChoreSwapRequests to fetch.
     */
    where?: ChoreSwapRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChoreSwapRequests to fetch.
     */
    orderBy?: ChoreSwapRequestOrderByWithRelationInput | ChoreSwapRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChoreSwapRequests.
     */
    cursor?: ChoreSwapRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChoreSwapRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChoreSwapRequests.
     */
    skip?: number
    distinct?: ChoreSwapRequestScalarFieldEnum | ChoreSwapRequestScalarFieldEnum[]
  }

  /**
   * ChoreSwapRequest create
   */
  export type ChoreSwapRequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChoreSwapRequest
     */
    select?: ChoreSwapRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChoreSwapRequestInclude<ExtArgs> | null
    /**
     * The data needed to create a ChoreSwapRequest.
     */
    data: XOR<ChoreSwapRequestCreateInput, ChoreSwapRequestUncheckedCreateInput>
  }

  /**
   * ChoreSwapRequest createMany
   */
  export type ChoreSwapRequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChoreSwapRequests.
     */
    data: ChoreSwapRequestCreateManyInput | ChoreSwapRequestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChoreSwapRequest createManyAndReturn
   */
  export type ChoreSwapRequestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChoreSwapRequest
     */
    select?: ChoreSwapRequestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ChoreSwapRequests.
     */
    data: ChoreSwapRequestCreateManyInput | ChoreSwapRequestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChoreSwapRequestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChoreSwapRequest update
   */
  export type ChoreSwapRequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChoreSwapRequest
     */
    select?: ChoreSwapRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChoreSwapRequestInclude<ExtArgs> | null
    /**
     * The data needed to update a ChoreSwapRequest.
     */
    data: XOR<ChoreSwapRequestUpdateInput, ChoreSwapRequestUncheckedUpdateInput>
    /**
     * Choose, which ChoreSwapRequest to update.
     */
    where: ChoreSwapRequestWhereUniqueInput
  }

  /**
   * ChoreSwapRequest updateMany
   */
  export type ChoreSwapRequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChoreSwapRequests.
     */
    data: XOR<ChoreSwapRequestUpdateManyMutationInput, ChoreSwapRequestUncheckedUpdateManyInput>
    /**
     * Filter which ChoreSwapRequests to update
     */
    where?: ChoreSwapRequestWhereInput
  }

  /**
   * ChoreSwapRequest upsert
   */
  export type ChoreSwapRequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChoreSwapRequest
     */
    select?: ChoreSwapRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChoreSwapRequestInclude<ExtArgs> | null
    /**
     * The filter to search for the ChoreSwapRequest to update in case it exists.
     */
    where: ChoreSwapRequestWhereUniqueInput
    /**
     * In case the ChoreSwapRequest found by the `where` argument doesn't exist, create a new ChoreSwapRequest with this data.
     */
    create: XOR<ChoreSwapRequestCreateInput, ChoreSwapRequestUncheckedCreateInput>
    /**
     * In case the ChoreSwapRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChoreSwapRequestUpdateInput, ChoreSwapRequestUncheckedUpdateInput>
  }

  /**
   * ChoreSwapRequest delete
   */
  export type ChoreSwapRequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChoreSwapRequest
     */
    select?: ChoreSwapRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChoreSwapRequestInclude<ExtArgs> | null
    /**
     * Filter which ChoreSwapRequest to delete.
     */
    where: ChoreSwapRequestWhereUniqueInput
  }

  /**
   * ChoreSwapRequest deleteMany
   */
  export type ChoreSwapRequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChoreSwapRequests to delete
     */
    where?: ChoreSwapRequestWhereInput
  }

  /**
   * ChoreSwapRequest without action
   */
  export type ChoreSwapRequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChoreSwapRequest
     */
    select?: ChoreSwapRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChoreSwapRequestInclude<ExtArgs> | null
  }


  /**
   * Model ChoreTemplate
   */

  export type AggregateChoreTemplate = {
    _count: ChoreTemplateCountAggregateOutputType | null
    _min: ChoreTemplateMinAggregateOutputType | null
    _max: ChoreTemplateMaxAggregateOutputType | null
  }

  export type ChoreTemplateMinAggregateOutputType = {
    id: string | null
    householdId: string | null
    title: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ChoreTemplateMaxAggregateOutputType = {
    id: string | null
    householdId: string | null
    title: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ChoreTemplateCountAggregateOutputType = {
    id: number
    householdId: number
    title: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ChoreTemplateMinAggregateInputType = {
    id?: true
    householdId?: true
    title?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ChoreTemplateMaxAggregateInputType = {
    id?: true
    householdId?: true
    title?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ChoreTemplateCountAggregateInputType = {
    id?: true
    householdId?: true
    title?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ChoreTemplateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChoreTemplate to aggregate.
     */
    where?: ChoreTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChoreTemplates to fetch.
     */
    orderBy?: ChoreTemplateOrderByWithRelationInput | ChoreTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChoreTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChoreTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChoreTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChoreTemplates
    **/
    _count?: true | ChoreTemplateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChoreTemplateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChoreTemplateMaxAggregateInputType
  }

  export type GetChoreTemplateAggregateType<T extends ChoreTemplateAggregateArgs> = {
        [P in keyof T & keyof AggregateChoreTemplate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChoreTemplate[P]>
      : GetScalarType<T[P], AggregateChoreTemplate[P]>
  }




  export type ChoreTemplateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChoreTemplateWhereInput
    orderBy?: ChoreTemplateOrderByWithAggregationInput | ChoreTemplateOrderByWithAggregationInput[]
    by: ChoreTemplateScalarFieldEnum[] | ChoreTemplateScalarFieldEnum
    having?: ChoreTemplateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChoreTemplateCountAggregateInputType | true
    _min?: ChoreTemplateMinAggregateInputType
    _max?: ChoreTemplateMaxAggregateInputType
  }

  export type ChoreTemplateGroupByOutputType = {
    id: string
    householdId: string
    title: string
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: ChoreTemplateCountAggregateOutputType | null
    _min: ChoreTemplateMinAggregateOutputType | null
    _max: ChoreTemplateMaxAggregateOutputType | null
  }

  type GetChoreTemplateGroupByPayload<T extends ChoreTemplateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChoreTemplateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChoreTemplateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChoreTemplateGroupByOutputType[P]>
            : GetScalarType<T[P], ChoreTemplateGroupByOutputType[P]>
        }
      >
    >


  export type ChoreTemplateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    householdId?: boolean
    title?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    household?: boolean | HouseholdDefaultArgs<ExtArgs>
    subtasks?: boolean | ChoreTemplate$subtasksArgs<ExtArgs>
    _count?: boolean | ChoreTemplateCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["choreTemplate"]>

  export type ChoreTemplateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    householdId?: boolean
    title?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    household?: boolean | HouseholdDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["choreTemplate"]>

  export type ChoreTemplateSelectScalar = {
    id?: boolean
    householdId?: boolean
    title?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ChoreTemplateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    household?: boolean | HouseholdDefaultArgs<ExtArgs>
    subtasks?: boolean | ChoreTemplate$subtasksArgs<ExtArgs>
    _count?: boolean | ChoreTemplateCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ChoreTemplateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    household?: boolean | HouseholdDefaultArgs<ExtArgs>
  }

  export type $ChoreTemplatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChoreTemplate"
    objects: {
      household: Prisma.$HouseholdPayload<ExtArgs>
      subtasks: Prisma.$SubtaskTemplatePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      householdId: string
      title: string
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["choreTemplate"]>
    composites: {}
  }

  type ChoreTemplateGetPayload<S extends boolean | null | undefined | ChoreTemplateDefaultArgs> = $Result.GetResult<Prisma.$ChoreTemplatePayload, S>

  type ChoreTemplateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ChoreTemplateFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ChoreTemplateCountAggregateInputType | true
    }

  export interface ChoreTemplateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChoreTemplate'], meta: { name: 'ChoreTemplate' } }
    /**
     * Find zero or one ChoreTemplate that matches the filter.
     * @param {ChoreTemplateFindUniqueArgs} args - Arguments to find a ChoreTemplate
     * @example
     * // Get one ChoreTemplate
     * const choreTemplate = await prisma.choreTemplate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChoreTemplateFindUniqueArgs>(args: SelectSubset<T, ChoreTemplateFindUniqueArgs<ExtArgs>>): Prisma__ChoreTemplateClient<$Result.GetResult<Prisma.$ChoreTemplatePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ChoreTemplate that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ChoreTemplateFindUniqueOrThrowArgs} args - Arguments to find a ChoreTemplate
     * @example
     * // Get one ChoreTemplate
     * const choreTemplate = await prisma.choreTemplate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChoreTemplateFindUniqueOrThrowArgs>(args: SelectSubset<T, ChoreTemplateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChoreTemplateClient<$Result.GetResult<Prisma.$ChoreTemplatePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ChoreTemplate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChoreTemplateFindFirstArgs} args - Arguments to find a ChoreTemplate
     * @example
     * // Get one ChoreTemplate
     * const choreTemplate = await prisma.choreTemplate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChoreTemplateFindFirstArgs>(args?: SelectSubset<T, ChoreTemplateFindFirstArgs<ExtArgs>>): Prisma__ChoreTemplateClient<$Result.GetResult<Prisma.$ChoreTemplatePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ChoreTemplate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChoreTemplateFindFirstOrThrowArgs} args - Arguments to find a ChoreTemplate
     * @example
     * // Get one ChoreTemplate
     * const choreTemplate = await prisma.choreTemplate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChoreTemplateFindFirstOrThrowArgs>(args?: SelectSubset<T, ChoreTemplateFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChoreTemplateClient<$Result.GetResult<Prisma.$ChoreTemplatePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ChoreTemplates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChoreTemplateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChoreTemplates
     * const choreTemplates = await prisma.choreTemplate.findMany()
     * 
     * // Get first 10 ChoreTemplates
     * const choreTemplates = await prisma.choreTemplate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const choreTemplateWithIdOnly = await prisma.choreTemplate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChoreTemplateFindManyArgs>(args?: SelectSubset<T, ChoreTemplateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChoreTemplatePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ChoreTemplate.
     * @param {ChoreTemplateCreateArgs} args - Arguments to create a ChoreTemplate.
     * @example
     * // Create one ChoreTemplate
     * const ChoreTemplate = await prisma.choreTemplate.create({
     *   data: {
     *     // ... data to create a ChoreTemplate
     *   }
     * })
     * 
     */
    create<T extends ChoreTemplateCreateArgs>(args: SelectSubset<T, ChoreTemplateCreateArgs<ExtArgs>>): Prisma__ChoreTemplateClient<$Result.GetResult<Prisma.$ChoreTemplatePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ChoreTemplates.
     * @param {ChoreTemplateCreateManyArgs} args - Arguments to create many ChoreTemplates.
     * @example
     * // Create many ChoreTemplates
     * const choreTemplate = await prisma.choreTemplate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChoreTemplateCreateManyArgs>(args?: SelectSubset<T, ChoreTemplateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChoreTemplates and returns the data saved in the database.
     * @param {ChoreTemplateCreateManyAndReturnArgs} args - Arguments to create many ChoreTemplates.
     * @example
     * // Create many ChoreTemplates
     * const choreTemplate = await prisma.choreTemplate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChoreTemplates and only return the `id`
     * const choreTemplateWithIdOnly = await prisma.choreTemplate.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChoreTemplateCreateManyAndReturnArgs>(args?: SelectSubset<T, ChoreTemplateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChoreTemplatePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ChoreTemplate.
     * @param {ChoreTemplateDeleteArgs} args - Arguments to delete one ChoreTemplate.
     * @example
     * // Delete one ChoreTemplate
     * const ChoreTemplate = await prisma.choreTemplate.delete({
     *   where: {
     *     // ... filter to delete one ChoreTemplate
     *   }
     * })
     * 
     */
    delete<T extends ChoreTemplateDeleteArgs>(args: SelectSubset<T, ChoreTemplateDeleteArgs<ExtArgs>>): Prisma__ChoreTemplateClient<$Result.GetResult<Prisma.$ChoreTemplatePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ChoreTemplate.
     * @param {ChoreTemplateUpdateArgs} args - Arguments to update one ChoreTemplate.
     * @example
     * // Update one ChoreTemplate
     * const choreTemplate = await prisma.choreTemplate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChoreTemplateUpdateArgs>(args: SelectSubset<T, ChoreTemplateUpdateArgs<ExtArgs>>): Prisma__ChoreTemplateClient<$Result.GetResult<Prisma.$ChoreTemplatePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ChoreTemplates.
     * @param {ChoreTemplateDeleteManyArgs} args - Arguments to filter ChoreTemplates to delete.
     * @example
     * // Delete a few ChoreTemplates
     * const { count } = await prisma.choreTemplate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChoreTemplateDeleteManyArgs>(args?: SelectSubset<T, ChoreTemplateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChoreTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChoreTemplateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChoreTemplates
     * const choreTemplate = await prisma.choreTemplate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChoreTemplateUpdateManyArgs>(args: SelectSubset<T, ChoreTemplateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ChoreTemplate.
     * @param {ChoreTemplateUpsertArgs} args - Arguments to update or create a ChoreTemplate.
     * @example
     * // Update or create a ChoreTemplate
     * const choreTemplate = await prisma.choreTemplate.upsert({
     *   create: {
     *     // ... data to create a ChoreTemplate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChoreTemplate we want to update
     *   }
     * })
     */
    upsert<T extends ChoreTemplateUpsertArgs>(args: SelectSubset<T, ChoreTemplateUpsertArgs<ExtArgs>>): Prisma__ChoreTemplateClient<$Result.GetResult<Prisma.$ChoreTemplatePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ChoreTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChoreTemplateCountArgs} args - Arguments to filter ChoreTemplates to count.
     * @example
     * // Count the number of ChoreTemplates
     * const count = await prisma.choreTemplate.count({
     *   where: {
     *     // ... the filter for the ChoreTemplates we want to count
     *   }
     * })
    **/
    count<T extends ChoreTemplateCountArgs>(
      args?: Subset<T, ChoreTemplateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChoreTemplateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChoreTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChoreTemplateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChoreTemplateAggregateArgs>(args: Subset<T, ChoreTemplateAggregateArgs>): Prisma.PrismaPromise<GetChoreTemplateAggregateType<T>>

    /**
     * Group by ChoreTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChoreTemplateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChoreTemplateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChoreTemplateGroupByArgs['orderBy'] }
        : { orderBy?: ChoreTemplateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChoreTemplateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChoreTemplateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChoreTemplate model
   */
  readonly fields: ChoreTemplateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChoreTemplate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChoreTemplateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    household<T extends HouseholdDefaultArgs<ExtArgs> = {}>(args?: Subset<T, HouseholdDefaultArgs<ExtArgs>>): Prisma__HouseholdClient<$Result.GetResult<Prisma.$HouseholdPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    subtasks<T extends ChoreTemplate$subtasksArgs<ExtArgs> = {}>(args?: Subset<T, ChoreTemplate$subtasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubtaskTemplatePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChoreTemplate model
   */ 
  interface ChoreTemplateFieldRefs {
    readonly id: FieldRef<"ChoreTemplate", 'String'>
    readonly householdId: FieldRef<"ChoreTemplate", 'String'>
    readonly title: FieldRef<"ChoreTemplate", 'String'>
    readonly description: FieldRef<"ChoreTemplate", 'String'>
    readonly createdAt: FieldRef<"ChoreTemplate", 'DateTime'>
    readonly updatedAt: FieldRef<"ChoreTemplate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ChoreTemplate findUnique
   */
  export type ChoreTemplateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChoreTemplate
     */
    select?: ChoreTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChoreTemplateInclude<ExtArgs> | null
    /**
     * Filter, which ChoreTemplate to fetch.
     */
    where: ChoreTemplateWhereUniqueInput
  }

  /**
   * ChoreTemplate findUniqueOrThrow
   */
  export type ChoreTemplateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChoreTemplate
     */
    select?: ChoreTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChoreTemplateInclude<ExtArgs> | null
    /**
     * Filter, which ChoreTemplate to fetch.
     */
    where: ChoreTemplateWhereUniqueInput
  }

  /**
   * ChoreTemplate findFirst
   */
  export type ChoreTemplateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChoreTemplate
     */
    select?: ChoreTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChoreTemplateInclude<ExtArgs> | null
    /**
     * Filter, which ChoreTemplate to fetch.
     */
    where?: ChoreTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChoreTemplates to fetch.
     */
    orderBy?: ChoreTemplateOrderByWithRelationInput | ChoreTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChoreTemplates.
     */
    cursor?: ChoreTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChoreTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChoreTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChoreTemplates.
     */
    distinct?: ChoreTemplateScalarFieldEnum | ChoreTemplateScalarFieldEnum[]
  }

  /**
   * ChoreTemplate findFirstOrThrow
   */
  export type ChoreTemplateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChoreTemplate
     */
    select?: ChoreTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChoreTemplateInclude<ExtArgs> | null
    /**
     * Filter, which ChoreTemplate to fetch.
     */
    where?: ChoreTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChoreTemplates to fetch.
     */
    orderBy?: ChoreTemplateOrderByWithRelationInput | ChoreTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChoreTemplates.
     */
    cursor?: ChoreTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChoreTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChoreTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChoreTemplates.
     */
    distinct?: ChoreTemplateScalarFieldEnum | ChoreTemplateScalarFieldEnum[]
  }

  /**
   * ChoreTemplate findMany
   */
  export type ChoreTemplateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChoreTemplate
     */
    select?: ChoreTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChoreTemplateInclude<ExtArgs> | null
    /**
     * Filter, which ChoreTemplates to fetch.
     */
    where?: ChoreTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChoreTemplates to fetch.
     */
    orderBy?: ChoreTemplateOrderByWithRelationInput | ChoreTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChoreTemplates.
     */
    cursor?: ChoreTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChoreTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChoreTemplates.
     */
    skip?: number
    distinct?: ChoreTemplateScalarFieldEnum | ChoreTemplateScalarFieldEnum[]
  }

  /**
   * ChoreTemplate create
   */
  export type ChoreTemplateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChoreTemplate
     */
    select?: ChoreTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChoreTemplateInclude<ExtArgs> | null
    /**
     * The data needed to create a ChoreTemplate.
     */
    data: XOR<ChoreTemplateCreateInput, ChoreTemplateUncheckedCreateInput>
  }

  /**
   * ChoreTemplate createMany
   */
  export type ChoreTemplateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChoreTemplates.
     */
    data: ChoreTemplateCreateManyInput | ChoreTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChoreTemplate createManyAndReturn
   */
  export type ChoreTemplateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChoreTemplate
     */
    select?: ChoreTemplateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ChoreTemplates.
     */
    data: ChoreTemplateCreateManyInput | ChoreTemplateCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChoreTemplateIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChoreTemplate update
   */
  export type ChoreTemplateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChoreTemplate
     */
    select?: ChoreTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChoreTemplateInclude<ExtArgs> | null
    /**
     * The data needed to update a ChoreTemplate.
     */
    data: XOR<ChoreTemplateUpdateInput, ChoreTemplateUncheckedUpdateInput>
    /**
     * Choose, which ChoreTemplate to update.
     */
    where: ChoreTemplateWhereUniqueInput
  }

  /**
   * ChoreTemplate updateMany
   */
  export type ChoreTemplateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChoreTemplates.
     */
    data: XOR<ChoreTemplateUpdateManyMutationInput, ChoreTemplateUncheckedUpdateManyInput>
    /**
     * Filter which ChoreTemplates to update
     */
    where?: ChoreTemplateWhereInput
  }

  /**
   * ChoreTemplate upsert
   */
  export type ChoreTemplateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChoreTemplate
     */
    select?: ChoreTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChoreTemplateInclude<ExtArgs> | null
    /**
     * The filter to search for the ChoreTemplate to update in case it exists.
     */
    where: ChoreTemplateWhereUniqueInput
    /**
     * In case the ChoreTemplate found by the `where` argument doesn't exist, create a new ChoreTemplate with this data.
     */
    create: XOR<ChoreTemplateCreateInput, ChoreTemplateUncheckedCreateInput>
    /**
     * In case the ChoreTemplate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChoreTemplateUpdateInput, ChoreTemplateUncheckedUpdateInput>
  }

  /**
   * ChoreTemplate delete
   */
  export type ChoreTemplateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChoreTemplate
     */
    select?: ChoreTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChoreTemplateInclude<ExtArgs> | null
    /**
     * Filter which ChoreTemplate to delete.
     */
    where: ChoreTemplateWhereUniqueInput
  }

  /**
   * ChoreTemplate deleteMany
   */
  export type ChoreTemplateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChoreTemplates to delete
     */
    where?: ChoreTemplateWhereInput
  }

  /**
   * ChoreTemplate.subtasks
   */
  export type ChoreTemplate$subtasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubtaskTemplate
     */
    select?: SubtaskTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtaskTemplateInclude<ExtArgs> | null
    where?: SubtaskTemplateWhereInput
    orderBy?: SubtaskTemplateOrderByWithRelationInput | SubtaskTemplateOrderByWithRelationInput[]
    cursor?: SubtaskTemplateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubtaskTemplateScalarFieldEnum | SubtaskTemplateScalarFieldEnum[]
  }

  /**
   * ChoreTemplate without action
   */
  export type ChoreTemplateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChoreTemplate
     */
    select?: ChoreTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChoreTemplateInclude<ExtArgs> | null
  }


  /**
   * Model SubtaskTemplate
   */

  export type AggregateSubtaskTemplate = {
    _count: SubtaskTemplateCountAggregateOutputType | null
    _min: SubtaskTemplateMinAggregateOutputType | null
    _max: SubtaskTemplateMaxAggregateOutputType | null
  }

  export type SubtaskTemplateMinAggregateOutputType = {
    id: string | null
    choreTemplateId: string | null
    title: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubtaskTemplateMaxAggregateOutputType = {
    id: string | null
    choreTemplateId: string | null
    title: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubtaskTemplateCountAggregateOutputType = {
    id: number
    choreTemplateId: number
    title: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SubtaskTemplateMinAggregateInputType = {
    id?: true
    choreTemplateId?: true
    title?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubtaskTemplateMaxAggregateInputType = {
    id?: true
    choreTemplateId?: true
    title?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubtaskTemplateCountAggregateInputType = {
    id?: true
    choreTemplateId?: true
    title?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SubtaskTemplateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubtaskTemplate to aggregate.
     */
    where?: SubtaskTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubtaskTemplates to fetch.
     */
    orderBy?: SubtaskTemplateOrderByWithRelationInput | SubtaskTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubtaskTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubtaskTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubtaskTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SubtaskTemplates
    **/
    _count?: true | SubtaskTemplateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubtaskTemplateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubtaskTemplateMaxAggregateInputType
  }

  export type GetSubtaskTemplateAggregateType<T extends SubtaskTemplateAggregateArgs> = {
        [P in keyof T & keyof AggregateSubtaskTemplate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubtaskTemplate[P]>
      : GetScalarType<T[P], AggregateSubtaskTemplate[P]>
  }




  export type SubtaskTemplateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubtaskTemplateWhereInput
    orderBy?: SubtaskTemplateOrderByWithAggregationInput | SubtaskTemplateOrderByWithAggregationInput[]
    by: SubtaskTemplateScalarFieldEnum[] | SubtaskTemplateScalarFieldEnum
    having?: SubtaskTemplateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubtaskTemplateCountAggregateInputType | true
    _min?: SubtaskTemplateMinAggregateInputType
    _max?: SubtaskTemplateMaxAggregateInputType
  }

  export type SubtaskTemplateGroupByOutputType = {
    id: string
    choreTemplateId: string
    title: string
    createdAt: Date
    updatedAt: Date
    _count: SubtaskTemplateCountAggregateOutputType | null
    _min: SubtaskTemplateMinAggregateOutputType | null
    _max: SubtaskTemplateMaxAggregateOutputType | null
  }

  type GetSubtaskTemplateGroupByPayload<T extends SubtaskTemplateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubtaskTemplateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubtaskTemplateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubtaskTemplateGroupByOutputType[P]>
            : GetScalarType<T[P], SubtaskTemplateGroupByOutputType[P]>
        }
      >
    >


  export type SubtaskTemplateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    choreTemplateId?: boolean
    title?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    choreTemplate?: boolean | ChoreTemplateDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subtaskTemplate"]>

  export type SubtaskTemplateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    choreTemplateId?: boolean
    title?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    choreTemplate?: boolean | ChoreTemplateDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subtaskTemplate"]>

  export type SubtaskTemplateSelectScalar = {
    id?: boolean
    choreTemplateId?: boolean
    title?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SubtaskTemplateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    choreTemplate?: boolean | ChoreTemplateDefaultArgs<ExtArgs>
  }
  export type SubtaskTemplateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    choreTemplate?: boolean | ChoreTemplateDefaultArgs<ExtArgs>
  }

  export type $SubtaskTemplatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SubtaskTemplate"
    objects: {
      choreTemplate: Prisma.$ChoreTemplatePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      choreTemplateId: string
      title: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["subtaskTemplate"]>
    composites: {}
  }

  type SubtaskTemplateGetPayload<S extends boolean | null | undefined | SubtaskTemplateDefaultArgs> = $Result.GetResult<Prisma.$SubtaskTemplatePayload, S>

  type SubtaskTemplateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SubtaskTemplateFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SubtaskTemplateCountAggregateInputType | true
    }

  export interface SubtaskTemplateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SubtaskTemplate'], meta: { name: 'SubtaskTemplate' } }
    /**
     * Find zero or one SubtaskTemplate that matches the filter.
     * @param {SubtaskTemplateFindUniqueArgs} args - Arguments to find a SubtaskTemplate
     * @example
     * // Get one SubtaskTemplate
     * const subtaskTemplate = await prisma.subtaskTemplate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubtaskTemplateFindUniqueArgs>(args: SelectSubset<T, SubtaskTemplateFindUniqueArgs<ExtArgs>>): Prisma__SubtaskTemplateClient<$Result.GetResult<Prisma.$SubtaskTemplatePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SubtaskTemplate that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SubtaskTemplateFindUniqueOrThrowArgs} args - Arguments to find a SubtaskTemplate
     * @example
     * // Get one SubtaskTemplate
     * const subtaskTemplate = await prisma.subtaskTemplate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubtaskTemplateFindUniqueOrThrowArgs>(args: SelectSubset<T, SubtaskTemplateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubtaskTemplateClient<$Result.GetResult<Prisma.$SubtaskTemplatePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SubtaskTemplate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubtaskTemplateFindFirstArgs} args - Arguments to find a SubtaskTemplate
     * @example
     * // Get one SubtaskTemplate
     * const subtaskTemplate = await prisma.subtaskTemplate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubtaskTemplateFindFirstArgs>(args?: SelectSubset<T, SubtaskTemplateFindFirstArgs<ExtArgs>>): Prisma__SubtaskTemplateClient<$Result.GetResult<Prisma.$SubtaskTemplatePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SubtaskTemplate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubtaskTemplateFindFirstOrThrowArgs} args - Arguments to find a SubtaskTemplate
     * @example
     * // Get one SubtaskTemplate
     * const subtaskTemplate = await prisma.subtaskTemplate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubtaskTemplateFindFirstOrThrowArgs>(args?: SelectSubset<T, SubtaskTemplateFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubtaskTemplateClient<$Result.GetResult<Prisma.$SubtaskTemplatePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SubtaskTemplates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubtaskTemplateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SubtaskTemplates
     * const subtaskTemplates = await prisma.subtaskTemplate.findMany()
     * 
     * // Get first 10 SubtaskTemplates
     * const subtaskTemplates = await prisma.subtaskTemplate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subtaskTemplateWithIdOnly = await prisma.subtaskTemplate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubtaskTemplateFindManyArgs>(args?: SelectSubset<T, SubtaskTemplateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubtaskTemplatePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SubtaskTemplate.
     * @param {SubtaskTemplateCreateArgs} args - Arguments to create a SubtaskTemplate.
     * @example
     * // Create one SubtaskTemplate
     * const SubtaskTemplate = await prisma.subtaskTemplate.create({
     *   data: {
     *     // ... data to create a SubtaskTemplate
     *   }
     * })
     * 
     */
    create<T extends SubtaskTemplateCreateArgs>(args: SelectSubset<T, SubtaskTemplateCreateArgs<ExtArgs>>): Prisma__SubtaskTemplateClient<$Result.GetResult<Prisma.$SubtaskTemplatePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SubtaskTemplates.
     * @param {SubtaskTemplateCreateManyArgs} args - Arguments to create many SubtaskTemplates.
     * @example
     * // Create many SubtaskTemplates
     * const subtaskTemplate = await prisma.subtaskTemplate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubtaskTemplateCreateManyArgs>(args?: SelectSubset<T, SubtaskTemplateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SubtaskTemplates and returns the data saved in the database.
     * @param {SubtaskTemplateCreateManyAndReturnArgs} args - Arguments to create many SubtaskTemplates.
     * @example
     * // Create many SubtaskTemplates
     * const subtaskTemplate = await prisma.subtaskTemplate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SubtaskTemplates and only return the `id`
     * const subtaskTemplateWithIdOnly = await prisma.subtaskTemplate.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubtaskTemplateCreateManyAndReturnArgs>(args?: SelectSubset<T, SubtaskTemplateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubtaskTemplatePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SubtaskTemplate.
     * @param {SubtaskTemplateDeleteArgs} args - Arguments to delete one SubtaskTemplate.
     * @example
     * // Delete one SubtaskTemplate
     * const SubtaskTemplate = await prisma.subtaskTemplate.delete({
     *   where: {
     *     // ... filter to delete one SubtaskTemplate
     *   }
     * })
     * 
     */
    delete<T extends SubtaskTemplateDeleteArgs>(args: SelectSubset<T, SubtaskTemplateDeleteArgs<ExtArgs>>): Prisma__SubtaskTemplateClient<$Result.GetResult<Prisma.$SubtaskTemplatePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SubtaskTemplate.
     * @param {SubtaskTemplateUpdateArgs} args - Arguments to update one SubtaskTemplate.
     * @example
     * // Update one SubtaskTemplate
     * const subtaskTemplate = await prisma.subtaskTemplate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubtaskTemplateUpdateArgs>(args: SelectSubset<T, SubtaskTemplateUpdateArgs<ExtArgs>>): Prisma__SubtaskTemplateClient<$Result.GetResult<Prisma.$SubtaskTemplatePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SubtaskTemplates.
     * @param {SubtaskTemplateDeleteManyArgs} args - Arguments to filter SubtaskTemplates to delete.
     * @example
     * // Delete a few SubtaskTemplates
     * const { count } = await prisma.subtaskTemplate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubtaskTemplateDeleteManyArgs>(args?: SelectSubset<T, SubtaskTemplateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubtaskTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubtaskTemplateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SubtaskTemplates
     * const subtaskTemplate = await prisma.subtaskTemplate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubtaskTemplateUpdateManyArgs>(args: SelectSubset<T, SubtaskTemplateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SubtaskTemplate.
     * @param {SubtaskTemplateUpsertArgs} args - Arguments to update or create a SubtaskTemplate.
     * @example
     * // Update or create a SubtaskTemplate
     * const subtaskTemplate = await prisma.subtaskTemplate.upsert({
     *   create: {
     *     // ... data to create a SubtaskTemplate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SubtaskTemplate we want to update
     *   }
     * })
     */
    upsert<T extends SubtaskTemplateUpsertArgs>(args: SelectSubset<T, SubtaskTemplateUpsertArgs<ExtArgs>>): Prisma__SubtaskTemplateClient<$Result.GetResult<Prisma.$SubtaskTemplatePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SubtaskTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubtaskTemplateCountArgs} args - Arguments to filter SubtaskTemplates to count.
     * @example
     * // Count the number of SubtaskTemplates
     * const count = await prisma.subtaskTemplate.count({
     *   where: {
     *     // ... the filter for the SubtaskTemplates we want to count
     *   }
     * })
    **/
    count<T extends SubtaskTemplateCountArgs>(
      args?: Subset<T, SubtaskTemplateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubtaskTemplateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SubtaskTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubtaskTemplateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubtaskTemplateAggregateArgs>(args: Subset<T, SubtaskTemplateAggregateArgs>): Prisma.PrismaPromise<GetSubtaskTemplateAggregateType<T>>

    /**
     * Group by SubtaskTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubtaskTemplateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubtaskTemplateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubtaskTemplateGroupByArgs['orderBy'] }
        : { orderBy?: SubtaskTemplateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubtaskTemplateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubtaskTemplateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SubtaskTemplate model
   */
  readonly fields: SubtaskTemplateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SubtaskTemplate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubtaskTemplateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    choreTemplate<T extends ChoreTemplateDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChoreTemplateDefaultArgs<ExtArgs>>): Prisma__ChoreTemplateClient<$Result.GetResult<Prisma.$ChoreTemplatePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SubtaskTemplate model
   */ 
  interface SubtaskTemplateFieldRefs {
    readonly id: FieldRef<"SubtaskTemplate", 'String'>
    readonly choreTemplateId: FieldRef<"SubtaskTemplate", 'String'>
    readonly title: FieldRef<"SubtaskTemplate", 'String'>
    readonly createdAt: FieldRef<"SubtaskTemplate", 'DateTime'>
    readonly updatedAt: FieldRef<"SubtaskTemplate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SubtaskTemplate findUnique
   */
  export type SubtaskTemplateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubtaskTemplate
     */
    select?: SubtaskTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtaskTemplateInclude<ExtArgs> | null
    /**
     * Filter, which SubtaskTemplate to fetch.
     */
    where: SubtaskTemplateWhereUniqueInput
  }

  /**
   * SubtaskTemplate findUniqueOrThrow
   */
  export type SubtaskTemplateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubtaskTemplate
     */
    select?: SubtaskTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtaskTemplateInclude<ExtArgs> | null
    /**
     * Filter, which SubtaskTemplate to fetch.
     */
    where: SubtaskTemplateWhereUniqueInput
  }

  /**
   * SubtaskTemplate findFirst
   */
  export type SubtaskTemplateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubtaskTemplate
     */
    select?: SubtaskTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtaskTemplateInclude<ExtArgs> | null
    /**
     * Filter, which SubtaskTemplate to fetch.
     */
    where?: SubtaskTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubtaskTemplates to fetch.
     */
    orderBy?: SubtaskTemplateOrderByWithRelationInput | SubtaskTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubtaskTemplates.
     */
    cursor?: SubtaskTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubtaskTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubtaskTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubtaskTemplates.
     */
    distinct?: SubtaskTemplateScalarFieldEnum | SubtaskTemplateScalarFieldEnum[]
  }

  /**
   * SubtaskTemplate findFirstOrThrow
   */
  export type SubtaskTemplateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubtaskTemplate
     */
    select?: SubtaskTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtaskTemplateInclude<ExtArgs> | null
    /**
     * Filter, which SubtaskTemplate to fetch.
     */
    where?: SubtaskTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubtaskTemplates to fetch.
     */
    orderBy?: SubtaskTemplateOrderByWithRelationInput | SubtaskTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubtaskTemplates.
     */
    cursor?: SubtaskTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubtaskTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubtaskTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubtaskTemplates.
     */
    distinct?: SubtaskTemplateScalarFieldEnum | SubtaskTemplateScalarFieldEnum[]
  }

  /**
   * SubtaskTemplate findMany
   */
  export type SubtaskTemplateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubtaskTemplate
     */
    select?: SubtaskTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtaskTemplateInclude<ExtArgs> | null
    /**
     * Filter, which SubtaskTemplates to fetch.
     */
    where?: SubtaskTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubtaskTemplates to fetch.
     */
    orderBy?: SubtaskTemplateOrderByWithRelationInput | SubtaskTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SubtaskTemplates.
     */
    cursor?: SubtaskTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubtaskTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubtaskTemplates.
     */
    skip?: number
    distinct?: SubtaskTemplateScalarFieldEnum | SubtaskTemplateScalarFieldEnum[]
  }

  /**
   * SubtaskTemplate create
   */
  export type SubtaskTemplateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubtaskTemplate
     */
    select?: SubtaskTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtaskTemplateInclude<ExtArgs> | null
    /**
     * The data needed to create a SubtaskTemplate.
     */
    data: XOR<SubtaskTemplateCreateInput, SubtaskTemplateUncheckedCreateInput>
  }

  /**
   * SubtaskTemplate createMany
   */
  export type SubtaskTemplateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SubtaskTemplates.
     */
    data: SubtaskTemplateCreateManyInput | SubtaskTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SubtaskTemplate createManyAndReturn
   */
  export type SubtaskTemplateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubtaskTemplate
     */
    select?: SubtaskTemplateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SubtaskTemplates.
     */
    data: SubtaskTemplateCreateManyInput | SubtaskTemplateCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtaskTemplateIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SubtaskTemplate update
   */
  export type SubtaskTemplateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubtaskTemplate
     */
    select?: SubtaskTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtaskTemplateInclude<ExtArgs> | null
    /**
     * The data needed to update a SubtaskTemplate.
     */
    data: XOR<SubtaskTemplateUpdateInput, SubtaskTemplateUncheckedUpdateInput>
    /**
     * Choose, which SubtaskTemplate to update.
     */
    where: SubtaskTemplateWhereUniqueInput
  }

  /**
   * SubtaskTemplate updateMany
   */
  export type SubtaskTemplateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SubtaskTemplates.
     */
    data: XOR<SubtaskTemplateUpdateManyMutationInput, SubtaskTemplateUncheckedUpdateManyInput>
    /**
     * Filter which SubtaskTemplates to update
     */
    where?: SubtaskTemplateWhereInput
  }

  /**
   * SubtaskTemplate upsert
   */
  export type SubtaskTemplateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubtaskTemplate
     */
    select?: SubtaskTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtaskTemplateInclude<ExtArgs> | null
    /**
     * The filter to search for the SubtaskTemplate to update in case it exists.
     */
    where: SubtaskTemplateWhereUniqueInput
    /**
     * In case the SubtaskTemplate found by the `where` argument doesn't exist, create a new SubtaskTemplate with this data.
     */
    create: XOR<SubtaskTemplateCreateInput, SubtaskTemplateUncheckedCreateInput>
    /**
     * In case the SubtaskTemplate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubtaskTemplateUpdateInput, SubtaskTemplateUncheckedUpdateInput>
  }

  /**
   * SubtaskTemplate delete
   */
  export type SubtaskTemplateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubtaskTemplate
     */
    select?: SubtaskTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtaskTemplateInclude<ExtArgs> | null
    /**
     * Filter which SubtaskTemplate to delete.
     */
    where: SubtaskTemplateWhereUniqueInput
  }

  /**
   * SubtaskTemplate deleteMany
   */
  export type SubtaskTemplateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubtaskTemplates to delete
     */
    where?: SubtaskTemplateWhereInput
  }

  /**
   * SubtaskTemplate without action
   */
  export type SubtaskTemplateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubtaskTemplate
     */
    select?: SubtaskTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtaskTemplateInclude<ExtArgs> | null
  }


  /**
   * Model ChoreHistory
   */

  export type AggregateChoreHistory = {
    _count: ChoreHistoryCountAggregateOutputType | null
    _min: ChoreHistoryMinAggregateOutputType | null
    _max: ChoreHistoryMaxAggregateOutputType | null
  }

  export type ChoreHistoryMinAggregateOutputType = {
    id: string | null
    choreId: string | null
    action: $Enums.ChoreAction | null
    changedById: string | null
    changedAt: Date | null
  }

  export type ChoreHistoryMaxAggregateOutputType = {
    id: string | null
    choreId: string | null
    action: $Enums.ChoreAction | null
    changedById: string | null
    changedAt: Date | null
  }

  export type ChoreHistoryCountAggregateOutputType = {
    id: number
    choreId: number
    action: number
    changedById: number
    changedAt: number
    _all: number
  }


  export type ChoreHistoryMinAggregateInputType = {
    id?: true
    choreId?: true
    action?: true
    changedById?: true
    changedAt?: true
  }

  export type ChoreHistoryMaxAggregateInputType = {
    id?: true
    choreId?: true
    action?: true
    changedById?: true
    changedAt?: true
  }

  export type ChoreHistoryCountAggregateInputType = {
    id?: true
    choreId?: true
    action?: true
    changedById?: true
    changedAt?: true
    _all?: true
  }

  export type ChoreHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChoreHistory to aggregate.
     */
    where?: ChoreHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChoreHistories to fetch.
     */
    orderBy?: ChoreHistoryOrderByWithRelationInput | ChoreHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChoreHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChoreHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChoreHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChoreHistories
    **/
    _count?: true | ChoreHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChoreHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChoreHistoryMaxAggregateInputType
  }

  export type GetChoreHistoryAggregateType<T extends ChoreHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateChoreHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChoreHistory[P]>
      : GetScalarType<T[P], AggregateChoreHistory[P]>
  }




  export type ChoreHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChoreHistoryWhereInput
    orderBy?: ChoreHistoryOrderByWithAggregationInput | ChoreHistoryOrderByWithAggregationInput[]
    by: ChoreHistoryScalarFieldEnum[] | ChoreHistoryScalarFieldEnum
    having?: ChoreHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChoreHistoryCountAggregateInputType | true
    _min?: ChoreHistoryMinAggregateInputType
    _max?: ChoreHistoryMaxAggregateInputType
  }

  export type ChoreHistoryGroupByOutputType = {
    id: string
    choreId: string
    action: $Enums.ChoreAction
    changedById: string
    changedAt: Date
    _count: ChoreHistoryCountAggregateOutputType | null
    _min: ChoreHistoryMinAggregateOutputType | null
    _max: ChoreHistoryMaxAggregateOutputType | null
  }

  type GetChoreHistoryGroupByPayload<T extends ChoreHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChoreHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChoreHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChoreHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], ChoreHistoryGroupByOutputType[P]>
        }
      >
    >


  export type ChoreHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    choreId?: boolean
    action?: boolean
    changedById?: boolean
    changedAt?: boolean
    chore?: boolean | ChoreDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["choreHistory"]>

  export type ChoreHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    choreId?: boolean
    action?: boolean
    changedById?: boolean
    changedAt?: boolean
    chore?: boolean | ChoreDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["choreHistory"]>

  export type ChoreHistorySelectScalar = {
    id?: boolean
    choreId?: boolean
    action?: boolean
    changedById?: boolean
    changedAt?: boolean
  }

  export type ChoreHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chore?: boolean | ChoreDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ChoreHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chore?: boolean | ChoreDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ChoreHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChoreHistory"
    objects: {
      chore: Prisma.$ChorePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      choreId: string
      action: $Enums.ChoreAction
      changedById: string
      changedAt: Date
    }, ExtArgs["result"]["choreHistory"]>
    composites: {}
  }

  type ChoreHistoryGetPayload<S extends boolean | null | undefined | ChoreHistoryDefaultArgs> = $Result.GetResult<Prisma.$ChoreHistoryPayload, S>

  type ChoreHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ChoreHistoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ChoreHistoryCountAggregateInputType | true
    }

  export interface ChoreHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChoreHistory'], meta: { name: 'ChoreHistory' } }
    /**
     * Find zero or one ChoreHistory that matches the filter.
     * @param {ChoreHistoryFindUniqueArgs} args - Arguments to find a ChoreHistory
     * @example
     * // Get one ChoreHistory
     * const choreHistory = await prisma.choreHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChoreHistoryFindUniqueArgs>(args: SelectSubset<T, ChoreHistoryFindUniqueArgs<ExtArgs>>): Prisma__ChoreHistoryClient<$Result.GetResult<Prisma.$ChoreHistoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ChoreHistory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ChoreHistoryFindUniqueOrThrowArgs} args - Arguments to find a ChoreHistory
     * @example
     * // Get one ChoreHistory
     * const choreHistory = await prisma.choreHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChoreHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, ChoreHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChoreHistoryClient<$Result.GetResult<Prisma.$ChoreHistoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ChoreHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChoreHistoryFindFirstArgs} args - Arguments to find a ChoreHistory
     * @example
     * // Get one ChoreHistory
     * const choreHistory = await prisma.choreHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChoreHistoryFindFirstArgs>(args?: SelectSubset<T, ChoreHistoryFindFirstArgs<ExtArgs>>): Prisma__ChoreHistoryClient<$Result.GetResult<Prisma.$ChoreHistoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ChoreHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChoreHistoryFindFirstOrThrowArgs} args - Arguments to find a ChoreHistory
     * @example
     * // Get one ChoreHistory
     * const choreHistory = await prisma.choreHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChoreHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, ChoreHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChoreHistoryClient<$Result.GetResult<Prisma.$ChoreHistoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ChoreHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChoreHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChoreHistories
     * const choreHistories = await prisma.choreHistory.findMany()
     * 
     * // Get first 10 ChoreHistories
     * const choreHistories = await prisma.choreHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const choreHistoryWithIdOnly = await prisma.choreHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChoreHistoryFindManyArgs>(args?: SelectSubset<T, ChoreHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChoreHistoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ChoreHistory.
     * @param {ChoreHistoryCreateArgs} args - Arguments to create a ChoreHistory.
     * @example
     * // Create one ChoreHistory
     * const ChoreHistory = await prisma.choreHistory.create({
     *   data: {
     *     // ... data to create a ChoreHistory
     *   }
     * })
     * 
     */
    create<T extends ChoreHistoryCreateArgs>(args: SelectSubset<T, ChoreHistoryCreateArgs<ExtArgs>>): Prisma__ChoreHistoryClient<$Result.GetResult<Prisma.$ChoreHistoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ChoreHistories.
     * @param {ChoreHistoryCreateManyArgs} args - Arguments to create many ChoreHistories.
     * @example
     * // Create many ChoreHistories
     * const choreHistory = await prisma.choreHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChoreHistoryCreateManyArgs>(args?: SelectSubset<T, ChoreHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChoreHistories and returns the data saved in the database.
     * @param {ChoreHistoryCreateManyAndReturnArgs} args - Arguments to create many ChoreHistories.
     * @example
     * // Create many ChoreHistories
     * const choreHistory = await prisma.choreHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChoreHistories and only return the `id`
     * const choreHistoryWithIdOnly = await prisma.choreHistory.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChoreHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, ChoreHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChoreHistoryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ChoreHistory.
     * @param {ChoreHistoryDeleteArgs} args - Arguments to delete one ChoreHistory.
     * @example
     * // Delete one ChoreHistory
     * const ChoreHistory = await prisma.choreHistory.delete({
     *   where: {
     *     // ... filter to delete one ChoreHistory
     *   }
     * })
     * 
     */
    delete<T extends ChoreHistoryDeleteArgs>(args: SelectSubset<T, ChoreHistoryDeleteArgs<ExtArgs>>): Prisma__ChoreHistoryClient<$Result.GetResult<Prisma.$ChoreHistoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ChoreHistory.
     * @param {ChoreHistoryUpdateArgs} args - Arguments to update one ChoreHistory.
     * @example
     * // Update one ChoreHistory
     * const choreHistory = await prisma.choreHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChoreHistoryUpdateArgs>(args: SelectSubset<T, ChoreHistoryUpdateArgs<ExtArgs>>): Prisma__ChoreHistoryClient<$Result.GetResult<Prisma.$ChoreHistoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ChoreHistories.
     * @param {ChoreHistoryDeleteManyArgs} args - Arguments to filter ChoreHistories to delete.
     * @example
     * // Delete a few ChoreHistories
     * const { count } = await prisma.choreHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChoreHistoryDeleteManyArgs>(args?: SelectSubset<T, ChoreHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChoreHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChoreHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChoreHistories
     * const choreHistory = await prisma.choreHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChoreHistoryUpdateManyArgs>(args: SelectSubset<T, ChoreHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ChoreHistory.
     * @param {ChoreHistoryUpsertArgs} args - Arguments to update or create a ChoreHistory.
     * @example
     * // Update or create a ChoreHistory
     * const choreHistory = await prisma.choreHistory.upsert({
     *   create: {
     *     // ... data to create a ChoreHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChoreHistory we want to update
     *   }
     * })
     */
    upsert<T extends ChoreHistoryUpsertArgs>(args: SelectSubset<T, ChoreHistoryUpsertArgs<ExtArgs>>): Prisma__ChoreHistoryClient<$Result.GetResult<Prisma.$ChoreHistoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ChoreHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChoreHistoryCountArgs} args - Arguments to filter ChoreHistories to count.
     * @example
     * // Count the number of ChoreHistories
     * const count = await prisma.choreHistory.count({
     *   where: {
     *     // ... the filter for the ChoreHistories we want to count
     *   }
     * })
    **/
    count<T extends ChoreHistoryCountArgs>(
      args?: Subset<T, ChoreHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChoreHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChoreHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChoreHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChoreHistoryAggregateArgs>(args: Subset<T, ChoreHistoryAggregateArgs>): Prisma.PrismaPromise<GetChoreHistoryAggregateType<T>>

    /**
     * Group by ChoreHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChoreHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChoreHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChoreHistoryGroupByArgs['orderBy'] }
        : { orderBy?: ChoreHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChoreHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChoreHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChoreHistory model
   */
  readonly fields: ChoreHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChoreHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChoreHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    chore<T extends ChoreDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChoreDefaultArgs<ExtArgs>>): Prisma__ChoreClient<$Result.GetResult<Prisma.$ChorePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChoreHistory model
   */ 
  interface ChoreHistoryFieldRefs {
    readonly id: FieldRef<"ChoreHistory", 'String'>
    readonly choreId: FieldRef<"ChoreHistory", 'String'>
    readonly action: FieldRef<"ChoreHistory", 'ChoreAction'>
    readonly changedById: FieldRef<"ChoreHistory", 'String'>
    readonly changedAt: FieldRef<"ChoreHistory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ChoreHistory findUnique
   */
  export type ChoreHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChoreHistory
     */
    select?: ChoreHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChoreHistoryInclude<ExtArgs> | null
    /**
     * Filter, which ChoreHistory to fetch.
     */
    where: ChoreHistoryWhereUniqueInput
  }

  /**
   * ChoreHistory findUniqueOrThrow
   */
  export type ChoreHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChoreHistory
     */
    select?: ChoreHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChoreHistoryInclude<ExtArgs> | null
    /**
     * Filter, which ChoreHistory to fetch.
     */
    where: ChoreHistoryWhereUniqueInput
  }

  /**
   * ChoreHistory findFirst
   */
  export type ChoreHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChoreHistory
     */
    select?: ChoreHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChoreHistoryInclude<ExtArgs> | null
    /**
     * Filter, which ChoreHistory to fetch.
     */
    where?: ChoreHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChoreHistories to fetch.
     */
    orderBy?: ChoreHistoryOrderByWithRelationInput | ChoreHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChoreHistories.
     */
    cursor?: ChoreHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChoreHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChoreHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChoreHistories.
     */
    distinct?: ChoreHistoryScalarFieldEnum | ChoreHistoryScalarFieldEnum[]
  }

  /**
   * ChoreHistory findFirstOrThrow
   */
  export type ChoreHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChoreHistory
     */
    select?: ChoreHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChoreHistoryInclude<ExtArgs> | null
    /**
     * Filter, which ChoreHistory to fetch.
     */
    where?: ChoreHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChoreHistories to fetch.
     */
    orderBy?: ChoreHistoryOrderByWithRelationInput | ChoreHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChoreHistories.
     */
    cursor?: ChoreHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChoreHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChoreHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChoreHistories.
     */
    distinct?: ChoreHistoryScalarFieldEnum | ChoreHistoryScalarFieldEnum[]
  }

  /**
   * ChoreHistory findMany
   */
  export type ChoreHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChoreHistory
     */
    select?: ChoreHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChoreHistoryInclude<ExtArgs> | null
    /**
     * Filter, which ChoreHistories to fetch.
     */
    where?: ChoreHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChoreHistories to fetch.
     */
    orderBy?: ChoreHistoryOrderByWithRelationInput | ChoreHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChoreHistories.
     */
    cursor?: ChoreHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChoreHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChoreHistories.
     */
    skip?: number
    distinct?: ChoreHistoryScalarFieldEnum | ChoreHistoryScalarFieldEnum[]
  }

  /**
   * ChoreHistory create
   */
  export type ChoreHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChoreHistory
     */
    select?: ChoreHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChoreHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a ChoreHistory.
     */
    data: XOR<ChoreHistoryCreateInput, ChoreHistoryUncheckedCreateInput>
  }

  /**
   * ChoreHistory createMany
   */
  export type ChoreHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChoreHistories.
     */
    data: ChoreHistoryCreateManyInput | ChoreHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChoreHistory createManyAndReturn
   */
  export type ChoreHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChoreHistory
     */
    select?: ChoreHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ChoreHistories.
     */
    data: ChoreHistoryCreateManyInput | ChoreHistoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChoreHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChoreHistory update
   */
  export type ChoreHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChoreHistory
     */
    select?: ChoreHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChoreHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a ChoreHistory.
     */
    data: XOR<ChoreHistoryUpdateInput, ChoreHistoryUncheckedUpdateInput>
    /**
     * Choose, which ChoreHistory to update.
     */
    where: ChoreHistoryWhereUniqueInput
  }

  /**
   * ChoreHistory updateMany
   */
  export type ChoreHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChoreHistories.
     */
    data: XOR<ChoreHistoryUpdateManyMutationInput, ChoreHistoryUncheckedUpdateManyInput>
    /**
     * Filter which ChoreHistories to update
     */
    where?: ChoreHistoryWhereInput
  }

  /**
   * ChoreHistory upsert
   */
  export type ChoreHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChoreHistory
     */
    select?: ChoreHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChoreHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the ChoreHistory to update in case it exists.
     */
    where: ChoreHistoryWhereUniqueInput
    /**
     * In case the ChoreHistory found by the `where` argument doesn't exist, create a new ChoreHistory with this data.
     */
    create: XOR<ChoreHistoryCreateInput, ChoreHistoryUncheckedCreateInput>
    /**
     * In case the ChoreHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChoreHistoryUpdateInput, ChoreHistoryUncheckedUpdateInput>
  }

  /**
   * ChoreHistory delete
   */
  export type ChoreHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChoreHistory
     */
    select?: ChoreHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChoreHistoryInclude<ExtArgs> | null
    /**
     * Filter which ChoreHistory to delete.
     */
    where: ChoreHistoryWhereUniqueInput
  }

  /**
   * ChoreHistory deleteMany
   */
  export type ChoreHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChoreHistories to delete
     */
    where?: ChoreHistoryWhereInput
  }

  /**
   * ChoreHistory without action
   */
  export type ChoreHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChoreHistory
     */
    select?: ChoreHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChoreHistoryInclude<ExtArgs> | null
  }


  /**
   * Model Expense
   */

  export type AggregateExpense = {
    _count: ExpenseCountAggregateOutputType | null
    _avg: ExpenseAvgAggregateOutputType | null
    _sum: ExpenseSumAggregateOutputType | null
    _min: ExpenseMinAggregateOutputType | null
    _max: ExpenseMaxAggregateOutputType | null
  }

  export type ExpenseAvgAggregateOutputType = {
    amount: number | null
  }

  export type ExpenseSumAggregateOutputType = {
    amount: number | null
  }

  export type ExpenseMinAggregateOutputType = {
    id: string | null
    householdId: string | null
    amount: number | null
    description: string | null
    paidById: string | null
    createdAt: Date | null
    updatedAt: Date | null
    dueDate: Date | null
    deletedAt: Date | null
    category: $Enums.ExpenseCategory | null
  }

  export type ExpenseMaxAggregateOutputType = {
    id: string | null
    householdId: string | null
    amount: number | null
    description: string | null
    paidById: string | null
    createdAt: Date | null
    updatedAt: Date | null
    dueDate: Date | null
    deletedAt: Date | null
    category: $Enums.ExpenseCategory | null
  }

  export type ExpenseCountAggregateOutputType = {
    id: number
    householdId: number
    amount: number
    description: number
    paidById: number
    createdAt: number
    updatedAt: number
    dueDate: number
    deletedAt: number
    category: number
    _all: number
  }


  export type ExpenseAvgAggregateInputType = {
    amount?: true
  }

  export type ExpenseSumAggregateInputType = {
    amount?: true
  }

  export type ExpenseMinAggregateInputType = {
    id?: true
    householdId?: true
    amount?: true
    description?: true
    paidById?: true
    createdAt?: true
    updatedAt?: true
    dueDate?: true
    deletedAt?: true
    category?: true
  }

  export type ExpenseMaxAggregateInputType = {
    id?: true
    householdId?: true
    amount?: true
    description?: true
    paidById?: true
    createdAt?: true
    updatedAt?: true
    dueDate?: true
    deletedAt?: true
    category?: true
  }

  export type ExpenseCountAggregateInputType = {
    id?: true
    householdId?: true
    amount?: true
    description?: true
    paidById?: true
    createdAt?: true
    updatedAt?: true
    dueDate?: true
    deletedAt?: true
    category?: true
    _all?: true
  }

  export type ExpenseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Expense to aggregate.
     */
    where?: ExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expenses to fetch.
     */
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Expenses
    **/
    _count?: true | ExpenseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExpenseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExpenseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExpenseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExpenseMaxAggregateInputType
  }

  export type GetExpenseAggregateType<T extends ExpenseAggregateArgs> = {
        [P in keyof T & keyof AggregateExpense]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExpense[P]>
      : GetScalarType<T[P], AggregateExpense[P]>
  }




  export type ExpenseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpenseWhereInput
    orderBy?: ExpenseOrderByWithAggregationInput | ExpenseOrderByWithAggregationInput[]
    by: ExpenseScalarFieldEnum[] | ExpenseScalarFieldEnum
    having?: ExpenseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExpenseCountAggregateInputType | true
    _avg?: ExpenseAvgAggregateInputType
    _sum?: ExpenseSumAggregateInputType
    _min?: ExpenseMinAggregateInputType
    _max?: ExpenseMaxAggregateInputType
  }

  export type ExpenseGroupByOutputType = {
    id: string
    householdId: string
    amount: number
    description: string
    paidById: string
    createdAt: Date
    updatedAt: Date
    dueDate: Date | null
    deletedAt: Date | null
    category: $Enums.ExpenseCategory
    _count: ExpenseCountAggregateOutputType | null
    _avg: ExpenseAvgAggregateOutputType | null
    _sum: ExpenseSumAggregateOutputType | null
    _min: ExpenseMinAggregateOutputType | null
    _max: ExpenseMaxAggregateOutputType | null
  }

  type GetExpenseGroupByPayload<T extends ExpenseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExpenseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExpenseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExpenseGroupByOutputType[P]>
            : GetScalarType<T[P], ExpenseGroupByOutputType[P]>
        }
      >
    >


  export type ExpenseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    householdId?: boolean
    amount?: boolean
    description?: boolean
    paidById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    dueDate?: boolean
    deletedAt?: boolean
    category?: boolean
    household?: boolean | HouseholdDefaultArgs<ExtArgs>
    paidBy?: boolean | UserDefaultArgs<ExtArgs>
    splits?: boolean | Expense$splitsArgs<ExtArgs>
    transactions?: boolean | Expense$transactionsArgs<ExtArgs>
    receipts?: boolean | Expense$receiptsArgs<ExtArgs>
    history?: boolean | Expense$historyArgs<ExtArgs>
    _count?: boolean | ExpenseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["expense"]>

  export type ExpenseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    householdId?: boolean
    amount?: boolean
    description?: boolean
    paidById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    dueDate?: boolean
    deletedAt?: boolean
    category?: boolean
    household?: boolean | HouseholdDefaultArgs<ExtArgs>
    paidBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["expense"]>

  export type ExpenseSelectScalar = {
    id?: boolean
    householdId?: boolean
    amount?: boolean
    description?: boolean
    paidById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    dueDate?: boolean
    deletedAt?: boolean
    category?: boolean
  }

  export type ExpenseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    household?: boolean | HouseholdDefaultArgs<ExtArgs>
    paidBy?: boolean | UserDefaultArgs<ExtArgs>
    splits?: boolean | Expense$splitsArgs<ExtArgs>
    transactions?: boolean | Expense$transactionsArgs<ExtArgs>
    receipts?: boolean | Expense$receiptsArgs<ExtArgs>
    history?: boolean | Expense$historyArgs<ExtArgs>
    _count?: boolean | ExpenseCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ExpenseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    household?: boolean | HouseholdDefaultArgs<ExtArgs>
    paidBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ExpensePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Expense"
    objects: {
      household: Prisma.$HouseholdPayload<ExtArgs>
      paidBy: Prisma.$UserPayload<ExtArgs>
      splits: Prisma.$ExpenseSplitPayload<ExtArgs>[]
      transactions: Prisma.$TransactionPayload<ExtArgs>[]
      receipts: Prisma.$ReceiptPayload<ExtArgs>[]
      history: Prisma.$ExpenseHistoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      householdId: string
      amount: number
      description: string
      paidById: string
      createdAt: Date
      updatedAt: Date
      dueDate: Date | null
      deletedAt: Date | null
      category: $Enums.ExpenseCategory
    }, ExtArgs["result"]["expense"]>
    composites: {}
  }

  type ExpenseGetPayload<S extends boolean | null | undefined | ExpenseDefaultArgs> = $Result.GetResult<Prisma.$ExpensePayload, S>

  type ExpenseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ExpenseFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ExpenseCountAggregateInputType | true
    }

  export interface ExpenseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Expense'], meta: { name: 'Expense' } }
    /**
     * Find zero or one Expense that matches the filter.
     * @param {ExpenseFindUniqueArgs} args - Arguments to find a Expense
     * @example
     * // Get one Expense
     * const expense = await prisma.expense.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExpenseFindUniqueArgs>(args: SelectSubset<T, ExpenseFindUniqueArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Expense that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ExpenseFindUniqueOrThrowArgs} args - Arguments to find a Expense
     * @example
     * // Get one Expense
     * const expense = await prisma.expense.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExpenseFindUniqueOrThrowArgs>(args: SelectSubset<T, ExpenseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Expense that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseFindFirstArgs} args - Arguments to find a Expense
     * @example
     * // Get one Expense
     * const expense = await prisma.expense.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExpenseFindFirstArgs>(args?: SelectSubset<T, ExpenseFindFirstArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Expense that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseFindFirstOrThrowArgs} args - Arguments to find a Expense
     * @example
     * // Get one Expense
     * const expense = await prisma.expense.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExpenseFindFirstOrThrowArgs>(args?: SelectSubset<T, ExpenseFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Expenses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Expenses
     * const expenses = await prisma.expense.findMany()
     * 
     * // Get first 10 Expenses
     * const expenses = await prisma.expense.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const expenseWithIdOnly = await prisma.expense.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExpenseFindManyArgs>(args?: SelectSubset<T, ExpenseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Expense.
     * @param {ExpenseCreateArgs} args - Arguments to create a Expense.
     * @example
     * // Create one Expense
     * const Expense = await prisma.expense.create({
     *   data: {
     *     // ... data to create a Expense
     *   }
     * })
     * 
     */
    create<T extends ExpenseCreateArgs>(args: SelectSubset<T, ExpenseCreateArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Expenses.
     * @param {ExpenseCreateManyArgs} args - Arguments to create many Expenses.
     * @example
     * // Create many Expenses
     * const expense = await prisma.expense.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExpenseCreateManyArgs>(args?: SelectSubset<T, ExpenseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Expenses and returns the data saved in the database.
     * @param {ExpenseCreateManyAndReturnArgs} args - Arguments to create many Expenses.
     * @example
     * // Create many Expenses
     * const expense = await prisma.expense.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Expenses and only return the `id`
     * const expenseWithIdOnly = await prisma.expense.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExpenseCreateManyAndReturnArgs>(args?: SelectSubset<T, ExpenseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Expense.
     * @param {ExpenseDeleteArgs} args - Arguments to delete one Expense.
     * @example
     * // Delete one Expense
     * const Expense = await prisma.expense.delete({
     *   where: {
     *     // ... filter to delete one Expense
     *   }
     * })
     * 
     */
    delete<T extends ExpenseDeleteArgs>(args: SelectSubset<T, ExpenseDeleteArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Expense.
     * @param {ExpenseUpdateArgs} args - Arguments to update one Expense.
     * @example
     * // Update one Expense
     * const expense = await prisma.expense.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExpenseUpdateArgs>(args: SelectSubset<T, ExpenseUpdateArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Expenses.
     * @param {ExpenseDeleteManyArgs} args - Arguments to filter Expenses to delete.
     * @example
     * // Delete a few Expenses
     * const { count } = await prisma.expense.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExpenseDeleteManyArgs>(args?: SelectSubset<T, ExpenseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Expenses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Expenses
     * const expense = await prisma.expense.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExpenseUpdateManyArgs>(args: SelectSubset<T, ExpenseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Expense.
     * @param {ExpenseUpsertArgs} args - Arguments to update or create a Expense.
     * @example
     * // Update or create a Expense
     * const expense = await prisma.expense.upsert({
     *   create: {
     *     // ... data to create a Expense
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Expense we want to update
     *   }
     * })
     */
    upsert<T extends ExpenseUpsertArgs>(args: SelectSubset<T, ExpenseUpsertArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Expenses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseCountArgs} args - Arguments to filter Expenses to count.
     * @example
     * // Count the number of Expenses
     * const count = await prisma.expense.count({
     *   where: {
     *     // ... the filter for the Expenses we want to count
     *   }
     * })
    **/
    count<T extends ExpenseCountArgs>(
      args?: Subset<T, ExpenseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExpenseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Expense.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExpenseAggregateArgs>(args: Subset<T, ExpenseAggregateArgs>): Prisma.PrismaPromise<GetExpenseAggregateType<T>>

    /**
     * Group by Expense.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExpenseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExpenseGroupByArgs['orderBy'] }
        : { orderBy?: ExpenseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExpenseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExpenseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Expense model
   */
  readonly fields: ExpenseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Expense.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExpenseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    household<T extends HouseholdDefaultArgs<ExtArgs> = {}>(args?: Subset<T, HouseholdDefaultArgs<ExtArgs>>): Prisma__HouseholdClient<$Result.GetResult<Prisma.$HouseholdPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    paidBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    splits<T extends Expense$splitsArgs<ExtArgs> = {}>(args?: Subset<T, Expense$splitsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpenseSplitPayload<ExtArgs>, T, "findMany"> | Null>
    transactions<T extends Expense$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, Expense$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany"> | Null>
    receipts<T extends Expense$receiptsArgs<ExtArgs> = {}>(args?: Subset<T, Expense$receiptsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReceiptPayload<ExtArgs>, T, "findMany"> | Null>
    history<T extends Expense$historyArgs<ExtArgs> = {}>(args?: Subset<T, Expense$historyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpenseHistoryPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Expense model
   */ 
  interface ExpenseFieldRefs {
    readonly id: FieldRef<"Expense", 'String'>
    readonly householdId: FieldRef<"Expense", 'String'>
    readonly amount: FieldRef<"Expense", 'Float'>
    readonly description: FieldRef<"Expense", 'String'>
    readonly paidById: FieldRef<"Expense", 'String'>
    readonly createdAt: FieldRef<"Expense", 'DateTime'>
    readonly updatedAt: FieldRef<"Expense", 'DateTime'>
    readonly dueDate: FieldRef<"Expense", 'DateTime'>
    readonly deletedAt: FieldRef<"Expense", 'DateTime'>
    readonly category: FieldRef<"Expense", 'ExpenseCategory'>
  }
    

  // Custom InputTypes
  /**
   * Expense findUnique
   */
  export type ExpenseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * Filter, which Expense to fetch.
     */
    where: ExpenseWhereUniqueInput
  }

  /**
   * Expense findUniqueOrThrow
   */
  export type ExpenseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * Filter, which Expense to fetch.
     */
    where: ExpenseWhereUniqueInput
  }

  /**
   * Expense findFirst
   */
  export type ExpenseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * Filter, which Expense to fetch.
     */
    where?: ExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expenses to fetch.
     */
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Expenses.
     */
    cursor?: ExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Expenses.
     */
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }

  /**
   * Expense findFirstOrThrow
   */
  export type ExpenseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * Filter, which Expense to fetch.
     */
    where?: ExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expenses to fetch.
     */
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Expenses.
     */
    cursor?: ExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Expenses.
     */
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }

  /**
   * Expense findMany
   */
  export type ExpenseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * Filter, which Expenses to fetch.
     */
    where?: ExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expenses to fetch.
     */
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Expenses.
     */
    cursor?: ExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expenses.
     */
    skip?: number
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }

  /**
   * Expense create
   */
  export type ExpenseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * The data needed to create a Expense.
     */
    data: XOR<ExpenseCreateInput, ExpenseUncheckedCreateInput>
  }

  /**
   * Expense createMany
   */
  export type ExpenseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Expenses.
     */
    data: ExpenseCreateManyInput | ExpenseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Expense createManyAndReturn
   */
  export type ExpenseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Expenses.
     */
    data: ExpenseCreateManyInput | ExpenseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Expense update
   */
  export type ExpenseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * The data needed to update a Expense.
     */
    data: XOR<ExpenseUpdateInput, ExpenseUncheckedUpdateInput>
    /**
     * Choose, which Expense to update.
     */
    where: ExpenseWhereUniqueInput
  }

  /**
   * Expense updateMany
   */
  export type ExpenseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Expenses.
     */
    data: XOR<ExpenseUpdateManyMutationInput, ExpenseUncheckedUpdateManyInput>
    /**
     * Filter which Expenses to update
     */
    where?: ExpenseWhereInput
  }

  /**
   * Expense upsert
   */
  export type ExpenseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * The filter to search for the Expense to update in case it exists.
     */
    where: ExpenseWhereUniqueInput
    /**
     * In case the Expense found by the `where` argument doesn't exist, create a new Expense with this data.
     */
    create: XOR<ExpenseCreateInput, ExpenseUncheckedCreateInput>
    /**
     * In case the Expense was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExpenseUpdateInput, ExpenseUncheckedUpdateInput>
  }

  /**
   * Expense delete
   */
  export type ExpenseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * Filter which Expense to delete.
     */
    where: ExpenseWhereUniqueInput
  }

  /**
   * Expense deleteMany
   */
  export type ExpenseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Expenses to delete
     */
    where?: ExpenseWhereInput
  }

  /**
   * Expense.splits
   */
  export type Expense$splitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseSplit
     */
    select?: ExpenseSplitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseSplitInclude<ExtArgs> | null
    where?: ExpenseSplitWhereInput
    orderBy?: ExpenseSplitOrderByWithRelationInput | ExpenseSplitOrderByWithRelationInput[]
    cursor?: ExpenseSplitWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExpenseSplitScalarFieldEnum | ExpenseSplitScalarFieldEnum[]
  }

  /**
   * Expense.transactions
   */
  export type Expense$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Expense.receipts
   */
  export type Expense$receiptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receipt
     */
    select?: ReceiptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceiptInclude<ExtArgs> | null
    where?: ReceiptWhereInput
    orderBy?: ReceiptOrderByWithRelationInput | ReceiptOrderByWithRelationInput[]
    cursor?: ReceiptWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReceiptScalarFieldEnum | ReceiptScalarFieldEnum[]
  }

  /**
   * Expense.history
   */
  export type Expense$historyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseHistory
     */
    select?: ExpenseHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseHistoryInclude<ExtArgs> | null
    where?: ExpenseHistoryWhereInput
    orderBy?: ExpenseHistoryOrderByWithRelationInput | ExpenseHistoryOrderByWithRelationInput[]
    cursor?: ExpenseHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExpenseHistoryScalarFieldEnum | ExpenseHistoryScalarFieldEnum[]
  }

  /**
   * Expense without action
   */
  export type ExpenseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
  }


  /**
   * Model ExpenseSplit
   */

  export type AggregateExpenseSplit = {
    _count: ExpenseSplitCountAggregateOutputType | null
    _avg: ExpenseSplitAvgAggregateOutputType | null
    _sum: ExpenseSplitSumAggregateOutputType | null
    _min: ExpenseSplitMinAggregateOutputType | null
    _max: ExpenseSplitMaxAggregateOutputType | null
  }

  export type ExpenseSplitAvgAggregateOutputType = {
    amount: number | null
  }

  export type ExpenseSplitSumAggregateOutputType = {
    amount: number | null
  }

  export type ExpenseSplitMinAggregateOutputType = {
    id: string | null
    expenseId: string | null
    userId: string | null
    amount: number | null
  }

  export type ExpenseSplitMaxAggregateOutputType = {
    id: string | null
    expenseId: string | null
    userId: string | null
    amount: number | null
  }

  export type ExpenseSplitCountAggregateOutputType = {
    id: number
    expenseId: number
    userId: number
    amount: number
    _all: number
  }


  export type ExpenseSplitAvgAggregateInputType = {
    amount?: true
  }

  export type ExpenseSplitSumAggregateInputType = {
    amount?: true
  }

  export type ExpenseSplitMinAggregateInputType = {
    id?: true
    expenseId?: true
    userId?: true
    amount?: true
  }

  export type ExpenseSplitMaxAggregateInputType = {
    id?: true
    expenseId?: true
    userId?: true
    amount?: true
  }

  export type ExpenseSplitCountAggregateInputType = {
    id?: true
    expenseId?: true
    userId?: true
    amount?: true
    _all?: true
  }

  export type ExpenseSplitAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExpenseSplit to aggregate.
     */
    where?: ExpenseSplitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExpenseSplits to fetch.
     */
    orderBy?: ExpenseSplitOrderByWithRelationInput | ExpenseSplitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExpenseSplitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExpenseSplits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExpenseSplits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ExpenseSplits
    **/
    _count?: true | ExpenseSplitCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExpenseSplitAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExpenseSplitSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExpenseSplitMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExpenseSplitMaxAggregateInputType
  }

  export type GetExpenseSplitAggregateType<T extends ExpenseSplitAggregateArgs> = {
        [P in keyof T & keyof AggregateExpenseSplit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExpenseSplit[P]>
      : GetScalarType<T[P], AggregateExpenseSplit[P]>
  }




  export type ExpenseSplitGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpenseSplitWhereInput
    orderBy?: ExpenseSplitOrderByWithAggregationInput | ExpenseSplitOrderByWithAggregationInput[]
    by: ExpenseSplitScalarFieldEnum[] | ExpenseSplitScalarFieldEnum
    having?: ExpenseSplitScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExpenseSplitCountAggregateInputType | true
    _avg?: ExpenseSplitAvgAggregateInputType
    _sum?: ExpenseSplitSumAggregateInputType
    _min?: ExpenseSplitMinAggregateInputType
    _max?: ExpenseSplitMaxAggregateInputType
  }

  export type ExpenseSplitGroupByOutputType = {
    id: string
    expenseId: string
    userId: string
    amount: number
    _count: ExpenseSplitCountAggregateOutputType | null
    _avg: ExpenseSplitAvgAggregateOutputType | null
    _sum: ExpenseSplitSumAggregateOutputType | null
    _min: ExpenseSplitMinAggregateOutputType | null
    _max: ExpenseSplitMaxAggregateOutputType | null
  }

  type GetExpenseSplitGroupByPayload<T extends ExpenseSplitGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExpenseSplitGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExpenseSplitGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExpenseSplitGroupByOutputType[P]>
            : GetScalarType<T[P], ExpenseSplitGroupByOutputType[P]>
        }
      >
    >


  export type ExpenseSplitSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    expenseId?: boolean
    userId?: boolean
    amount?: boolean
    expense?: boolean | ExpenseDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["expenseSplit"]>

  export type ExpenseSplitSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    expenseId?: boolean
    userId?: boolean
    amount?: boolean
    expense?: boolean | ExpenseDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["expenseSplit"]>

  export type ExpenseSplitSelectScalar = {
    id?: boolean
    expenseId?: boolean
    userId?: boolean
    amount?: boolean
  }

  export type ExpenseSplitInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    expense?: boolean | ExpenseDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ExpenseSplitIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    expense?: boolean | ExpenseDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ExpenseSplitPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ExpenseSplit"
    objects: {
      expense: Prisma.$ExpensePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      expenseId: string
      userId: string
      amount: number
    }, ExtArgs["result"]["expenseSplit"]>
    composites: {}
  }

  type ExpenseSplitGetPayload<S extends boolean | null | undefined | ExpenseSplitDefaultArgs> = $Result.GetResult<Prisma.$ExpenseSplitPayload, S>

  type ExpenseSplitCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ExpenseSplitFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ExpenseSplitCountAggregateInputType | true
    }

  export interface ExpenseSplitDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ExpenseSplit'], meta: { name: 'ExpenseSplit' } }
    /**
     * Find zero or one ExpenseSplit that matches the filter.
     * @param {ExpenseSplitFindUniqueArgs} args - Arguments to find a ExpenseSplit
     * @example
     * // Get one ExpenseSplit
     * const expenseSplit = await prisma.expenseSplit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExpenseSplitFindUniqueArgs>(args: SelectSubset<T, ExpenseSplitFindUniqueArgs<ExtArgs>>): Prisma__ExpenseSplitClient<$Result.GetResult<Prisma.$ExpenseSplitPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ExpenseSplit that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ExpenseSplitFindUniqueOrThrowArgs} args - Arguments to find a ExpenseSplit
     * @example
     * // Get one ExpenseSplit
     * const expenseSplit = await prisma.expenseSplit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExpenseSplitFindUniqueOrThrowArgs>(args: SelectSubset<T, ExpenseSplitFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExpenseSplitClient<$Result.GetResult<Prisma.$ExpenseSplitPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ExpenseSplit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseSplitFindFirstArgs} args - Arguments to find a ExpenseSplit
     * @example
     * // Get one ExpenseSplit
     * const expenseSplit = await prisma.expenseSplit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExpenseSplitFindFirstArgs>(args?: SelectSubset<T, ExpenseSplitFindFirstArgs<ExtArgs>>): Prisma__ExpenseSplitClient<$Result.GetResult<Prisma.$ExpenseSplitPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ExpenseSplit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseSplitFindFirstOrThrowArgs} args - Arguments to find a ExpenseSplit
     * @example
     * // Get one ExpenseSplit
     * const expenseSplit = await prisma.expenseSplit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExpenseSplitFindFirstOrThrowArgs>(args?: SelectSubset<T, ExpenseSplitFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExpenseSplitClient<$Result.GetResult<Prisma.$ExpenseSplitPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ExpenseSplits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseSplitFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExpenseSplits
     * const expenseSplits = await prisma.expenseSplit.findMany()
     * 
     * // Get first 10 ExpenseSplits
     * const expenseSplits = await prisma.expenseSplit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const expenseSplitWithIdOnly = await prisma.expenseSplit.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExpenseSplitFindManyArgs>(args?: SelectSubset<T, ExpenseSplitFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpenseSplitPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ExpenseSplit.
     * @param {ExpenseSplitCreateArgs} args - Arguments to create a ExpenseSplit.
     * @example
     * // Create one ExpenseSplit
     * const ExpenseSplit = await prisma.expenseSplit.create({
     *   data: {
     *     // ... data to create a ExpenseSplit
     *   }
     * })
     * 
     */
    create<T extends ExpenseSplitCreateArgs>(args: SelectSubset<T, ExpenseSplitCreateArgs<ExtArgs>>): Prisma__ExpenseSplitClient<$Result.GetResult<Prisma.$ExpenseSplitPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ExpenseSplits.
     * @param {ExpenseSplitCreateManyArgs} args - Arguments to create many ExpenseSplits.
     * @example
     * // Create many ExpenseSplits
     * const expenseSplit = await prisma.expenseSplit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExpenseSplitCreateManyArgs>(args?: SelectSubset<T, ExpenseSplitCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ExpenseSplits and returns the data saved in the database.
     * @param {ExpenseSplitCreateManyAndReturnArgs} args - Arguments to create many ExpenseSplits.
     * @example
     * // Create many ExpenseSplits
     * const expenseSplit = await prisma.expenseSplit.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ExpenseSplits and only return the `id`
     * const expenseSplitWithIdOnly = await prisma.expenseSplit.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExpenseSplitCreateManyAndReturnArgs>(args?: SelectSubset<T, ExpenseSplitCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpenseSplitPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ExpenseSplit.
     * @param {ExpenseSplitDeleteArgs} args - Arguments to delete one ExpenseSplit.
     * @example
     * // Delete one ExpenseSplit
     * const ExpenseSplit = await prisma.expenseSplit.delete({
     *   where: {
     *     // ... filter to delete one ExpenseSplit
     *   }
     * })
     * 
     */
    delete<T extends ExpenseSplitDeleteArgs>(args: SelectSubset<T, ExpenseSplitDeleteArgs<ExtArgs>>): Prisma__ExpenseSplitClient<$Result.GetResult<Prisma.$ExpenseSplitPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ExpenseSplit.
     * @param {ExpenseSplitUpdateArgs} args - Arguments to update one ExpenseSplit.
     * @example
     * // Update one ExpenseSplit
     * const expenseSplit = await prisma.expenseSplit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExpenseSplitUpdateArgs>(args: SelectSubset<T, ExpenseSplitUpdateArgs<ExtArgs>>): Prisma__ExpenseSplitClient<$Result.GetResult<Prisma.$ExpenseSplitPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ExpenseSplits.
     * @param {ExpenseSplitDeleteManyArgs} args - Arguments to filter ExpenseSplits to delete.
     * @example
     * // Delete a few ExpenseSplits
     * const { count } = await prisma.expenseSplit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExpenseSplitDeleteManyArgs>(args?: SelectSubset<T, ExpenseSplitDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExpenseSplits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseSplitUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExpenseSplits
     * const expenseSplit = await prisma.expenseSplit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExpenseSplitUpdateManyArgs>(args: SelectSubset<T, ExpenseSplitUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ExpenseSplit.
     * @param {ExpenseSplitUpsertArgs} args - Arguments to update or create a ExpenseSplit.
     * @example
     * // Update or create a ExpenseSplit
     * const expenseSplit = await prisma.expenseSplit.upsert({
     *   create: {
     *     // ... data to create a ExpenseSplit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExpenseSplit we want to update
     *   }
     * })
     */
    upsert<T extends ExpenseSplitUpsertArgs>(args: SelectSubset<T, ExpenseSplitUpsertArgs<ExtArgs>>): Prisma__ExpenseSplitClient<$Result.GetResult<Prisma.$ExpenseSplitPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ExpenseSplits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseSplitCountArgs} args - Arguments to filter ExpenseSplits to count.
     * @example
     * // Count the number of ExpenseSplits
     * const count = await prisma.expenseSplit.count({
     *   where: {
     *     // ... the filter for the ExpenseSplits we want to count
     *   }
     * })
    **/
    count<T extends ExpenseSplitCountArgs>(
      args?: Subset<T, ExpenseSplitCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExpenseSplitCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExpenseSplit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseSplitAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExpenseSplitAggregateArgs>(args: Subset<T, ExpenseSplitAggregateArgs>): Prisma.PrismaPromise<GetExpenseSplitAggregateType<T>>

    /**
     * Group by ExpenseSplit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseSplitGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExpenseSplitGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExpenseSplitGroupByArgs['orderBy'] }
        : { orderBy?: ExpenseSplitGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExpenseSplitGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExpenseSplitGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ExpenseSplit model
   */
  readonly fields: ExpenseSplitFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExpenseSplit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExpenseSplitClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    expense<T extends ExpenseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ExpenseDefaultArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ExpenseSplit model
   */ 
  interface ExpenseSplitFieldRefs {
    readonly id: FieldRef<"ExpenseSplit", 'String'>
    readonly expenseId: FieldRef<"ExpenseSplit", 'String'>
    readonly userId: FieldRef<"ExpenseSplit", 'String'>
    readonly amount: FieldRef<"ExpenseSplit", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * ExpenseSplit findUnique
   */
  export type ExpenseSplitFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseSplit
     */
    select?: ExpenseSplitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseSplitInclude<ExtArgs> | null
    /**
     * Filter, which ExpenseSplit to fetch.
     */
    where: ExpenseSplitWhereUniqueInput
  }

  /**
   * ExpenseSplit findUniqueOrThrow
   */
  export type ExpenseSplitFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseSplit
     */
    select?: ExpenseSplitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseSplitInclude<ExtArgs> | null
    /**
     * Filter, which ExpenseSplit to fetch.
     */
    where: ExpenseSplitWhereUniqueInput
  }

  /**
   * ExpenseSplit findFirst
   */
  export type ExpenseSplitFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseSplit
     */
    select?: ExpenseSplitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseSplitInclude<ExtArgs> | null
    /**
     * Filter, which ExpenseSplit to fetch.
     */
    where?: ExpenseSplitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExpenseSplits to fetch.
     */
    orderBy?: ExpenseSplitOrderByWithRelationInput | ExpenseSplitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExpenseSplits.
     */
    cursor?: ExpenseSplitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExpenseSplits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExpenseSplits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExpenseSplits.
     */
    distinct?: ExpenseSplitScalarFieldEnum | ExpenseSplitScalarFieldEnum[]
  }

  /**
   * ExpenseSplit findFirstOrThrow
   */
  export type ExpenseSplitFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseSplit
     */
    select?: ExpenseSplitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseSplitInclude<ExtArgs> | null
    /**
     * Filter, which ExpenseSplit to fetch.
     */
    where?: ExpenseSplitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExpenseSplits to fetch.
     */
    orderBy?: ExpenseSplitOrderByWithRelationInput | ExpenseSplitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExpenseSplits.
     */
    cursor?: ExpenseSplitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExpenseSplits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExpenseSplits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExpenseSplits.
     */
    distinct?: ExpenseSplitScalarFieldEnum | ExpenseSplitScalarFieldEnum[]
  }

  /**
   * ExpenseSplit findMany
   */
  export type ExpenseSplitFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseSplit
     */
    select?: ExpenseSplitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseSplitInclude<ExtArgs> | null
    /**
     * Filter, which ExpenseSplits to fetch.
     */
    where?: ExpenseSplitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExpenseSplits to fetch.
     */
    orderBy?: ExpenseSplitOrderByWithRelationInput | ExpenseSplitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ExpenseSplits.
     */
    cursor?: ExpenseSplitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExpenseSplits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExpenseSplits.
     */
    skip?: number
    distinct?: ExpenseSplitScalarFieldEnum | ExpenseSplitScalarFieldEnum[]
  }

  /**
   * ExpenseSplit create
   */
  export type ExpenseSplitCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseSplit
     */
    select?: ExpenseSplitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseSplitInclude<ExtArgs> | null
    /**
     * The data needed to create a ExpenseSplit.
     */
    data: XOR<ExpenseSplitCreateInput, ExpenseSplitUncheckedCreateInput>
  }

  /**
   * ExpenseSplit createMany
   */
  export type ExpenseSplitCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ExpenseSplits.
     */
    data: ExpenseSplitCreateManyInput | ExpenseSplitCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ExpenseSplit createManyAndReturn
   */
  export type ExpenseSplitCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseSplit
     */
    select?: ExpenseSplitSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ExpenseSplits.
     */
    data: ExpenseSplitCreateManyInput | ExpenseSplitCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseSplitIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ExpenseSplit update
   */
  export type ExpenseSplitUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseSplit
     */
    select?: ExpenseSplitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseSplitInclude<ExtArgs> | null
    /**
     * The data needed to update a ExpenseSplit.
     */
    data: XOR<ExpenseSplitUpdateInput, ExpenseSplitUncheckedUpdateInput>
    /**
     * Choose, which ExpenseSplit to update.
     */
    where: ExpenseSplitWhereUniqueInput
  }

  /**
   * ExpenseSplit updateMany
   */
  export type ExpenseSplitUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ExpenseSplits.
     */
    data: XOR<ExpenseSplitUpdateManyMutationInput, ExpenseSplitUncheckedUpdateManyInput>
    /**
     * Filter which ExpenseSplits to update
     */
    where?: ExpenseSplitWhereInput
  }

  /**
   * ExpenseSplit upsert
   */
  export type ExpenseSplitUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseSplit
     */
    select?: ExpenseSplitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseSplitInclude<ExtArgs> | null
    /**
     * The filter to search for the ExpenseSplit to update in case it exists.
     */
    where: ExpenseSplitWhereUniqueInput
    /**
     * In case the ExpenseSplit found by the `where` argument doesn't exist, create a new ExpenseSplit with this data.
     */
    create: XOR<ExpenseSplitCreateInput, ExpenseSplitUncheckedCreateInput>
    /**
     * In case the ExpenseSplit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExpenseSplitUpdateInput, ExpenseSplitUncheckedUpdateInput>
  }

  /**
   * ExpenseSplit delete
   */
  export type ExpenseSplitDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseSplit
     */
    select?: ExpenseSplitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseSplitInclude<ExtArgs> | null
    /**
     * Filter which ExpenseSplit to delete.
     */
    where: ExpenseSplitWhereUniqueInput
  }

  /**
   * ExpenseSplit deleteMany
   */
  export type ExpenseSplitDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExpenseSplits to delete
     */
    where?: ExpenseSplitWhereInput
  }

  /**
   * ExpenseSplit without action
   */
  export type ExpenseSplitDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseSplit
     */
    select?: ExpenseSplitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseSplitInclude<ExtArgs> | null
  }


  /**
   * Model Transaction
   */

  export type AggregateTransaction = {
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  export type TransactionAvgAggregateOutputType = {
    amount: number | null
  }

  export type TransactionSumAggregateOutputType = {
    amount: number | null
  }

  export type TransactionMinAggregateOutputType = {
    id: string | null
    expenseId: string | null
    fromUserId: string | null
    toUserId: string | null
    amount: number | null
    status: $Enums.TransactionStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type TransactionMaxAggregateOutputType = {
    id: string | null
    expenseId: string | null
    fromUserId: string | null
    toUserId: string | null
    amount: number | null
    status: $Enums.TransactionStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type TransactionCountAggregateOutputType = {
    id: number
    expenseId: number
    fromUserId: number
    toUserId: number
    amount: number
    status: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type TransactionAvgAggregateInputType = {
    amount?: true
  }

  export type TransactionSumAggregateInputType = {
    amount?: true
  }

  export type TransactionMinAggregateInputType = {
    id?: true
    expenseId?: true
    fromUserId?: true
    toUserId?: true
    amount?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type TransactionMaxAggregateInputType = {
    id?: true
    expenseId?: true
    fromUserId?: true
    toUserId?: true
    amount?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type TransactionCountAggregateInputType = {
    id?: true
    expenseId?: true
    fromUserId?: true
    toUserId?: true
    amount?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type TransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transaction to aggregate.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Transactions
    **/
    _count?: true | TransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionMaxAggregateInputType
  }

  export type GetTransactionAggregateType<T extends TransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransaction[P]>
      : GetScalarType<T[P], AggregateTransaction[P]>
  }




  export type TransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithAggregationInput | TransactionOrderByWithAggregationInput[]
    by: TransactionScalarFieldEnum[] | TransactionScalarFieldEnum
    having?: TransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionCountAggregateInputType | true
    _avg?: TransactionAvgAggregateInputType
    _sum?: TransactionSumAggregateInputType
    _min?: TransactionMinAggregateInputType
    _max?: TransactionMaxAggregateInputType
  }

  export type TransactionGroupByOutputType = {
    id: string
    expenseId: string
    fromUserId: string
    toUserId: string
    amount: number
    status: $Enums.TransactionStatus
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  type GetTransactionGroupByPayload<T extends TransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionGroupByOutputType[P]>
        }
      >
    >


  export type TransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    expenseId?: boolean
    fromUserId?: boolean
    toUserId?: boolean
    amount?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    expense?: boolean | ExpenseDefaultArgs<ExtArgs>
    fromUser?: boolean | UserDefaultArgs<ExtArgs>
    toUser?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    expenseId?: boolean
    fromUserId?: boolean
    toUserId?: boolean
    amount?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    expense?: boolean | ExpenseDefaultArgs<ExtArgs>
    fromUser?: boolean | UserDefaultArgs<ExtArgs>
    toUser?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectScalar = {
    id?: boolean
    expenseId?: boolean
    fromUserId?: boolean
    toUserId?: boolean
    amount?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type TransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    expense?: boolean | ExpenseDefaultArgs<ExtArgs>
    fromUser?: boolean | UserDefaultArgs<ExtArgs>
    toUser?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TransactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    expense?: boolean | ExpenseDefaultArgs<ExtArgs>
    fromUser?: boolean | UserDefaultArgs<ExtArgs>
    toUser?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Transaction"
    objects: {
      expense: Prisma.$ExpensePayload<ExtArgs>
      fromUser: Prisma.$UserPayload<ExtArgs>
      toUser: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      expenseId: string
      fromUserId: string
      toUserId: string
      amount: number
      status: $Enums.TransactionStatus
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["transaction"]>
    composites: {}
  }

  type TransactionGetPayload<S extends boolean | null | undefined | TransactionDefaultArgs> = $Result.GetResult<Prisma.$TransactionPayload, S>

  type TransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TransactionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TransactionCountAggregateInputType | true
    }

  export interface TransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Transaction'], meta: { name: 'Transaction' } }
    /**
     * Find zero or one Transaction that matches the filter.
     * @param {TransactionFindUniqueArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransactionFindUniqueArgs>(args: SelectSubset<T, TransactionFindUniqueArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Transaction that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TransactionFindUniqueOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, TransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Transaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransactionFindFirstArgs>(args?: SelectSubset<T, TransactionFindFirstArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Transaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, TransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transactions
     * const transactions = await prisma.transaction.findMany()
     * 
     * // Get first 10 Transactions
     * const transactions = await prisma.transaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transactionWithIdOnly = await prisma.transaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransactionFindManyArgs>(args?: SelectSubset<T, TransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Transaction.
     * @param {TransactionCreateArgs} args - Arguments to create a Transaction.
     * @example
     * // Create one Transaction
     * const Transaction = await prisma.transaction.create({
     *   data: {
     *     // ... data to create a Transaction
     *   }
     * })
     * 
     */
    create<T extends TransactionCreateArgs>(args: SelectSubset<T, TransactionCreateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Transactions.
     * @param {TransactionCreateManyArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransactionCreateManyArgs>(args?: SelectSubset<T, TransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Transactions and returns the data saved in the database.
     * @param {TransactionCreateManyAndReturnArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Transactions and only return the `id`
     * const transactionWithIdOnly = await prisma.transaction.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, TransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Transaction.
     * @param {TransactionDeleteArgs} args - Arguments to delete one Transaction.
     * @example
     * // Delete one Transaction
     * const Transaction = await prisma.transaction.delete({
     *   where: {
     *     // ... filter to delete one Transaction
     *   }
     * })
     * 
     */
    delete<T extends TransactionDeleteArgs>(args: SelectSubset<T, TransactionDeleteArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Transaction.
     * @param {TransactionUpdateArgs} args - Arguments to update one Transaction.
     * @example
     * // Update one Transaction
     * const transaction = await prisma.transaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransactionUpdateArgs>(args: SelectSubset<T, TransactionUpdateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Transactions.
     * @param {TransactionDeleteManyArgs} args - Arguments to filter Transactions to delete.
     * @example
     * // Delete a few Transactions
     * const { count } = await prisma.transaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransactionDeleteManyArgs>(args?: SelectSubset<T, TransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transactions
     * const transaction = await prisma.transaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransactionUpdateManyArgs>(args: SelectSubset<T, TransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Transaction.
     * @param {TransactionUpsertArgs} args - Arguments to update or create a Transaction.
     * @example
     * // Update or create a Transaction
     * const transaction = await prisma.transaction.upsert({
     *   create: {
     *     // ... data to create a Transaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transaction we want to update
     *   }
     * })
     */
    upsert<T extends TransactionUpsertArgs>(args: SelectSubset<T, TransactionUpsertArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionCountArgs} args - Arguments to filter Transactions to count.
     * @example
     * // Count the number of Transactions
     * const count = await prisma.transaction.count({
     *   where: {
     *     // ... the filter for the Transactions we want to count
     *   }
     * })
    **/
    count<T extends TransactionCountArgs>(
      args?: Subset<T, TransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionAggregateArgs>(args: Subset<T, TransactionAggregateArgs>): Prisma.PrismaPromise<GetTransactionAggregateType<T>>

    /**
     * Group by Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransactionGroupByArgs['orderBy'] }
        : { orderBy?: TransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Transaction model
   */
  readonly fields: TransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Transaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    expense<T extends ExpenseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ExpenseDefaultArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    fromUser<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    toUser<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Transaction model
   */ 
  interface TransactionFieldRefs {
    readonly id: FieldRef<"Transaction", 'String'>
    readonly expenseId: FieldRef<"Transaction", 'String'>
    readonly fromUserId: FieldRef<"Transaction", 'String'>
    readonly toUserId: FieldRef<"Transaction", 'String'>
    readonly amount: FieldRef<"Transaction", 'Float'>
    readonly status: FieldRef<"Transaction", 'TransactionStatus'>
    readonly createdAt: FieldRef<"Transaction", 'DateTime'>
    readonly updatedAt: FieldRef<"Transaction", 'DateTime'>
    readonly deletedAt: FieldRef<"Transaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Transaction findUnique
   */
  export type TransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findUniqueOrThrow
   */
  export type TransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findFirst
   */
  export type TransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findFirstOrThrow
   */
  export type TransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findMany
   */
  export type TransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transactions to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction create
   */
  export type TransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a Transaction.
     */
    data: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
  }

  /**
   * Transaction createMany
   */
  export type TransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Transactions.
     */
    data: TransactionCreateManyInput | TransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Transaction createManyAndReturn
   */
  export type TransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Transactions.
     */
    data: TransactionCreateManyInput | TransactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transaction update
   */
  export type TransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a Transaction.
     */
    data: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
    /**
     * Choose, which Transaction to update.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction updateMany
   */
  export type TransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Transactions.
     */
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyInput>
    /**
     * Filter which Transactions to update
     */
    where?: TransactionWhereInput
  }

  /**
   * Transaction upsert
   */
  export type TransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the Transaction to update in case it exists.
     */
    where: TransactionWhereUniqueInput
    /**
     * In case the Transaction found by the `where` argument doesn't exist, create a new Transaction with this data.
     */
    create: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
    /**
     * In case the Transaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
  }

  /**
   * Transaction delete
   */
  export type TransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter which Transaction to delete.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction deleteMany
   */
  export type TransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transactions to delete
     */
    where?: TransactionWhereInput
  }

  /**
   * Transaction without action
   */
  export type TransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
  }


  /**
   * Model Receipt
   */

  export type AggregateReceipt = {
    _count: ReceiptCountAggregateOutputType | null
    _min: ReceiptMinAggregateOutputType | null
    _max: ReceiptMaxAggregateOutputType | null
  }

  export type ReceiptMinAggregateOutputType = {
    id: string | null
    expenseId: string | null
    url: string | null
    fileType: string | null
    createdAt: Date | null
  }

  export type ReceiptMaxAggregateOutputType = {
    id: string | null
    expenseId: string | null
    url: string | null
    fileType: string | null
    createdAt: Date | null
  }

  export type ReceiptCountAggregateOutputType = {
    id: number
    expenseId: number
    url: number
    fileType: number
    createdAt: number
    _all: number
  }


  export type ReceiptMinAggregateInputType = {
    id?: true
    expenseId?: true
    url?: true
    fileType?: true
    createdAt?: true
  }

  export type ReceiptMaxAggregateInputType = {
    id?: true
    expenseId?: true
    url?: true
    fileType?: true
    createdAt?: true
  }

  export type ReceiptCountAggregateInputType = {
    id?: true
    expenseId?: true
    url?: true
    fileType?: true
    createdAt?: true
    _all?: true
  }

  export type ReceiptAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Receipt to aggregate.
     */
    where?: ReceiptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Receipts to fetch.
     */
    orderBy?: ReceiptOrderByWithRelationInput | ReceiptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReceiptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Receipts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Receipts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Receipts
    **/
    _count?: true | ReceiptCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReceiptMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReceiptMaxAggregateInputType
  }

  export type GetReceiptAggregateType<T extends ReceiptAggregateArgs> = {
        [P in keyof T & keyof AggregateReceipt]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReceipt[P]>
      : GetScalarType<T[P], AggregateReceipt[P]>
  }




  export type ReceiptGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReceiptWhereInput
    orderBy?: ReceiptOrderByWithAggregationInput | ReceiptOrderByWithAggregationInput[]
    by: ReceiptScalarFieldEnum[] | ReceiptScalarFieldEnum
    having?: ReceiptScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReceiptCountAggregateInputType | true
    _min?: ReceiptMinAggregateInputType
    _max?: ReceiptMaxAggregateInputType
  }

  export type ReceiptGroupByOutputType = {
    id: string
    expenseId: string
    url: string
    fileType: string
    createdAt: Date
    _count: ReceiptCountAggregateOutputType | null
    _min: ReceiptMinAggregateOutputType | null
    _max: ReceiptMaxAggregateOutputType | null
  }

  type GetReceiptGroupByPayload<T extends ReceiptGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReceiptGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReceiptGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReceiptGroupByOutputType[P]>
            : GetScalarType<T[P], ReceiptGroupByOutputType[P]>
        }
      >
    >


  export type ReceiptSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    expenseId?: boolean
    url?: boolean
    fileType?: boolean
    createdAt?: boolean
    expense?: boolean | ExpenseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["receipt"]>

  export type ReceiptSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    expenseId?: boolean
    url?: boolean
    fileType?: boolean
    createdAt?: boolean
    expense?: boolean | ExpenseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["receipt"]>

  export type ReceiptSelectScalar = {
    id?: boolean
    expenseId?: boolean
    url?: boolean
    fileType?: boolean
    createdAt?: boolean
  }

  export type ReceiptInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    expense?: boolean | ExpenseDefaultArgs<ExtArgs>
  }
  export type ReceiptIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    expense?: boolean | ExpenseDefaultArgs<ExtArgs>
  }

  export type $ReceiptPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Receipt"
    objects: {
      expense: Prisma.$ExpensePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      expenseId: string
      url: string
      fileType: string
      createdAt: Date
    }, ExtArgs["result"]["receipt"]>
    composites: {}
  }

  type ReceiptGetPayload<S extends boolean | null | undefined | ReceiptDefaultArgs> = $Result.GetResult<Prisma.$ReceiptPayload, S>

  type ReceiptCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ReceiptFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ReceiptCountAggregateInputType | true
    }

  export interface ReceiptDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Receipt'], meta: { name: 'Receipt' } }
    /**
     * Find zero or one Receipt that matches the filter.
     * @param {ReceiptFindUniqueArgs} args - Arguments to find a Receipt
     * @example
     * // Get one Receipt
     * const receipt = await prisma.receipt.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReceiptFindUniqueArgs>(args: SelectSubset<T, ReceiptFindUniqueArgs<ExtArgs>>): Prisma__ReceiptClient<$Result.GetResult<Prisma.$ReceiptPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Receipt that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ReceiptFindUniqueOrThrowArgs} args - Arguments to find a Receipt
     * @example
     * // Get one Receipt
     * const receipt = await prisma.receipt.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReceiptFindUniqueOrThrowArgs>(args: SelectSubset<T, ReceiptFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReceiptClient<$Result.GetResult<Prisma.$ReceiptPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Receipt that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceiptFindFirstArgs} args - Arguments to find a Receipt
     * @example
     * // Get one Receipt
     * const receipt = await prisma.receipt.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReceiptFindFirstArgs>(args?: SelectSubset<T, ReceiptFindFirstArgs<ExtArgs>>): Prisma__ReceiptClient<$Result.GetResult<Prisma.$ReceiptPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Receipt that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceiptFindFirstOrThrowArgs} args - Arguments to find a Receipt
     * @example
     * // Get one Receipt
     * const receipt = await prisma.receipt.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReceiptFindFirstOrThrowArgs>(args?: SelectSubset<T, ReceiptFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReceiptClient<$Result.GetResult<Prisma.$ReceiptPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Receipts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceiptFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Receipts
     * const receipts = await prisma.receipt.findMany()
     * 
     * // Get first 10 Receipts
     * const receipts = await prisma.receipt.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const receiptWithIdOnly = await prisma.receipt.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReceiptFindManyArgs>(args?: SelectSubset<T, ReceiptFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReceiptPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Receipt.
     * @param {ReceiptCreateArgs} args - Arguments to create a Receipt.
     * @example
     * // Create one Receipt
     * const Receipt = await prisma.receipt.create({
     *   data: {
     *     // ... data to create a Receipt
     *   }
     * })
     * 
     */
    create<T extends ReceiptCreateArgs>(args: SelectSubset<T, ReceiptCreateArgs<ExtArgs>>): Prisma__ReceiptClient<$Result.GetResult<Prisma.$ReceiptPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Receipts.
     * @param {ReceiptCreateManyArgs} args - Arguments to create many Receipts.
     * @example
     * // Create many Receipts
     * const receipt = await prisma.receipt.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReceiptCreateManyArgs>(args?: SelectSubset<T, ReceiptCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Receipts and returns the data saved in the database.
     * @param {ReceiptCreateManyAndReturnArgs} args - Arguments to create many Receipts.
     * @example
     * // Create many Receipts
     * const receipt = await prisma.receipt.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Receipts and only return the `id`
     * const receiptWithIdOnly = await prisma.receipt.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReceiptCreateManyAndReturnArgs>(args?: SelectSubset<T, ReceiptCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReceiptPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Receipt.
     * @param {ReceiptDeleteArgs} args - Arguments to delete one Receipt.
     * @example
     * // Delete one Receipt
     * const Receipt = await prisma.receipt.delete({
     *   where: {
     *     // ... filter to delete one Receipt
     *   }
     * })
     * 
     */
    delete<T extends ReceiptDeleteArgs>(args: SelectSubset<T, ReceiptDeleteArgs<ExtArgs>>): Prisma__ReceiptClient<$Result.GetResult<Prisma.$ReceiptPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Receipt.
     * @param {ReceiptUpdateArgs} args - Arguments to update one Receipt.
     * @example
     * // Update one Receipt
     * const receipt = await prisma.receipt.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReceiptUpdateArgs>(args: SelectSubset<T, ReceiptUpdateArgs<ExtArgs>>): Prisma__ReceiptClient<$Result.GetResult<Prisma.$ReceiptPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Receipts.
     * @param {ReceiptDeleteManyArgs} args - Arguments to filter Receipts to delete.
     * @example
     * // Delete a few Receipts
     * const { count } = await prisma.receipt.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReceiptDeleteManyArgs>(args?: SelectSubset<T, ReceiptDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Receipts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceiptUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Receipts
     * const receipt = await prisma.receipt.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReceiptUpdateManyArgs>(args: SelectSubset<T, ReceiptUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Receipt.
     * @param {ReceiptUpsertArgs} args - Arguments to update or create a Receipt.
     * @example
     * // Update or create a Receipt
     * const receipt = await prisma.receipt.upsert({
     *   create: {
     *     // ... data to create a Receipt
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Receipt we want to update
     *   }
     * })
     */
    upsert<T extends ReceiptUpsertArgs>(args: SelectSubset<T, ReceiptUpsertArgs<ExtArgs>>): Prisma__ReceiptClient<$Result.GetResult<Prisma.$ReceiptPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Receipts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceiptCountArgs} args - Arguments to filter Receipts to count.
     * @example
     * // Count the number of Receipts
     * const count = await prisma.receipt.count({
     *   where: {
     *     // ... the filter for the Receipts we want to count
     *   }
     * })
    **/
    count<T extends ReceiptCountArgs>(
      args?: Subset<T, ReceiptCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReceiptCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Receipt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceiptAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReceiptAggregateArgs>(args: Subset<T, ReceiptAggregateArgs>): Prisma.PrismaPromise<GetReceiptAggregateType<T>>

    /**
     * Group by Receipt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceiptGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReceiptGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReceiptGroupByArgs['orderBy'] }
        : { orderBy?: ReceiptGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReceiptGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReceiptGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Receipt model
   */
  readonly fields: ReceiptFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Receipt.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReceiptClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    expense<T extends ExpenseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ExpenseDefaultArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Receipt model
   */ 
  interface ReceiptFieldRefs {
    readonly id: FieldRef<"Receipt", 'String'>
    readonly expenseId: FieldRef<"Receipt", 'String'>
    readonly url: FieldRef<"Receipt", 'String'>
    readonly fileType: FieldRef<"Receipt", 'String'>
    readonly createdAt: FieldRef<"Receipt", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Receipt findUnique
   */
  export type ReceiptFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receipt
     */
    select?: ReceiptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceiptInclude<ExtArgs> | null
    /**
     * Filter, which Receipt to fetch.
     */
    where: ReceiptWhereUniqueInput
  }

  /**
   * Receipt findUniqueOrThrow
   */
  export type ReceiptFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receipt
     */
    select?: ReceiptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceiptInclude<ExtArgs> | null
    /**
     * Filter, which Receipt to fetch.
     */
    where: ReceiptWhereUniqueInput
  }

  /**
   * Receipt findFirst
   */
  export type ReceiptFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receipt
     */
    select?: ReceiptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceiptInclude<ExtArgs> | null
    /**
     * Filter, which Receipt to fetch.
     */
    where?: ReceiptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Receipts to fetch.
     */
    orderBy?: ReceiptOrderByWithRelationInput | ReceiptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Receipts.
     */
    cursor?: ReceiptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Receipts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Receipts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Receipts.
     */
    distinct?: ReceiptScalarFieldEnum | ReceiptScalarFieldEnum[]
  }

  /**
   * Receipt findFirstOrThrow
   */
  export type ReceiptFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receipt
     */
    select?: ReceiptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceiptInclude<ExtArgs> | null
    /**
     * Filter, which Receipt to fetch.
     */
    where?: ReceiptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Receipts to fetch.
     */
    orderBy?: ReceiptOrderByWithRelationInput | ReceiptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Receipts.
     */
    cursor?: ReceiptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Receipts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Receipts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Receipts.
     */
    distinct?: ReceiptScalarFieldEnum | ReceiptScalarFieldEnum[]
  }

  /**
   * Receipt findMany
   */
  export type ReceiptFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receipt
     */
    select?: ReceiptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceiptInclude<ExtArgs> | null
    /**
     * Filter, which Receipts to fetch.
     */
    where?: ReceiptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Receipts to fetch.
     */
    orderBy?: ReceiptOrderByWithRelationInput | ReceiptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Receipts.
     */
    cursor?: ReceiptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Receipts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Receipts.
     */
    skip?: number
    distinct?: ReceiptScalarFieldEnum | ReceiptScalarFieldEnum[]
  }

  /**
   * Receipt create
   */
  export type ReceiptCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receipt
     */
    select?: ReceiptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceiptInclude<ExtArgs> | null
    /**
     * The data needed to create a Receipt.
     */
    data: XOR<ReceiptCreateInput, ReceiptUncheckedCreateInput>
  }

  /**
   * Receipt createMany
   */
  export type ReceiptCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Receipts.
     */
    data: ReceiptCreateManyInput | ReceiptCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Receipt createManyAndReturn
   */
  export type ReceiptCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receipt
     */
    select?: ReceiptSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Receipts.
     */
    data: ReceiptCreateManyInput | ReceiptCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceiptIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Receipt update
   */
  export type ReceiptUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receipt
     */
    select?: ReceiptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceiptInclude<ExtArgs> | null
    /**
     * The data needed to update a Receipt.
     */
    data: XOR<ReceiptUpdateInput, ReceiptUncheckedUpdateInput>
    /**
     * Choose, which Receipt to update.
     */
    where: ReceiptWhereUniqueInput
  }

  /**
   * Receipt updateMany
   */
  export type ReceiptUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Receipts.
     */
    data: XOR<ReceiptUpdateManyMutationInput, ReceiptUncheckedUpdateManyInput>
    /**
     * Filter which Receipts to update
     */
    where?: ReceiptWhereInput
  }

  /**
   * Receipt upsert
   */
  export type ReceiptUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receipt
     */
    select?: ReceiptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceiptInclude<ExtArgs> | null
    /**
     * The filter to search for the Receipt to update in case it exists.
     */
    where: ReceiptWhereUniqueInput
    /**
     * In case the Receipt found by the `where` argument doesn't exist, create a new Receipt with this data.
     */
    create: XOR<ReceiptCreateInput, ReceiptUncheckedCreateInput>
    /**
     * In case the Receipt was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReceiptUpdateInput, ReceiptUncheckedUpdateInput>
  }

  /**
   * Receipt delete
   */
  export type ReceiptDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receipt
     */
    select?: ReceiptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceiptInclude<ExtArgs> | null
    /**
     * Filter which Receipt to delete.
     */
    where: ReceiptWhereUniqueInput
  }

  /**
   * Receipt deleteMany
   */
  export type ReceiptDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Receipts to delete
     */
    where?: ReceiptWhereInput
  }

  /**
   * Receipt without action
   */
  export type ReceiptDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receipt
     */
    select?: ReceiptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceiptInclude<ExtArgs> | null
  }


  /**
   * Model ExpenseHistory
   */

  export type AggregateExpenseHistory = {
    _count: ExpenseHistoryCountAggregateOutputType | null
    _min: ExpenseHistoryMinAggregateOutputType | null
    _max: ExpenseHistoryMaxAggregateOutputType | null
  }

  export type ExpenseHistoryMinAggregateOutputType = {
    id: string | null
    expenseId: string | null
    action: $Enums.ExpenseAction | null
    changedById: string | null
    changedAt: Date | null
  }

  export type ExpenseHistoryMaxAggregateOutputType = {
    id: string | null
    expenseId: string | null
    action: $Enums.ExpenseAction | null
    changedById: string | null
    changedAt: Date | null
  }

  export type ExpenseHistoryCountAggregateOutputType = {
    id: number
    expenseId: number
    action: number
    changedById: number
    changedAt: number
    _all: number
  }


  export type ExpenseHistoryMinAggregateInputType = {
    id?: true
    expenseId?: true
    action?: true
    changedById?: true
    changedAt?: true
  }

  export type ExpenseHistoryMaxAggregateInputType = {
    id?: true
    expenseId?: true
    action?: true
    changedById?: true
    changedAt?: true
  }

  export type ExpenseHistoryCountAggregateInputType = {
    id?: true
    expenseId?: true
    action?: true
    changedById?: true
    changedAt?: true
    _all?: true
  }

  export type ExpenseHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExpenseHistory to aggregate.
     */
    where?: ExpenseHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExpenseHistories to fetch.
     */
    orderBy?: ExpenseHistoryOrderByWithRelationInput | ExpenseHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExpenseHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExpenseHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExpenseHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ExpenseHistories
    **/
    _count?: true | ExpenseHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExpenseHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExpenseHistoryMaxAggregateInputType
  }

  export type GetExpenseHistoryAggregateType<T extends ExpenseHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateExpenseHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExpenseHistory[P]>
      : GetScalarType<T[P], AggregateExpenseHistory[P]>
  }




  export type ExpenseHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpenseHistoryWhereInput
    orderBy?: ExpenseHistoryOrderByWithAggregationInput | ExpenseHistoryOrderByWithAggregationInput[]
    by: ExpenseHistoryScalarFieldEnum[] | ExpenseHistoryScalarFieldEnum
    having?: ExpenseHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExpenseHistoryCountAggregateInputType | true
    _min?: ExpenseHistoryMinAggregateInputType
    _max?: ExpenseHistoryMaxAggregateInputType
  }

  export type ExpenseHistoryGroupByOutputType = {
    id: string
    expenseId: string
    action: $Enums.ExpenseAction
    changedById: string
    changedAt: Date
    _count: ExpenseHistoryCountAggregateOutputType | null
    _min: ExpenseHistoryMinAggregateOutputType | null
    _max: ExpenseHistoryMaxAggregateOutputType | null
  }

  type GetExpenseHistoryGroupByPayload<T extends ExpenseHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExpenseHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExpenseHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExpenseHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], ExpenseHistoryGroupByOutputType[P]>
        }
      >
    >


  export type ExpenseHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    expenseId?: boolean
    action?: boolean
    changedById?: boolean
    changedAt?: boolean
    expense?: boolean | ExpenseDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["expenseHistory"]>

  export type ExpenseHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    expenseId?: boolean
    action?: boolean
    changedById?: boolean
    changedAt?: boolean
    expense?: boolean | ExpenseDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["expenseHistory"]>

  export type ExpenseHistorySelectScalar = {
    id?: boolean
    expenseId?: boolean
    action?: boolean
    changedById?: boolean
    changedAt?: boolean
  }

  export type ExpenseHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    expense?: boolean | ExpenseDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ExpenseHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    expense?: boolean | ExpenseDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ExpenseHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ExpenseHistory"
    objects: {
      expense: Prisma.$ExpensePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      expenseId: string
      action: $Enums.ExpenseAction
      changedById: string
      changedAt: Date
    }, ExtArgs["result"]["expenseHistory"]>
    composites: {}
  }

  type ExpenseHistoryGetPayload<S extends boolean | null | undefined | ExpenseHistoryDefaultArgs> = $Result.GetResult<Prisma.$ExpenseHistoryPayload, S>

  type ExpenseHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ExpenseHistoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ExpenseHistoryCountAggregateInputType | true
    }

  export interface ExpenseHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ExpenseHistory'], meta: { name: 'ExpenseHistory' } }
    /**
     * Find zero or one ExpenseHistory that matches the filter.
     * @param {ExpenseHistoryFindUniqueArgs} args - Arguments to find a ExpenseHistory
     * @example
     * // Get one ExpenseHistory
     * const expenseHistory = await prisma.expenseHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExpenseHistoryFindUniqueArgs>(args: SelectSubset<T, ExpenseHistoryFindUniqueArgs<ExtArgs>>): Prisma__ExpenseHistoryClient<$Result.GetResult<Prisma.$ExpenseHistoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ExpenseHistory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ExpenseHistoryFindUniqueOrThrowArgs} args - Arguments to find a ExpenseHistory
     * @example
     * // Get one ExpenseHistory
     * const expenseHistory = await prisma.expenseHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExpenseHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, ExpenseHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExpenseHistoryClient<$Result.GetResult<Prisma.$ExpenseHistoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ExpenseHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseHistoryFindFirstArgs} args - Arguments to find a ExpenseHistory
     * @example
     * // Get one ExpenseHistory
     * const expenseHistory = await prisma.expenseHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExpenseHistoryFindFirstArgs>(args?: SelectSubset<T, ExpenseHistoryFindFirstArgs<ExtArgs>>): Prisma__ExpenseHistoryClient<$Result.GetResult<Prisma.$ExpenseHistoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ExpenseHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseHistoryFindFirstOrThrowArgs} args - Arguments to find a ExpenseHistory
     * @example
     * // Get one ExpenseHistory
     * const expenseHistory = await prisma.expenseHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExpenseHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, ExpenseHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExpenseHistoryClient<$Result.GetResult<Prisma.$ExpenseHistoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ExpenseHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExpenseHistories
     * const expenseHistories = await prisma.expenseHistory.findMany()
     * 
     * // Get first 10 ExpenseHistories
     * const expenseHistories = await prisma.expenseHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const expenseHistoryWithIdOnly = await prisma.expenseHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExpenseHistoryFindManyArgs>(args?: SelectSubset<T, ExpenseHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpenseHistoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ExpenseHistory.
     * @param {ExpenseHistoryCreateArgs} args - Arguments to create a ExpenseHistory.
     * @example
     * // Create one ExpenseHistory
     * const ExpenseHistory = await prisma.expenseHistory.create({
     *   data: {
     *     // ... data to create a ExpenseHistory
     *   }
     * })
     * 
     */
    create<T extends ExpenseHistoryCreateArgs>(args: SelectSubset<T, ExpenseHistoryCreateArgs<ExtArgs>>): Prisma__ExpenseHistoryClient<$Result.GetResult<Prisma.$ExpenseHistoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ExpenseHistories.
     * @param {ExpenseHistoryCreateManyArgs} args - Arguments to create many ExpenseHistories.
     * @example
     * // Create many ExpenseHistories
     * const expenseHistory = await prisma.expenseHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExpenseHistoryCreateManyArgs>(args?: SelectSubset<T, ExpenseHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ExpenseHistories and returns the data saved in the database.
     * @param {ExpenseHistoryCreateManyAndReturnArgs} args - Arguments to create many ExpenseHistories.
     * @example
     * // Create many ExpenseHistories
     * const expenseHistory = await prisma.expenseHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ExpenseHistories and only return the `id`
     * const expenseHistoryWithIdOnly = await prisma.expenseHistory.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExpenseHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, ExpenseHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpenseHistoryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ExpenseHistory.
     * @param {ExpenseHistoryDeleteArgs} args - Arguments to delete one ExpenseHistory.
     * @example
     * // Delete one ExpenseHistory
     * const ExpenseHistory = await prisma.expenseHistory.delete({
     *   where: {
     *     // ... filter to delete one ExpenseHistory
     *   }
     * })
     * 
     */
    delete<T extends ExpenseHistoryDeleteArgs>(args: SelectSubset<T, ExpenseHistoryDeleteArgs<ExtArgs>>): Prisma__ExpenseHistoryClient<$Result.GetResult<Prisma.$ExpenseHistoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ExpenseHistory.
     * @param {ExpenseHistoryUpdateArgs} args - Arguments to update one ExpenseHistory.
     * @example
     * // Update one ExpenseHistory
     * const expenseHistory = await prisma.expenseHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExpenseHistoryUpdateArgs>(args: SelectSubset<T, ExpenseHistoryUpdateArgs<ExtArgs>>): Prisma__ExpenseHistoryClient<$Result.GetResult<Prisma.$ExpenseHistoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ExpenseHistories.
     * @param {ExpenseHistoryDeleteManyArgs} args - Arguments to filter ExpenseHistories to delete.
     * @example
     * // Delete a few ExpenseHistories
     * const { count } = await prisma.expenseHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExpenseHistoryDeleteManyArgs>(args?: SelectSubset<T, ExpenseHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExpenseHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExpenseHistories
     * const expenseHistory = await prisma.expenseHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExpenseHistoryUpdateManyArgs>(args: SelectSubset<T, ExpenseHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ExpenseHistory.
     * @param {ExpenseHistoryUpsertArgs} args - Arguments to update or create a ExpenseHistory.
     * @example
     * // Update or create a ExpenseHistory
     * const expenseHistory = await prisma.expenseHistory.upsert({
     *   create: {
     *     // ... data to create a ExpenseHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExpenseHistory we want to update
     *   }
     * })
     */
    upsert<T extends ExpenseHistoryUpsertArgs>(args: SelectSubset<T, ExpenseHistoryUpsertArgs<ExtArgs>>): Prisma__ExpenseHistoryClient<$Result.GetResult<Prisma.$ExpenseHistoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ExpenseHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseHistoryCountArgs} args - Arguments to filter ExpenseHistories to count.
     * @example
     * // Count the number of ExpenseHistories
     * const count = await prisma.expenseHistory.count({
     *   where: {
     *     // ... the filter for the ExpenseHistories we want to count
     *   }
     * })
    **/
    count<T extends ExpenseHistoryCountArgs>(
      args?: Subset<T, ExpenseHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExpenseHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExpenseHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExpenseHistoryAggregateArgs>(args: Subset<T, ExpenseHistoryAggregateArgs>): Prisma.PrismaPromise<GetExpenseHistoryAggregateType<T>>

    /**
     * Group by ExpenseHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExpenseHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExpenseHistoryGroupByArgs['orderBy'] }
        : { orderBy?: ExpenseHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExpenseHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExpenseHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ExpenseHistory model
   */
  readonly fields: ExpenseHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExpenseHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExpenseHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    expense<T extends ExpenseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ExpenseDefaultArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ExpenseHistory model
   */ 
  interface ExpenseHistoryFieldRefs {
    readonly id: FieldRef<"ExpenseHistory", 'String'>
    readonly expenseId: FieldRef<"ExpenseHistory", 'String'>
    readonly action: FieldRef<"ExpenseHistory", 'ExpenseAction'>
    readonly changedById: FieldRef<"ExpenseHistory", 'String'>
    readonly changedAt: FieldRef<"ExpenseHistory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ExpenseHistory findUnique
   */
  export type ExpenseHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseHistory
     */
    select?: ExpenseHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseHistoryInclude<ExtArgs> | null
    /**
     * Filter, which ExpenseHistory to fetch.
     */
    where: ExpenseHistoryWhereUniqueInput
  }

  /**
   * ExpenseHistory findUniqueOrThrow
   */
  export type ExpenseHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseHistory
     */
    select?: ExpenseHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseHistoryInclude<ExtArgs> | null
    /**
     * Filter, which ExpenseHistory to fetch.
     */
    where: ExpenseHistoryWhereUniqueInput
  }

  /**
   * ExpenseHistory findFirst
   */
  export type ExpenseHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseHistory
     */
    select?: ExpenseHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseHistoryInclude<ExtArgs> | null
    /**
     * Filter, which ExpenseHistory to fetch.
     */
    where?: ExpenseHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExpenseHistories to fetch.
     */
    orderBy?: ExpenseHistoryOrderByWithRelationInput | ExpenseHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExpenseHistories.
     */
    cursor?: ExpenseHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExpenseHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExpenseHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExpenseHistories.
     */
    distinct?: ExpenseHistoryScalarFieldEnum | ExpenseHistoryScalarFieldEnum[]
  }

  /**
   * ExpenseHistory findFirstOrThrow
   */
  export type ExpenseHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseHistory
     */
    select?: ExpenseHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseHistoryInclude<ExtArgs> | null
    /**
     * Filter, which ExpenseHistory to fetch.
     */
    where?: ExpenseHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExpenseHistories to fetch.
     */
    orderBy?: ExpenseHistoryOrderByWithRelationInput | ExpenseHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExpenseHistories.
     */
    cursor?: ExpenseHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExpenseHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExpenseHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExpenseHistories.
     */
    distinct?: ExpenseHistoryScalarFieldEnum | ExpenseHistoryScalarFieldEnum[]
  }

  /**
   * ExpenseHistory findMany
   */
  export type ExpenseHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseHistory
     */
    select?: ExpenseHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseHistoryInclude<ExtArgs> | null
    /**
     * Filter, which ExpenseHistories to fetch.
     */
    where?: ExpenseHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExpenseHistories to fetch.
     */
    orderBy?: ExpenseHistoryOrderByWithRelationInput | ExpenseHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ExpenseHistories.
     */
    cursor?: ExpenseHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExpenseHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExpenseHistories.
     */
    skip?: number
    distinct?: ExpenseHistoryScalarFieldEnum | ExpenseHistoryScalarFieldEnum[]
  }

  /**
   * ExpenseHistory create
   */
  export type ExpenseHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseHistory
     */
    select?: ExpenseHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a ExpenseHistory.
     */
    data: XOR<ExpenseHistoryCreateInput, ExpenseHistoryUncheckedCreateInput>
  }

  /**
   * ExpenseHistory createMany
   */
  export type ExpenseHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ExpenseHistories.
     */
    data: ExpenseHistoryCreateManyInput | ExpenseHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ExpenseHistory createManyAndReturn
   */
  export type ExpenseHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseHistory
     */
    select?: ExpenseHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ExpenseHistories.
     */
    data: ExpenseHistoryCreateManyInput | ExpenseHistoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ExpenseHistory update
   */
  export type ExpenseHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseHistory
     */
    select?: ExpenseHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a ExpenseHistory.
     */
    data: XOR<ExpenseHistoryUpdateInput, ExpenseHistoryUncheckedUpdateInput>
    /**
     * Choose, which ExpenseHistory to update.
     */
    where: ExpenseHistoryWhereUniqueInput
  }

  /**
   * ExpenseHistory updateMany
   */
  export type ExpenseHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ExpenseHistories.
     */
    data: XOR<ExpenseHistoryUpdateManyMutationInput, ExpenseHistoryUncheckedUpdateManyInput>
    /**
     * Filter which ExpenseHistories to update
     */
    where?: ExpenseHistoryWhereInput
  }

  /**
   * ExpenseHistory upsert
   */
  export type ExpenseHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseHistory
     */
    select?: ExpenseHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the ExpenseHistory to update in case it exists.
     */
    where: ExpenseHistoryWhereUniqueInput
    /**
     * In case the ExpenseHistory found by the `where` argument doesn't exist, create a new ExpenseHistory with this data.
     */
    create: XOR<ExpenseHistoryCreateInput, ExpenseHistoryUncheckedCreateInput>
    /**
     * In case the ExpenseHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExpenseHistoryUpdateInput, ExpenseHistoryUncheckedUpdateInput>
  }

  /**
   * ExpenseHistory delete
   */
  export type ExpenseHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseHistory
     */
    select?: ExpenseHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseHistoryInclude<ExtArgs> | null
    /**
     * Filter which ExpenseHistory to delete.
     */
    where: ExpenseHistoryWhereUniqueInput
  }

  /**
   * ExpenseHistory deleteMany
   */
  export type ExpenseHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExpenseHistories to delete
     */
    where?: ExpenseHistoryWhereInput
  }

  /**
   * ExpenseHistory without action
   */
  export type ExpenseHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseHistory
     */
    select?: ExpenseHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseHistoryInclude<ExtArgs> | null
  }


  /**
   * Model Event
   */

  export type AggregateEvent = {
    _count: EventCountAggregateOutputType | null
    _min: EventMinAggregateOutputType | null
    _max: EventMaxAggregateOutputType | null
  }

  export type EventMinAggregateOutputType = {
    id: string | null
    householdId: string | null
    title: string | null
    description: string | null
    startTime: Date | null
    endTime: Date | null
    createdById: string | null
    createdAt: Date | null
    updatedAt: Date | null
    choreId: string | null
    recurrenceRuleId: string | null
    category: $Enums.EventCategory | null
    isAllDay: boolean | null
    location: string | null
    isPrivate: boolean | null
    status: $Enums.EventStatus | null
    deletedAt: Date | null
  }

  export type EventMaxAggregateOutputType = {
    id: string | null
    householdId: string | null
    title: string | null
    description: string | null
    startTime: Date | null
    endTime: Date | null
    createdById: string | null
    createdAt: Date | null
    updatedAt: Date | null
    choreId: string | null
    recurrenceRuleId: string | null
    category: $Enums.EventCategory | null
    isAllDay: boolean | null
    location: string | null
    isPrivate: boolean | null
    status: $Enums.EventStatus | null
    deletedAt: Date | null
  }

  export type EventCountAggregateOutputType = {
    id: number
    householdId: number
    title: number
    description: number
    startTime: number
    endTime: number
    createdById: number
    createdAt: number
    updatedAt: number
    choreId: number
    recurrenceRuleId: number
    category: number
    isAllDay: number
    location: number
    isPrivate: number
    status: number
    deletedAt: number
    _all: number
  }


  export type EventMinAggregateInputType = {
    id?: true
    householdId?: true
    title?: true
    description?: true
    startTime?: true
    endTime?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
    choreId?: true
    recurrenceRuleId?: true
    category?: true
    isAllDay?: true
    location?: true
    isPrivate?: true
    status?: true
    deletedAt?: true
  }

  export type EventMaxAggregateInputType = {
    id?: true
    householdId?: true
    title?: true
    description?: true
    startTime?: true
    endTime?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
    choreId?: true
    recurrenceRuleId?: true
    category?: true
    isAllDay?: true
    location?: true
    isPrivate?: true
    status?: true
    deletedAt?: true
  }

  export type EventCountAggregateInputType = {
    id?: true
    householdId?: true
    title?: true
    description?: true
    startTime?: true
    endTime?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
    choreId?: true
    recurrenceRuleId?: true
    category?: true
    isAllDay?: true
    location?: true
    isPrivate?: true
    status?: true
    deletedAt?: true
    _all?: true
  }

  export type EventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Event to aggregate.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Events
    **/
    _count?: true | EventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EventMaxAggregateInputType
  }

  export type GetEventAggregateType<T extends EventAggregateArgs> = {
        [P in keyof T & keyof AggregateEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvent[P]>
      : GetScalarType<T[P], AggregateEvent[P]>
  }




  export type EventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventWhereInput
    orderBy?: EventOrderByWithAggregationInput | EventOrderByWithAggregationInput[]
    by: EventScalarFieldEnum[] | EventScalarFieldEnum
    having?: EventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EventCountAggregateInputType | true
    _min?: EventMinAggregateInputType
    _max?: EventMaxAggregateInputType
  }

  export type EventGroupByOutputType = {
    id: string
    householdId: string
    title: string
    description: string | null
    startTime: Date
    endTime: Date
    createdById: string
    createdAt: Date
    updatedAt: Date
    choreId: string | null
    recurrenceRuleId: string | null
    category: $Enums.EventCategory
    isAllDay: boolean
    location: string | null
    isPrivate: boolean
    status: $Enums.EventStatus
    deletedAt: Date | null
    _count: EventCountAggregateOutputType | null
    _min: EventMinAggregateOutputType | null
    _max: EventMaxAggregateOutputType | null
  }

  type GetEventGroupByPayload<T extends EventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EventGroupByOutputType[P]>
            : GetScalarType<T[P], EventGroupByOutputType[P]>
        }
      >
    >


  export type EventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    householdId?: boolean
    title?: boolean
    description?: boolean
    startTime?: boolean
    endTime?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    choreId?: boolean
    recurrenceRuleId?: boolean
    category?: boolean
    isAllDay?: boolean
    location?: boolean
    isPrivate?: boolean
    status?: boolean
    deletedAt?: boolean
    reminders?: boolean | Event$remindersArgs<ExtArgs>
    household?: boolean | HouseholdDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    chore?: boolean | Event$choreArgs<ExtArgs>
    recurrenceRule?: boolean | Event$recurrenceRuleArgs<ExtArgs>
    history?: boolean | Event$historyArgs<ExtArgs>
    _count?: boolean | EventCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["event"]>

  export type EventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    householdId?: boolean
    title?: boolean
    description?: boolean
    startTime?: boolean
    endTime?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    choreId?: boolean
    recurrenceRuleId?: boolean
    category?: boolean
    isAllDay?: boolean
    location?: boolean
    isPrivate?: boolean
    status?: boolean
    deletedAt?: boolean
    household?: boolean | HouseholdDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    recurrenceRule?: boolean | Event$recurrenceRuleArgs<ExtArgs>
  }, ExtArgs["result"]["event"]>

  export type EventSelectScalar = {
    id?: boolean
    householdId?: boolean
    title?: boolean
    description?: boolean
    startTime?: boolean
    endTime?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    choreId?: boolean
    recurrenceRuleId?: boolean
    category?: boolean
    isAllDay?: boolean
    location?: boolean
    isPrivate?: boolean
    status?: boolean
    deletedAt?: boolean
  }

  export type EventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reminders?: boolean | Event$remindersArgs<ExtArgs>
    household?: boolean | HouseholdDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    chore?: boolean | Event$choreArgs<ExtArgs>
    recurrenceRule?: boolean | Event$recurrenceRuleArgs<ExtArgs>
    history?: boolean | Event$historyArgs<ExtArgs>
    _count?: boolean | EventCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    household?: boolean | HouseholdDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    recurrenceRule?: boolean | Event$recurrenceRuleArgs<ExtArgs>
  }

  export type $EventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Event"
    objects: {
      reminders: Prisma.$EventReminderPayload<ExtArgs>[]
      household: Prisma.$HouseholdPayload<ExtArgs>
      createdBy: Prisma.$UserPayload<ExtArgs>
      chore: Prisma.$ChorePayload<ExtArgs> | null
      recurrenceRule: Prisma.$RecurrenceRulePayload<ExtArgs> | null
      history: Prisma.$CalendarEventHistoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      householdId: string
      title: string
      description: string | null
      startTime: Date
      endTime: Date
      createdById: string
      createdAt: Date
      updatedAt: Date
      choreId: string | null
      recurrenceRuleId: string | null
      category: $Enums.EventCategory
      isAllDay: boolean
      location: string | null
      isPrivate: boolean
      status: $Enums.EventStatus
      deletedAt: Date | null
    }, ExtArgs["result"]["event"]>
    composites: {}
  }

  type EventGetPayload<S extends boolean | null | undefined | EventDefaultArgs> = $Result.GetResult<Prisma.$EventPayload, S>

  type EventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EventFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EventCountAggregateInputType | true
    }

  export interface EventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Event'], meta: { name: 'Event' } }
    /**
     * Find zero or one Event that matches the filter.
     * @param {EventFindUniqueArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EventFindUniqueArgs>(args: SelectSubset<T, EventFindUniqueArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Event that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EventFindUniqueOrThrowArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EventFindUniqueOrThrowArgs>(args: SelectSubset<T, EventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Event that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindFirstArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EventFindFirstArgs>(args?: SelectSubset<T, EventFindFirstArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Event that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindFirstOrThrowArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EventFindFirstOrThrowArgs>(args?: SelectSubset<T, EventFindFirstOrThrowArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Events that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Events
     * const events = await prisma.event.findMany()
     * 
     * // Get first 10 Events
     * const events = await prisma.event.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eventWithIdOnly = await prisma.event.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EventFindManyArgs>(args?: SelectSubset<T, EventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Event.
     * @param {EventCreateArgs} args - Arguments to create a Event.
     * @example
     * // Create one Event
     * const Event = await prisma.event.create({
     *   data: {
     *     // ... data to create a Event
     *   }
     * })
     * 
     */
    create<T extends EventCreateArgs>(args: SelectSubset<T, EventCreateArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Events.
     * @param {EventCreateManyArgs} args - Arguments to create many Events.
     * @example
     * // Create many Events
     * const event = await prisma.event.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EventCreateManyArgs>(args?: SelectSubset<T, EventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Events and returns the data saved in the database.
     * @param {EventCreateManyAndReturnArgs} args - Arguments to create many Events.
     * @example
     * // Create many Events
     * const event = await prisma.event.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Events and only return the `id`
     * const eventWithIdOnly = await prisma.event.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EventCreateManyAndReturnArgs>(args?: SelectSubset<T, EventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Event.
     * @param {EventDeleteArgs} args - Arguments to delete one Event.
     * @example
     * // Delete one Event
     * const Event = await prisma.event.delete({
     *   where: {
     *     // ... filter to delete one Event
     *   }
     * })
     * 
     */
    delete<T extends EventDeleteArgs>(args: SelectSubset<T, EventDeleteArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Event.
     * @param {EventUpdateArgs} args - Arguments to update one Event.
     * @example
     * // Update one Event
     * const event = await prisma.event.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EventUpdateArgs>(args: SelectSubset<T, EventUpdateArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Events.
     * @param {EventDeleteManyArgs} args - Arguments to filter Events to delete.
     * @example
     * // Delete a few Events
     * const { count } = await prisma.event.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EventDeleteManyArgs>(args?: SelectSubset<T, EventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Events
     * const event = await prisma.event.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EventUpdateManyArgs>(args: SelectSubset<T, EventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Event.
     * @param {EventUpsertArgs} args - Arguments to update or create a Event.
     * @example
     * // Update or create a Event
     * const event = await prisma.event.upsert({
     *   create: {
     *     // ... data to create a Event
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Event we want to update
     *   }
     * })
     */
    upsert<T extends EventUpsertArgs>(args: SelectSubset<T, EventUpsertArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventCountArgs} args - Arguments to filter Events to count.
     * @example
     * // Count the number of Events
     * const count = await prisma.event.count({
     *   where: {
     *     // ... the filter for the Events we want to count
     *   }
     * })
    **/
    count<T extends EventCountArgs>(
      args?: Subset<T, EventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Event.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EventAggregateArgs>(args: Subset<T, EventAggregateArgs>): Prisma.PrismaPromise<GetEventAggregateType<T>>

    /**
     * Group by Event.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EventGroupByArgs['orderBy'] }
        : { orderBy?: EventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Event model
   */
  readonly fields: EventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Event.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    reminders<T extends Event$remindersArgs<ExtArgs> = {}>(args?: Subset<T, Event$remindersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventReminderPayload<ExtArgs>, T, "findMany"> | Null>
    household<T extends HouseholdDefaultArgs<ExtArgs> = {}>(args?: Subset<T, HouseholdDefaultArgs<ExtArgs>>): Prisma__HouseholdClient<$Result.GetResult<Prisma.$HouseholdPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    chore<T extends Event$choreArgs<ExtArgs> = {}>(args?: Subset<T, Event$choreArgs<ExtArgs>>): Prisma__ChoreClient<$Result.GetResult<Prisma.$ChorePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    recurrenceRule<T extends Event$recurrenceRuleArgs<ExtArgs> = {}>(args?: Subset<T, Event$recurrenceRuleArgs<ExtArgs>>): Prisma__RecurrenceRuleClient<$Result.GetResult<Prisma.$RecurrenceRulePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    history<T extends Event$historyArgs<ExtArgs> = {}>(args?: Subset<T, Event$historyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CalendarEventHistoryPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Event model
   */ 
  interface EventFieldRefs {
    readonly id: FieldRef<"Event", 'String'>
    readonly householdId: FieldRef<"Event", 'String'>
    readonly title: FieldRef<"Event", 'String'>
    readonly description: FieldRef<"Event", 'String'>
    readonly startTime: FieldRef<"Event", 'DateTime'>
    readonly endTime: FieldRef<"Event", 'DateTime'>
    readonly createdById: FieldRef<"Event", 'String'>
    readonly createdAt: FieldRef<"Event", 'DateTime'>
    readonly updatedAt: FieldRef<"Event", 'DateTime'>
    readonly choreId: FieldRef<"Event", 'String'>
    readonly recurrenceRuleId: FieldRef<"Event", 'String'>
    readonly category: FieldRef<"Event", 'EventCategory'>
    readonly isAllDay: FieldRef<"Event", 'Boolean'>
    readonly location: FieldRef<"Event", 'String'>
    readonly isPrivate: FieldRef<"Event", 'Boolean'>
    readonly status: FieldRef<"Event", 'EventStatus'>
    readonly deletedAt: FieldRef<"Event", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Event findUnique
   */
  export type EventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event findUniqueOrThrow
   */
  export type EventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event findFirst
   */
  export type EventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Events.
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Events.
     */
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Event findFirstOrThrow
   */
  export type EventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Events.
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Events.
     */
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Event findMany
   */
  export type EventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Events to fetch.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Events.
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Event create
   */
  export type EventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * The data needed to create a Event.
     */
    data: XOR<EventCreateInput, EventUncheckedCreateInput>
  }

  /**
   * Event createMany
   */
  export type EventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Events.
     */
    data: EventCreateManyInput | EventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Event createManyAndReturn
   */
  export type EventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Events.
     */
    data: EventCreateManyInput | EventCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Event update
   */
  export type EventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * The data needed to update a Event.
     */
    data: XOR<EventUpdateInput, EventUncheckedUpdateInput>
    /**
     * Choose, which Event to update.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event updateMany
   */
  export type EventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Events.
     */
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyInput>
    /**
     * Filter which Events to update
     */
    where?: EventWhereInput
  }

  /**
   * Event upsert
   */
  export type EventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * The filter to search for the Event to update in case it exists.
     */
    where: EventWhereUniqueInput
    /**
     * In case the Event found by the `where` argument doesn't exist, create a new Event with this data.
     */
    create: XOR<EventCreateInput, EventUncheckedCreateInput>
    /**
     * In case the Event was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EventUpdateInput, EventUncheckedUpdateInput>
  }

  /**
   * Event delete
   */
  export type EventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter which Event to delete.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event deleteMany
   */
  export type EventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Events to delete
     */
    where?: EventWhereInput
  }

  /**
   * Event.reminders
   */
  export type Event$remindersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventReminder
     */
    select?: EventReminderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventReminderInclude<ExtArgs> | null
    where?: EventReminderWhereInput
    orderBy?: EventReminderOrderByWithRelationInput | EventReminderOrderByWithRelationInput[]
    cursor?: EventReminderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventReminderScalarFieldEnum | EventReminderScalarFieldEnum[]
  }

  /**
   * Event.chore
   */
  export type Event$choreArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chore
     */
    select?: ChoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChoreInclude<ExtArgs> | null
    where?: ChoreWhereInput
  }

  /**
   * Event.recurrenceRule
   */
  export type Event$recurrenceRuleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurrenceRule
     */
    select?: RecurrenceRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurrenceRuleInclude<ExtArgs> | null
    where?: RecurrenceRuleWhereInput
  }

  /**
   * Event.history
   */
  export type Event$historyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEventHistory
     */
    select?: CalendarEventHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventHistoryInclude<ExtArgs> | null
    where?: CalendarEventHistoryWhereInput
    orderBy?: CalendarEventHistoryOrderByWithRelationInput | CalendarEventHistoryOrderByWithRelationInput[]
    cursor?: CalendarEventHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CalendarEventHistoryScalarFieldEnum | CalendarEventHistoryScalarFieldEnum[]
  }

  /**
   * Event without action
   */
  export type EventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
  }


  /**
   * Model EventReminder
   */

  export type AggregateEventReminder = {
    _count: EventReminderCountAggregateOutputType | null
    _min: EventReminderMinAggregateOutputType | null
    _max: EventReminderMaxAggregateOutputType | null
  }

  export type EventReminderMinAggregateOutputType = {
    id: string | null
    eventId: string | null
    time: Date | null
    type: $Enums.EventReminderType | null
  }

  export type EventReminderMaxAggregateOutputType = {
    id: string | null
    eventId: string | null
    time: Date | null
    type: $Enums.EventReminderType | null
  }

  export type EventReminderCountAggregateOutputType = {
    id: number
    eventId: number
    time: number
    type: number
    _all: number
  }


  export type EventReminderMinAggregateInputType = {
    id?: true
    eventId?: true
    time?: true
    type?: true
  }

  export type EventReminderMaxAggregateInputType = {
    id?: true
    eventId?: true
    time?: true
    type?: true
  }

  export type EventReminderCountAggregateInputType = {
    id?: true
    eventId?: true
    time?: true
    type?: true
    _all?: true
  }

  export type EventReminderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EventReminder to aggregate.
     */
    where?: EventReminderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventReminders to fetch.
     */
    orderBy?: EventReminderOrderByWithRelationInput | EventReminderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EventReminderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventReminders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventReminders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EventReminders
    **/
    _count?: true | EventReminderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EventReminderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EventReminderMaxAggregateInputType
  }

  export type GetEventReminderAggregateType<T extends EventReminderAggregateArgs> = {
        [P in keyof T & keyof AggregateEventReminder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEventReminder[P]>
      : GetScalarType<T[P], AggregateEventReminder[P]>
  }




  export type EventReminderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventReminderWhereInput
    orderBy?: EventReminderOrderByWithAggregationInput | EventReminderOrderByWithAggregationInput[]
    by: EventReminderScalarFieldEnum[] | EventReminderScalarFieldEnum
    having?: EventReminderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EventReminderCountAggregateInputType | true
    _min?: EventReminderMinAggregateInputType
    _max?: EventReminderMaxAggregateInputType
  }

  export type EventReminderGroupByOutputType = {
    id: string
    eventId: string
    time: Date
    type: $Enums.EventReminderType
    _count: EventReminderCountAggregateOutputType | null
    _min: EventReminderMinAggregateOutputType | null
    _max: EventReminderMaxAggregateOutputType | null
  }

  type GetEventReminderGroupByPayload<T extends EventReminderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EventReminderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EventReminderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EventReminderGroupByOutputType[P]>
            : GetScalarType<T[P], EventReminderGroupByOutputType[P]>
        }
      >
    >


  export type EventReminderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventId?: boolean
    time?: boolean
    type?: boolean
    event?: boolean | EventDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["eventReminder"]>

  export type EventReminderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventId?: boolean
    time?: boolean
    type?: boolean
    event?: boolean | EventDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["eventReminder"]>

  export type EventReminderSelectScalar = {
    id?: boolean
    eventId?: boolean
    time?: boolean
    type?: boolean
  }

  export type EventReminderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | EventDefaultArgs<ExtArgs>
  }
  export type EventReminderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | EventDefaultArgs<ExtArgs>
  }

  export type $EventReminderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EventReminder"
    objects: {
      event: Prisma.$EventPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      eventId: string
      time: Date
      type: $Enums.EventReminderType
    }, ExtArgs["result"]["eventReminder"]>
    composites: {}
  }

  type EventReminderGetPayload<S extends boolean | null | undefined | EventReminderDefaultArgs> = $Result.GetResult<Prisma.$EventReminderPayload, S>

  type EventReminderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EventReminderFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EventReminderCountAggregateInputType | true
    }

  export interface EventReminderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EventReminder'], meta: { name: 'EventReminder' } }
    /**
     * Find zero or one EventReminder that matches the filter.
     * @param {EventReminderFindUniqueArgs} args - Arguments to find a EventReminder
     * @example
     * // Get one EventReminder
     * const eventReminder = await prisma.eventReminder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EventReminderFindUniqueArgs>(args: SelectSubset<T, EventReminderFindUniqueArgs<ExtArgs>>): Prisma__EventReminderClient<$Result.GetResult<Prisma.$EventReminderPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EventReminder that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EventReminderFindUniqueOrThrowArgs} args - Arguments to find a EventReminder
     * @example
     * // Get one EventReminder
     * const eventReminder = await prisma.eventReminder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EventReminderFindUniqueOrThrowArgs>(args: SelectSubset<T, EventReminderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EventReminderClient<$Result.GetResult<Prisma.$EventReminderPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EventReminder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventReminderFindFirstArgs} args - Arguments to find a EventReminder
     * @example
     * // Get one EventReminder
     * const eventReminder = await prisma.eventReminder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EventReminderFindFirstArgs>(args?: SelectSubset<T, EventReminderFindFirstArgs<ExtArgs>>): Prisma__EventReminderClient<$Result.GetResult<Prisma.$EventReminderPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EventReminder that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventReminderFindFirstOrThrowArgs} args - Arguments to find a EventReminder
     * @example
     * // Get one EventReminder
     * const eventReminder = await prisma.eventReminder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EventReminderFindFirstOrThrowArgs>(args?: SelectSubset<T, EventReminderFindFirstOrThrowArgs<ExtArgs>>): Prisma__EventReminderClient<$Result.GetResult<Prisma.$EventReminderPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EventReminders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventReminderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EventReminders
     * const eventReminders = await prisma.eventReminder.findMany()
     * 
     * // Get first 10 EventReminders
     * const eventReminders = await prisma.eventReminder.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eventReminderWithIdOnly = await prisma.eventReminder.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EventReminderFindManyArgs>(args?: SelectSubset<T, EventReminderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventReminderPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EventReminder.
     * @param {EventReminderCreateArgs} args - Arguments to create a EventReminder.
     * @example
     * // Create one EventReminder
     * const EventReminder = await prisma.eventReminder.create({
     *   data: {
     *     // ... data to create a EventReminder
     *   }
     * })
     * 
     */
    create<T extends EventReminderCreateArgs>(args: SelectSubset<T, EventReminderCreateArgs<ExtArgs>>): Prisma__EventReminderClient<$Result.GetResult<Prisma.$EventReminderPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EventReminders.
     * @param {EventReminderCreateManyArgs} args - Arguments to create many EventReminders.
     * @example
     * // Create many EventReminders
     * const eventReminder = await prisma.eventReminder.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EventReminderCreateManyArgs>(args?: SelectSubset<T, EventReminderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EventReminders and returns the data saved in the database.
     * @param {EventReminderCreateManyAndReturnArgs} args - Arguments to create many EventReminders.
     * @example
     * // Create many EventReminders
     * const eventReminder = await prisma.eventReminder.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EventReminders and only return the `id`
     * const eventReminderWithIdOnly = await prisma.eventReminder.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EventReminderCreateManyAndReturnArgs>(args?: SelectSubset<T, EventReminderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventReminderPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a EventReminder.
     * @param {EventReminderDeleteArgs} args - Arguments to delete one EventReminder.
     * @example
     * // Delete one EventReminder
     * const EventReminder = await prisma.eventReminder.delete({
     *   where: {
     *     // ... filter to delete one EventReminder
     *   }
     * })
     * 
     */
    delete<T extends EventReminderDeleteArgs>(args: SelectSubset<T, EventReminderDeleteArgs<ExtArgs>>): Prisma__EventReminderClient<$Result.GetResult<Prisma.$EventReminderPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EventReminder.
     * @param {EventReminderUpdateArgs} args - Arguments to update one EventReminder.
     * @example
     * // Update one EventReminder
     * const eventReminder = await prisma.eventReminder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EventReminderUpdateArgs>(args: SelectSubset<T, EventReminderUpdateArgs<ExtArgs>>): Prisma__EventReminderClient<$Result.GetResult<Prisma.$EventReminderPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EventReminders.
     * @param {EventReminderDeleteManyArgs} args - Arguments to filter EventReminders to delete.
     * @example
     * // Delete a few EventReminders
     * const { count } = await prisma.eventReminder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EventReminderDeleteManyArgs>(args?: SelectSubset<T, EventReminderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EventReminders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventReminderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EventReminders
     * const eventReminder = await prisma.eventReminder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EventReminderUpdateManyArgs>(args: SelectSubset<T, EventReminderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EventReminder.
     * @param {EventReminderUpsertArgs} args - Arguments to update or create a EventReminder.
     * @example
     * // Update or create a EventReminder
     * const eventReminder = await prisma.eventReminder.upsert({
     *   create: {
     *     // ... data to create a EventReminder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EventReminder we want to update
     *   }
     * })
     */
    upsert<T extends EventReminderUpsertArgs>(args: SelectSubset<T, EventReminderUpsertArgs<ExtArgs>>): Prisma__EventReminderClient<$Result.GetResult<Prisma.$EventReminderPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EventReminders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventReminderCountArgs} args - Arguments to filter EventReminders to count.
     * @example
     * // Count the number of EventReminders
     * const count = await prisma.eventReminder.count({
     *   where: {
     *     // ... the filter for the EventReminders we want to count
     *   }
     * })
    **/
    count<T extends EventReminderCountArgs>(
      args?: Subset<T, EventReminderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventReminderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EventReminder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventReminderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EventReminderAggregateArgs>(args: Subset<T, EventReminderAggregateArgs>): Prisma.PrismaPromise<GetEventReminderAggregateType<T>>

    /**
     * Group by EventReminder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventReminderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EventReminderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EventReminderGroupByArgs['orderBy'] }
        : { orderBy?: EventReminderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EventReminderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventReminderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EventReminder model
   */
  readonly fields: EventReminderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EventReminder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EventReminderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    event<T extends EventDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EventDefaultArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EventReminder model
   */ 
  interface EventReminderFieldRefs {
    readonly id: FieldRef<"EventReminder", 'String'>
    readonly eventId: FieldRef<"EventReminder", 'String'>
    readonly time: FieldRef<"EventReminder", 'DateTime'>
    readonly type: FieldRef<"EventReminder", 'EventReminderType'>
  }
    

  // Custom InputTypes
  /**
   * EventReminder findUnique
   */
  export type EventReminderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventReminder
     */
    select?: EventReminderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventReminderInclude<ExtArgs> | null
    /**
     * Filter, which EventReminder to fetch.
     */
    where: EventReminderWhereUniqueInput
  }

  /**
   * EventReminder findUniqueOrThrow
   */
  export type EventReminderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventReminder
     */
    select?: EventReminderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventReminderInclude<ExtArgs> | null
    /**
     * Filter, which EventReminder to fetch.
     */
    where: EventReminderWhereUniqueInput
  }

  /**
   * EventReminder findFirst
   */
  export type EventReminderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventReminder
     */
    select?: EventReminderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventReminderInclude<ExtArgs> | null
    /**
     * Filter, which EventReminder to fetch.
     */
    where?: EventReminderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventReminders to fetch.
     */
    orderBy?: EventReminderOrderByWithRelationInput | EventReminderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EventReminders.
     */
    cursor?: EventReminderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventReminders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventReminders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EventReminders.
     */
    distinct?: EventReminderScalarFieldEnum | EventReminderScalarFieldEnum[]
  }

  /**
   * EventReminder findFirstOrThrow
   */
  export type EventReminderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventReminder
     */
    select?: EventReminderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventReminderInclude<ExtArgs> | null
    /**
     * Filter, which EventReminder to fetch.
     */
    where?: EventReminderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventReminders to fetch.
     */
    orderBy?: EventReminderOrderByWithRelationInput | EventReminderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EventReminders.
     */
    cursor?: EventReminderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventReminders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventReminders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EventReminders.
     */
    distinct?: EventReminderScalarFieldEnum | EventReminderScalarFieldEnum[]
  }

  /**
   * EventReminder findMany
   */
  export type EventReminderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventReminder
     */
    select?: EventReminderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventReminderInclude<ExtArgs> | null
    /**
     * Filter, which EventReminders to fetch.
     */
    where?: EventReminderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventReminders to fetch.
     */
    orderBy?: EventReminderOrderByWithRelationInput | EventReminderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EventReminders.
     */
    cursor?: EventReminderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventReminders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventReminders.
     */
    skip?: number
    distinct?: EventReminderScalarFieldEnum | EventReminderScalarFieldEnum[]
  }

  /**
   * EventReminder create
   */
  export type EventReminderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventReminder
     */
    select?: EventReminderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventReminderInclude<ExtArgs> | null
    /**
     * The data needed to create a EventReminder.
     */
    data: XOR<EventReminderCreateInput, EventReminderUncheckedCreateInput>
  }

  /**
   * EventReminder createMany
   */
  export type EventReminderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EventReminders.
     */
    data: EventReminderCreateManyInput | EventReminderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EventReminder createManyAndReturn
   */
  export type EventReminderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventReminder
     */
    select?: EventReminderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many EventReminders.
     */
    data: EventReminderCreateManyInput | EventReminderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventReminderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EventReminder update
   */
  export type EventReminderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventReminder
     */
    select?: EventReminderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventReminderInclude<ExtArgs> | null
    /**
     * The data needed to update a EventReminder.
     */
    data: XOR<EventReminderUpdateInput, EventReminderUncheckedUpdateInput>
    /**
     * Choose, which EventReminder to update.
     */
    where: EventReminderWhereUniqueInput
  }

  /**
   * EventReminder updateMany
   */
  export type EventReminderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EventReminders.
     */
    data: XOR<EventReminderUpdateManyMutationInput, EventReminderUncheckedUpdateManyInput>
    /**
     * Filter which EventReminders to update
     */
    where?: EventReminderWhereInput
  }

  /**
   * EventReminder upsert
   */
  export type EventReminderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventReminder
     */
    select?: EventReminderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventReminderInclude<ExtArgs> | null
    /**
     * The filter to search for the EventReminder to update in case it exists.
     */
    where: EventReminderWhereUniqueInput
    /**
     * In case the EventReminder found by the `where` argument doesn't exist, create a new EventReminder with this data.
     */
    create: XOR<EventReminderCreateInput, EventReminderUncheckedCreateInput>
    /**
     * In case the EventReminder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EventReminderUpdateInput, EventReminderUncheckedUpdateInput>
  }

  /**
   * EventReminder delete
   */
  export type EventReminderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventReminder
     */
    select?: EventReminderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventReminderInclude<ExtArgs> | null
    /**
     * Filter which EventReminder to delete.
     */
    where: EventReminderWhereUniqueInput
  }

  /**
   * EventReminder deleteMany
   */
  export type EventReminderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EventReminders to delete
     */
    where?: EventReminderWhereInput
  }

  /**
   * EventReminder without action
   */
  export type EventReminderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventReminder
     */
    select?: EventReminderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventReminderInclude<ExtArgs> | null
  }


  /**
   * Model CalendarEventHistory
   */

  export type AggregateCalendarEventHistory = {
    _count: CalendarEventHistoryCountAggregateOutputType | null
    _min: CalendarEventHistoryMinAggregateOutputType | null
    _max: CalendarEventHistoryMaxAggregateOutputType | null
  }

  export type CalendarEventHistoryMinAggregateOutputType = {
    id: string | null
    eventId: string | null
    action: $Enums.CalendarEventAction | null
    changedById: string | null
    changedAt: Date | null
  }

  export type CalendarEventHistoryMaxAggregateOutputType = {
    id: string | null
    eventId: string | null
    action: $Enums.CalendarEventAction | null
    changedById: string | null
    changedAt: Date | null
  }

  export type CalendarEventHistoryCountAggregateOutputType = {
    id: number
    eventId: number
    action: number
    changedById: number
    changedAt: number
    _all: number
  }


  export type CalendarEventHistoryMinAggregateInputType = {
    id?: true
    eventId?: true
    action?: true
    changedById?: true
    changedAt?: true
  }

  export type CalendarEventHistoryMaxAggregateInputType = {
    id?: true
    eventId?: true
    action?: true
    changedById?: true
    changedAt?: true
  }

  export type CalendarEventHistoryCountAggregateInputType = {
    id?: true
    eventId?: true
    action?: true
    changedById?: true
    changedAt?: true
    _all?: true
  }

  export type CalendarEventHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CalendarEventHistory to aggregate.
     */
    where?: CalendarEventHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CalendarEventHistories to fetch.
     */
    orderBy?: CalendarEventHistoryOrderByWithRelationInput | CalendarEventHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CalendarEventHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CalendarEventHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CalendarEventHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CalendarEventHistories
    **/
    _count?: true | CalendarEventHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CalendarEventHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CalendarEventHistoryMaxAggregateInputType
  }

  export type GetCalendarEventHistoryAggregateType<T extends CalendarEventHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCalendarEventHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCalendarEventHistory[P]>
      : GetScalarType<T[P], AggregateCalendarEventHistory[P]>
  }




  export type CalendarEventHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CalendarEventHistoryWhereInput
    orderBy?: CalendarEventHistoryOrderByWithAggregationInput | CalendarEventHistoryOrderByWithAggregationInput[]
    by: CalendarEventHistoryScalarFieldEnum[] | CalendarEventHistoryScalarFieldEnum
    having?: CalendarEventHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CalendarEventHistoryCountAggregateInputType | true
    _min?: CalendarEventHistoryMinAggregateInputType
    _max?: CalendarEventHistoryMaxAggregateInputType
  }

  export type CalendarEventHistoryGroupByOutputType = {
    id: string
    eventId: string
    action: $Enums.CalendarEventAction
    changedById: string
    changedAt: Date
    _count: CalendarEventHistoryCountAggregateOutputType | null
    _min: CalendarEventHistoryMinAggregateOutputType | null
    _max: CalendarEventHistoryMaxAggregateOutputType | null
  }

  type GetCalendarEventHistoryGroupByPayload<T extends CalendarEventHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CalendarEventHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CalendarEventHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CalendarEventHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], CalendarEventHistoryGroupByOutputType[P]>
        }
      >
    >


  export type CalendarEventHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventId?: boolean
    action?: boolean
    changedById?: boolean
    changedAt?: boolean
    event?: boolean | EventDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["calendarEventHistory"]>

  export type CalendarEventHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventId?: boolean
    action?: boolean
    changedById?: boolean
    changedAt?: boolean
    event?: boolean | EventDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["calendarEventHistory"]>

  export type CalendarEventHistorySelectScalar = {
    id?: boolean
    eventId?: boolean
    action?: boolean
    changedById?: boolean
    changedAt?: boolean
  }

  export type CalendarEventHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | EventDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CalendarEventHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | EventDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CalendarEventHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CalendarEventHistory"
    objects: {
      event: Prisma.$EventPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      eventId: string
      action: $Enums.CalendarEventAction
      changedById: string
      changedAt: Date
    }, ExtArgs["result"]["calendarEventHistory"]>
    composites: {}
  }

  type CalendarEventHistoryGetPayload<S extends boolean | null | undefined | CalendarEventHistoryDefaultArgs> = $Result.GetResult<Prisma.$CalendarEventHistoryPayload, S>

  type CalendarEventHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CalendarEventHistoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CalendarEventHistoryCountAggregateInputType | true
    }

  export interface CalendarEventHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CalendarEventHistory'], meta: { name: 'CalendarEventHistory' } }
    /**
     * Find zero or one CalendarEventHistory that matches the filter.
     * @param {CalendarEventHistoryFindUniqueArgs} args - Arguments to find a CalendarEventHistory
     * @example
     * // Get one CalendarEventHistory
     * const calendarEventHistory = await prisma.calendarEventHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CalendarEventHistoryFindUniqueArgs>(args: SelectSubset<T, CalendarEventHistoryFindUniqueArgs<ExtArgs>>): Prisma__CalendarEventHistoryClient<$Result.GetResult<Prisma.$CalendarEventHistoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CalendarEventHistory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CalendarEventHistoryFindUniqueOrThrowArgs} args - Arguments to find a CalendarEventHistory
     * @example
     * // Get one CalendarEventHistory
     * const calendarEventHistory = await prisma.calendarEventHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CalendarEventHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, CalendarEventHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CalendarEventHistoryClient<$Result.GetResult<Prisma.$CalendarEventHistoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CalendarEventHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarEventHistoryFindFirstArgs} args - Arguments to find a CalendarEventHistory
     * @example
     * // Get one CalendarEventHistory
     * const calendarEventHistory = await prisma.calendarEventHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CalendarEventHistoryFindFirstArgs>(args?: SelectSubset<T, CalendarEventHistoryFindFirstArgs<ExtArgs>>): Prisma__CalendarEventHistoryClient<$Result.GetResult<Prisma.$CalendarEventHistoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CalendarEventHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarEventHistoryFindFirstOrThrowArgs} args - Arguments to find a CalendarEventHistory
     * @example
     * // Get one CalendarEventHistory
     * const calendarEventHistory = await prisma.calendarEventHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CalendarEventHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, CalendarEventHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__CalendarEventHistoryClient<$Result.GetResult<Prisma.$CalendarEventHistoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CalendarEventHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarEventHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CalendarEventHistories
     * const calendarEventHistories = await prisma.calendarEventHistory.findMany()
     * 
     * // Get first 10 CalendarEventHistories
     * const calendarEventHistories = await prisma.calendarEventHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const calendarEventHistoryWithIdOnly = await prisma.calendarEventHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CalendarEventHistoryFindManyArgs>(args?: SelectSubset<T, CalendarEventHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CalendarEventHistoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CalendarEventHistory.
     * @param {CalendarEventHistoryCreateArgs} args - Arguments to create a CalendarEventHistory.
     * @example
     * // Create one CalendarEventHistory
     * const CalendarEventHistory = await prisma.calendarEventHistory.create({
     *   data: {
     *     // ... data to create a CalendarEventHistory
     *   }
     * })
     * 
     */
    create<T extends CalendarEventHistoryCreateArgs>(args: SelectSubset<T, CalendarEventHistoryCreateArgs<ExtArgs>>): Prisma__CalendarEventHistoryClient<$Result.GetResult<Prisma.$CalendarEventHistoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CalendarEventHistories.
     * @param {CalendarEventHistoryCreateManyArgs} args - Arguments to create many CalendarEventHistories.
     * @example
     * // Create many CalendarEventHistories
     * const calendarEventHistory = await prisma.calendarEventHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CalendarEventHistoryCreateManyArgs>(args?: SelectSubset<T, CalendarEventHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CalendarEventHistories and returns the data saved in the database.
     * @param {CalendarEventHistoryCreateManyAndReturnArgs} args - Arguments to create many CalendarEventHistories.
     * @example
     * // Create many CalendarEventHistories
     * const calendarEventHistory = await prisma.calendarEventHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CalendarEventHistories and only return the `id`
     * const calendarEventHistoryWithIdOnly = await prisma.calendarEventHistory.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CalendarEventHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, CalendarEventHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CalendarEventHistoryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CalendarEventHistory.
     * @param {CalendarEventHistoryDeleteArgs} args - Arguments to delete one CalendarEventHistory.
     * @example
     * // Delete one CalendarEventHistory
     * const CalendarEventHistory = await prisma.calendarEventHistory.delete({
     *   where: {
     *     // ... filter to delete one CalendarEventHistory
     *   }
     * })
     * 
     */
    delete<T extends CalendarEventHistoryDeleteArgs>(args: SelectSubset<T, CalendarEventHistoryDeleteArgs<ExtArgs>>): Prisma__CalendarEventHistoryClient<$Result.GetResult<Prisma.$CalendarEventHistoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CalendarEventHistory.
     * @param {CalendarEventHistoryUpdateArgs} args - Arguments to update one CalendarEventHistory.
     * @example
     * // Update one CalendarEventHistory
     * const calendarEventHistory = await prisma.calendarEventHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CalendarEventHistoryUpdateArgs>(args: SelectSubset<T, CalendarEventHistoryUpdateArgs<ExtArgs>>): Prisma__CalendarEventHistoryClient<$Result.GetResult<Prisma.$CalendarEventHistoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CalendarEventHistories.
     * @param {CalendarEventHistoryDeleteManyArgs} args - Arguments to filter CalendarEventHistories to delete.
     * @example
     * // Delete a few CalendarEventHistories
     * const { count } = await prisma.calendarEventHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CalendarEventHistoryDeleteManyArgs>(args?: SelectSubset<T, CalendarEventHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CalendarEventHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarEventHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CalendarEventHistories
     * const calendarEventHistory = await prisma.calendarEventHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CalendarEventHistoryUpdateManyArgs>(args: SelectSubset<T, CalendarEventHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CalendarEventHistory.
     * @param {CalendarEventHistoryUpsertArgs} args - Arguments to update or create a CalendarEventHistory.
     * @example
     * // Update or create a CalendarEventHistory
     * const calendarEventHistory = await prisma.calendarEventHistory.upsert({
     *   create: {
     *     // ... data to create a CalendarEventHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CalendarEventHistory we want to update
     *   }
     * })
     */
    upsert<T extends CalendarEventHistoryUpsertArgs>(args: SelectSubset<T, CalendarEventHistoryUpsertArgs<ExtArgs>>): Prisma__CalendarEventHistoryClient<$Result.GetResult<Prisma.$CalendarEventHistoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CalendarEventHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarEventHistoryCountArgs} args - Arguments to filter CalendarEventHistories to count.
     * @example
     * // Count the number of CalendarEventHistories
     * const count = await prisma.calendarEventHistory.count({
     *   where: {
     *     // ... the filter for the CalendarEventHistories we want to count
     *   }
     * })
    **/
    count<T extends CalendarEventHistoryCountArgs>(
      args?: Subset<T, CalendarEventHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CalendarEventHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CalendarEventHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarEventHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CalendarEventHistoryAggregateArgs>(args: Subset<T, CalendarEventHistoryAggregateArgs>): Prisma.PrismaPromise<GetCalendarEventHistoryAggregateType<T>>

    /**
     * Group by CalendarEventHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarEventHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CalendarEventHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CalendarEventHistoryGroupByArgs['orderBy'] }
        : { orderBy?: CalendarEventHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CalendarEventHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCalendarEventHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CalendarEventHistory model
   */
  readonly fields: CalendarEventHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CalendarEventHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CalendarEventHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    event<T extends EventDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EventDefaultArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CalendarEventHistory model
   */ 
  interface CalendarEventHistoryFieldRefs {
    readonly id: FieldRef<"CalendarEventHistory", 'String'>
    readonly eventId: FieldRef<"CalendarEventHistory", 'String'>
    readonly action: FieldRef<"CalendarEventHistory", 'CalendarEventAction'>
    readonly changedById: FieldRef<"CalendarEventHistory", 'String'>
    readonly changedAt: FieldRef<"CalendarEventHistory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CalendarEventHistory findUnique
   */
  export type CalendarEventHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEventHistory
     */
    select?: CalendarEventHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventHistoryInclude<ExtArgs> | null
    /**
     * Filter, which CalendarEventHistory to fetch.
     */
    where: CalendarEventHistoryWhereUniqueInput
  }

  /**
   * CalendarEventHistory findUniqueOrThrow
   */
  export type CalendarEventHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEventHistory
     */
    select?: CalendarEventHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventHistoryInclude<ExtArgs> | null
    /**
     * Filter, which CalendarEventHistory to fetch.
     */
    where: CalendarEventHistoryWhereUniqueInput
  }

  /**
   * CalendarEventHistory findFirst
   */
  export type CalendarEventHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEventHistory
     */
    select?: CalendarEventHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventHistoryInclude<ExtArgs> | null
    /**
     * Filter, which CalendarEventHistory to fetch.
     */
    where?: CalendarEventHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CalendarEventHistories to fetch.
     */
    orderBy?: CalendarEventHistoryOrderByWithRelationInput | CalendarEventHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CalendarEventHistories.
     */
    cursor?: CalendarEventHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CalendarEventHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CalendarEventHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CalendarEventHistories.
     */
    distinct?: CalendarEventHistoryScalarFieldEnum | CalendarEventHistoryScalarFieldEnum[]
  }

  /**
   * CalendarEventHistory findFirstOrThrow
   */
  export type CalendarEventHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEventHistory
     */
    select?: CalendarEventHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventHistoryInclude<ExtArgs> | null
    /**
     * Filter, which CalendarEventHistory to fetch.
     */
    where?: CalendarEventHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CalendarEventHistories to fetch.
     */
    orderBy?: CalendarEventHistoryOrderByWithRelationInput | CalendarEventHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CalendarEventHistories.
     */
    cursor?: CalendarEventHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CalendarEventHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CalendarEventHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CalendarEventHistories.
     */
    distinct?: CalendarEventHistoryScalarFieldEnum | CalendarEventHistoryScalarFieldEnum[]
  }

  /**
   * CalendarEventHistory findMany
   */
  export type CalendarEventHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEventHistory
     */
    select?: CalendarEventHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventHistoryInclude<ExtArgs> | null
    /**
     * Filter, which CalendarEventHistories to fetch.
     */
    where?: CalendarEventHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CalendarEventHistories to fetch.
     */
    orderBy?: CalendarEventHistoryOrderByWithRelationInput | CalendarEventHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CalendarEventHistories.
     */
    cursor?: CalendarEventHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CalendarEventHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CalendarEventHistories.
     */
    skip?: number
    distinct?: CalendarEventHistoryScalarFieldEnum | CalendarEventHistoryScalarFieldEnum[]
  }

  /**
   * CalendarEventHistory create
   */
  export type CalendarEventHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEventHistory
     */
    select?: CalendarEventHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a CalendarEventHistory.
     */
    data: XOR<CalendarEventHistoryCreateInput, CalendarEventHistoryUncheckedCreateInput>
  }

  /**
   * CalendarEventHistory createMany
   */
  export type CalendarEventHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CalendarEventHistories.
     */
    data: CalendarEventHistoryCreateManyInput | CalendarEventHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CalendarEventHistory createManyAndReturn
   */
  export type CalendarEventHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEventHistory
     */
    select?: CalendarEventHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CalendarEventHistories.
     */
    data: CalendarEventHistoryCreateManyInput | CalendarEventHistoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CalendarEventHistory update
   */
  export type CalendarEventHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEventHistory
     */
    select?: CalendarEventHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a CalendarEventHistory.
     */
    data: XOR<CalendarEventHistoryUpdateInput, CalendarEventHistoryUncheckedUpdateInput>
    /**
     * Choose, which CalendarEventHistory to update.
     */
    where: CalendarEventHistoryWhereUniqueInput
  }

  /**
   * CalendarEventHistory updateMany
   */
  export type CalendarEventHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CalendarEventHistories.
     */
    data: XOR<CalendarEventHistoryUpdateManyMutationInput, CalendarEventHistoryUncheckedUpdateManyInput>
    /**
     * Filter which CalendarEventHistories to update
     */
    where?: CalendarEventHistoryWhereInput
  }

  /**
   * CalendarEventHistory upsert
   */
  export type CalendarEventHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEventHistory
     */
    select?: CalendarEventHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the CalendarEventHistory to update in case it exists.
     */
    where: CalendarEventHistoryWhereUniqueInput
    /**
     * In case the CalendarEventHistory found by the `where` argument doesn't exist, create a new CalendarEventHistory with this data.
     */
    create: XOR<CalendarEventHistoryCreateInput, CalendarEventHistoryUncheckedCreateInput>
    /**
     * In case the CalendarEventHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CalendarEventHistoryUpdateInput, CalendarEventHistoryUncheckedUpdateInput>
  }

  /**
   * CalendarEventHistory delete
   */
  export type CalendarEventHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEventHistory
     */
    select?: CalendarEventHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventHistoryInclude<ExtArgs> | null
    /**
     * Filter which CalendarEventHistory to delete.
     */
    where: CalendarEventHistoryWhereUniqueInput
  }

  /**
   * CalendarEventHistory deleteMany
   */
  export type CalendarEventHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CalendarEventHistories to delete
     */
    where?: CalendarEventHistoryWhereInput
  }

  /**
   * CalendarEventHistory without action
   */
  export type CalendarEventHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEventHistory
     */
    select?: CalendarEventHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEventHistoryInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: $Enums.NotificationType | null
    message: string | null
    isRead: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: $Enums.NotificationType | null
    message: string | null
    isRead: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    message: number
    isRead: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    message?: true
    isRead?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    message?: true
    isRead?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    message?: true
    isRead?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    userId: string
    type: $Enums.NotificationType
    message: string
    isRead: boolean
    createdAt: Date
    updatedAt: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    message?: boolean
    isRead?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    message?: boolean
    isRead?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    message?: boolean
    isRead?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: $Enums.NotificationType
      message: string
      isRead: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */ 
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly userId: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'NotificationType'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly isRead: FieldRef<"Notification", 'Boolean'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
    readonly updatedAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model NotificationSettings
   */

  export type AggregateNotificationSettings = {
    _count: NotificationSettingsCountAggregateOutputType | null
    _min: NotificationSettingsMinAggregateOutputType | null
    _max: NotificationSettingsMaxAggregateOutputType | null
  }

  export type NotificationSettingsMinAggregateOutputType = {
    id: string | null
    userId: string | null
    householdId: string | null
    messageNotif: boolean | null
    mentionsNotif: boolean | null
    reactionsNotif: boolean | null
    choreNotif: boolean | null
    financeNotif: boolean | null
    calendarNotif: boolean | null
    remindersNotif: boolean | null
  }

  export type NotificationSettingsMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    householdId: string | null
    messageNotif: boolean | null
    mentionsNotif: boolean | null
    reactionsNotif: boolean | null
    choreNotif: boolean | null
    financeNotif: boolean | null
    calendarNotif: boolean | null
    remindersNotif: boolean | null
  }

  export type NotificationSettingsCountAggregateOutputType = {
    id: number
    userId: number
    householdId: number
    messageNotif: number
    mentionsNotif: number
    reactionsNotif: number
    choreNotif: number
    financeNotif: number
    calendarNotif: number
    remindersNotif: number
    _all: number
  }


  export type NotificationSettingsMinAggregateInputType = {
    id?: true
    userId?: true
    householdId?: true
    messageNotif?: true
    mentionsNotif?: true
    reactionsNotif?: true
    choreNotif?: true
    financeNotif?: true
    calendarNotif?: true
    remindersNotif?: true
  }

  export type NotificationSettingsMaxAggregateInputType = {
    id?: true
    userId?: true
    householdId?: true
    messageNotif?: true
    mentionsNotif?: true
    reactionsNotif?: true
    choreNotif?: true
    financeNotif?: true
    calendarNotif?: true
    remindersNotif?: true
  }

  export type NotificationSettingsCountAggregateInputType = {
    id?: true
    userId?: true
    householdId?: true
    messageNotif?: true
    mentionsNotif?: true
    reactionsNotif?: true
    choreNotif?: true
    financeNotif?: true
    calendarNotif?: true
    remindersNotif?: true
    _all?: true
  }

  export type NotificationSettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationSettings to aggregate.
     */
    where?: NotificationSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationSettings to fetch.
     */
    orderBy?: NotificationSettingsOrderByWithRelationInput | NotificationSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NotificationSettings
    **/
    _count?: true | NotificationSettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationSettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationSettingsMaxAggregateInputType
  }

  export type GetNotificationSettingsAggregateType<T extends NotificationSettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateNotificationSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotificationSettings[P]>
      : GetScalarType<T[P], AggregateNotificationSettings[P]>
  }




  export type NotificationSettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationSettingsWhereInput
    orderBy?: NotificationSettingsOrderByWithAggregationInput | NotificationSettingsOrderByWithAggregationInput[]
    by: NotificationSettingsScalarFieldEnum[] | NotificationSettingsScalarFieldEnum
    having?: NotificationSettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationSettingsCountAggregateInputType | true
    _min?: NotificationSettingsMinAggregateInputType
    _max?: NotificationSettingsMaxAggregateInputType
  }

  export type NotificationSettingsGroupByOutputType = {
    id: string
    userId: string | null
    householdId: string | null
    messageNotif: boolean
    mentionsNotif: boolean
    reactionsNotif: boolean
    choreNotif: boolean
    financeNotif: boolean
    calendarNotif: boolean
    remindersNotif: boolean
    _count: NotificationSettingsCountAggregateOutputType | null
    _min: NotificationSettingsMinAggregateOutputType | null
    _max: NotificationSettingsMaxAggregateOutputType | null
  }

  type GetNotificationSettingsGroupByPayload<T extends NotificationSettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationSettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationSettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationSettingsGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationSettingsGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    householdId?: boolean
    messageNotif?: boolean
    mentionsNotif?: boolean
    reactionsNotif?: boolean
    choreNotif?: boolean
    financeNotif?: boolean
    calendarNotif?: boolean
    remindersNotif?: boolean
    user?: boolean | NotificationSettings$userArgs<ExtArgs>
    household?: boolean | NotificationSettings$householdArgs<ExtArgs>
  }, ExtArgs["result"]["notificationSettings"]>

  export type NotificationSettingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    householdId?: boolean
    messageNotif?: boolean
    mentionsNotif?: boolean
    reactionsNotif?: boolean
    choreNotif?: boolean
    financeNotif?: boolean
    calendarNotif?: boolean
    remindersNotif?: boolean
    user?: boolean | NotificationSettings$userArgs<ExtArgs>
    household?: boolean | NotificationSettings$householdArgs<ExtArgs>
  }, ExtArgs["result"]["notificationSettings"]>

  export type NotificationSettingsSelectScalar = {
    id?: boolean
    userId?: boolean
    householdId?: boolean
    messageNotif?: boolean
    mentionsNotif?: boolean
    reactionsNotif?: boolean
    choreNotif?: boolean
    financeNotif?: boolean
    calendarNotif?: boolean
    remindersNotif?: boolean
  }

  export type NotificationSettingsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | NotificationSettings$userArgs<ExtArgs>
    household?: boolean | NotificationSettings$householdArgs<ExtArgs>
  }
  export type NotificationSettingsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | NotificationSettings$userArgs<ExtArgs>
    household?: boolean | NotificationSettings$householdArgs<ExtArgs>
  }

  export type $NotificationSettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NotificationSettings"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      household: Prisma.$HouseholdPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      householdId: string | null
      messageNotif: boolean
      mentionsNotif: boolean
      reactionsNotif: boolean
      choreNotif: boolean
      financeNotif: boolean
      calendarNotif: boolean
      remindersNotif: boolean
    }, ExtArgs["result"]["notificationSettings"]>
    composites: {}
  }

  type NotificationSettingsGetPayload<S extends boolean | null | undefined | NotificationSettingsDefaultArgs> = $Result.GetResult<Prisma.$NotificationSettingsPayload, S>

  type NotificationSettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NotificationSettingsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotificationSettingsCountAggregateInputType | true
    }

  export interface NotificationSettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NotificationSettings'], meta: { name: 'NotificationSettings' } }
    /**
     * Find zero or one NotificationSettings that matches the filter.
     * @param {NotificationSettingsFindUniqueArgs} args - Arguments to find a NotificationSettings
     * @example
     * // Get one NotificationSettings
     * const notificationSettings = await prisma.notificationSettings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationSettingsFindUniqueArgs>(args: SelectSubset<T, NotificationSettingsFindUniqueArgs<ExtArgs>>): Prisma__NotificationSettingsClient<$Result.GetResult<Prisma.$NotificationSettingsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one NotificationSettings that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NotificationSettingsFindUniqueOrThrowArgs} args - Arguments to find a NotificationSettings
     * @example
     * // Get one NotificationSettings
     * const notificationSettings = await prisma.notificationSettings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationSettingsFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationSettingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationSettingsClient<$Result.GetResult<Prisma.$NotificationSettingsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first NotificationSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationSettingsFindFirstArgs} args - Arguments to find a NotificationSettings
     * @example
     * // Get one NotificationSettings
     * const notificationSettings = await prisma.notificationSettings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationSettingsFindFirstArgs>(args?: SelectSubset<T, NotificationSettingsFindFirstArgs<ExtArgs>>): Prisma__NotificationSettingsClient<$Result.GetResult<Prisma.$NotificationSettingsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first NotificationSettings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationSettingsFindFirstOrThrowArgs} args - Arguments to find a NotificationSettings
     * @example
     * // Get one NotificationSettings
     * const notificationSettings = await prisma.notificationSettings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationSettingsFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationSettingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationSettingsClient<$Result.GetResult<Prisma.$NotificationSettingsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more NotificationSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationSettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NotificationSettings
     * const notificationSettings = await prisma.notificationSettings.findMany()
     * 
     * // Get first 10 NotificationSettings
     * const notificationSettings = await prisma.notificationSettings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationSettingsWithIdOnly = await prisma.notificationSettings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationSettingsFindManyArgs>(args?: SelectSubset<T, NotificationSettingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationSettingsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a NotificationSettings.
     * @param {NotificationSettingsCreateArgs} args - Arguments to create a NotificationSettings.
     * @example
     * // Create one NotificationSettings
     * const NotificationSettings = await prisma.notificationSettings.create({
     *   data: {
     *     // ... data to create a NotificationSettings
     *   }
     * })
     * 
     */
    create<T extends NotificationSettingsCreateArgs>(args: SelectSubset<T, NotificationSettingsCreateArgs<ExtArgs>>): Prisma__NotificationSettingsClient<$Result.GetResult<Prisma.$NotificationSettingsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many NotificationSettings.
     * @param {NotificationSettingsCreateManyArgs} args - Arguments to create many NotificationSettings.
     * @example
     * // Create many NotificationSettings
     * const notificationSettings = await prisma.notificationSettings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationSettingsCreateManyArgs>(args?: SelectSubset<T, NotificationSettingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NotificationSettings and returns the data saved in the database.
     * @param {NotificationSettingsCreateManyAndReturnArgs} args - Arguments to create many NotificationSettings.
     * @example
     * // Create many NotificationSettings
     * const notificationSettings = await prisma.notificationSettings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NotificationSettings and only return the `id`
     * const notificationSettingsWithIdOnly = await prisma.notificationSettings.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationSettingsCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationSettingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationSettingsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a NotificationSettings.
     * @param {NotificationSettingsDeleteArgs} args - Arguments to delete one NotificationSettings.
     * @example
     * // Delete one NotificationSettings
     * const NotificationSettings = await prisma.notificationSettings.delete({
     *   where: {
     *     // ... filter to delete one NotificationSettings
     *   }
     * })
     * 
     */
    delete<T extends NotificationSettingsDeleteArgs>(args: SelectSubset<T, NotificationSettingsDeleteArgs<ExtArgs>>): Prisma__NotificationSettingsClient<$Result.GetResult<Prisma.$NotificationSettingsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one NotificationSettings.
     * @param {NotificationSettingsUpdateArgs} args - Arguments to update one NotificationSettings.
     * @example
     * // Update one NotificationSettings
     * const notificationSettings = await prisma.notificationSettings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationSettingsUpdateArgs>(args: SelectSubset<T, NotificationSettingsUpdateArgs<ExtArgs>>): Prisma__NotificationSettingsClient<$Result.GetResult<Prisma.$NotificationSettingsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more NotificationSettings.
     * @param {NotificationSettingsDeleteManyArgs} args - Arguments to filter NotificationSettings to delete.
     * @example
     * // Delete a few NotificationSettings
     * const { count } = await prisma.notificationSettings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationSettingsDeleteManyArgs>(args?: SelectSubset<T, NotificationSettingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationSettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NotificationSettings
     * const notificationSettings = await prisma.notificationSettings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationSettingsUpdateManyArgs>(args: SelectSubset<T, NotificationSettingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one NotificationSettings.
     * @param {NotificationSettingsUpsertArgs} args - Arguments to update or create a NotificationSettings.
     * @example
     * // Update or create a NotificationSettings
     * const notificationSettings = await prisma.notificationSettings.upsert({
     *   create: {
     *     // ... data to create a NotificationSettings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NotificationSettings we want to update
     *   }
     * })
     */
    upsert<T extends NotificationSettingsUpsertArgs>(args: SelectSubset<T, NotificationSettingsUpsertArgs<ExtArgs>>): Prisma__NotificationSettingsClient<$Result.GetResult<Prisma.$NotificationSettingsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of NotificationSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationSettingsCountArgs} args - Arguments to filter NotificationSettings to count.
     * @example
     * // Count the number of NotificationSettings
     * const count = await prisma.notificationSettings.count({
     *   where: {
     *     // ... the filter for the NotificationSettings we want to count
     *   }
     * })
    **/
    count<T extends NotificationSettingsCountArgs>(
      args?: Subset<T, NotificationSettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationSettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NotificationSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationSettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationSettingsAggregateArgs>(args: Subset<T, NotificationSettingsAggregateArgs>): Prisma.PrismaPromise<GetNotificationSettingsAggregateType<T>>

    /**
     * Group by NotificationSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationSettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationSettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationSettingsGroupByArgs['orderBy'] }
        : { orderBy?: NotificationSettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationSettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NotificationSettings model
   */
  readonly fields: NotificationSettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NotificationSettings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationSettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends NotificationSettings$userArgs<ExtArgs> = {}>(args?: Subset<T, NotificationSettings$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    household<T extends NotificationSettings$householdArgs<ExtArgs> = {}>(args?: Subset<T, NotificationSettings$householdArgs<ExtArgs>>): Prisma__HouseholdClient<$Result.GetResult<Prisma.$HouseholdPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NotificationSettings model
   */ 
  interface NotificationSettingsFieldRefs {
    readonly id: FieldRef<"NotificationSettings", 'String'>
    readonly userId: FieldRef<"NotificationSettings", 'String'>
    readonly householdId: FieldRef<"NotificationSettings", 'String'>
    readonly messageNotif: FieldRef<"NotificationSettings", 'Boolean'>
    readonly mentionsNotif: FieldRef<"NotificationSettings", 'Boolean'>
    readonly reactionsNotif: FieldRef<"NotificationSettings", 'Boolean'>
    readonly choreNotif: FieldRef<"NotificationSettings", 'Boolean'>
    readonly financeNotif: FieldRef<"NotificationSettings", 'Boolean'>
    readonly calendarNotif: FieldRef<"NotificationSettings", 'Boolean'>
    readonly remindersNotif: FieldRef<"NotificationSettings", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * NotificationSettings findUnique
   */
  export type NotificationSettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSettings
     */
    select?: NotificationSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSettingsInclude<ExtArgs> | null
    /**
     * Filter, which NotificationSettings to fetch.
     */
    where: NotificationSettingsWhereUniqueInput
  }

  /**
   * NotificationSettings findUniqueOrThrow
   */
  export type NotificationSettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSettings
     */
    select?: NotificationSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSettingsInclude<ExtArgs> | null
    /**
     * Filter, which NotificationSettings to fetch.
     */
    where: NotificationSettingsWhereUniqueInput
  }

  /**
   * NotificationSettings findFirst
   */
  export type NotificationSettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSettings
     */
    select?: NotificationSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSettingsInclude<ExtArgs> | null
    /**
     * Filter, which NotificationSettings to fetch.
     */
    where?: NotificationSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationSettings to fetch.
     */
    orderBy?: NotificationSettingsOrderByWithRelationInput | NotificationSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationSettings.
     */
    cursor?: NotificationSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationSettings.
     */
    distinct?: NotificationSettingsScalarFieldEnum | NotificationSettingsScalarFieldEnum[]
  }

  /**
   * NotificationSettings findFirstOrThrow
   */
  export type NotificationSettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSettings
     */
    select?: NotificationSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSettingsInclude<ExtArgs> | null
    /**
     * Filter, which NotificationSettings to fetch.
     */
    where?: NotificationSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationSettings to fetch.
     */
    orderBy?: NotificationSettingsOrderByWithRelationInput | NotificationSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationSettings.
     */
    cursor?: NotificationSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationSettings.
     */
    distinct?: NotificationSettingsScalarFieldEnum | NotificationSettingsScalarFieldEnum[]
  }

  /**
   * NotificationSettings findMany
   */
  export type NotificationSettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSettings
     */
    select?: NotificationSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSettingsInclude<ExtArgs> | null
    /**
     * Filter, which NotificationSettings to fetch.
     */
    where?: NotificationSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationSettings to fetch.
     */
    orderBy?: NotificationSettingsOrderByWithRelationInput | NotificationSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NotificationSettings.
     */
    cursor?: NotificationSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationSettings.
     */
    skip?: number
    distinct?: NotificationSettingsScalarFieldEnum | NotificationSettingsScalarFieldEnum[]
  }

  /**
   * NotificationSettings create
   */
  export type NotificationSettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSettings
     */
    select?: NotificationSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSettingsInclude<ExtArgs> | null
    /**
     * The data needed to create a NotificationSettings.
     */
    data?: XOR<NotificationSettingsCreateInput, NotificationSettingsUncheckedCreateInput>
  }

  /**
   * NotificationSettings createMany
   */
  export type NotificationSettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NotificationSettings.
     */
    data: NotificationSettingsCreateManyInput | NotificationSettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NotificationSettings createManyAndReturn
   */
  export type NotificationSettingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSettings
     */
    select?: NotificationSettingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many NotificationSettings.
     */
    data: NotificationSettingsCreateManyInput | NotificationSettingsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSettingsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NotificationSettings update
   */
  export type NotificationSettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSettings
     */
    select?: NotificationSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSettingsInclude<ExtArgs> | null
    /**
     * The data needed to update a NotificationSettings.
     */
    data: XOR<NotificationSettingsUpdateInput, NotificationSettingsUncheckedUpdateInput>
    /**
     * Choose, which NotificationSettings to update.
     */
    where: NotificationSettingsWhereUniqueInput
  }

  /**
   * NotificationSettings updateMany
   */
  export type NotificationSettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NotificationSettings.
     */
    data: XOR<NotificationSettingsUpdateManyMutationInput, NotificationSettingsUncheckedUpdateManyInput>
    /**
     * Filter which NotificationSettings to update
     */
    where?: NotificationSettingsWhereInput
  }

  /**
   * NotificationSettings upsert
   */
  export type NotificationSettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSettings
     */
    select?: NotificationSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSettingsInclude<ExtArgs> | null
    /**
     * The filter to search for the NotificationSettings to update in case it exists.
     */
    where: NotificationSettingsWhereUniqueInput
    /**
     * In case the NotificationSettings found by the `where` argument doesn't exist, create a new NotificationSettings with this data.
     */
    create: XOR<NotificationSettingsCreateInput, NotificationSettingsUncheckedCreateInput>
    /**
     * In case the NotificationSettings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationSettingsUpdateInput, NotificationSettingsUncheckedUpdateInput>
  }

  /**
   * NotificationSettings delete
   */
  export type NotificationSettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSettings
     */
    select?: NotificationSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSettingsInclude<ExtArgs> | null
    /**
     * Filter which NotificationSettings to delete.
     */
    where: NotificationSettingsWhereUniqueInput
  }

  /**
   * NotificationSettings deleteMany
   */
  export type NotificationSettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationSettings to delete
     */
    where?: NotificationSettingsWhereInput
  }

  /**
   * NotificationSettings.user
   */
  export type NotificationSettings$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * NotificationSettings.household
   */
  export type NotificationSettings$householdArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Household
     */
    select?: HouseholdSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HouseholdInclude<ExtArgs> | null
    where?: HouseholdWhereInput
  }

  /**
   * NotificationSettings without action
   */
  export type NotificationSettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSettings
     */
    select?: NotificationSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSettingsInclude<ExtArgs> | null
  }


  /**
   * Model OAuthIntegration
   */

  export type AggregateOAuthIntegration = {
    _count: OAuthIntegrationCountAggregateOutputType | null
    _min: OAuthIntegrationMinAggregateOutputType | null
    _max: OAuthIntegrationMaxAggregateOutputType | null
  }

  export type OAuthIntegrationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    provider: $Enums.Provider | null
    accessToken: string | null
    refreshToken: string | null
    expiresAt: Date | null
  }

  export type OAuthIntegrationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    provider: $Enums.Provider | null
    accessToken: string | null
    refreshToken: string | null
    expiresAt: Date | null
  }

  export type OAuthIntegrationCountAggregateOutputType = {
    id: number
    userId: number
    provider: number
    accessToken: number
    refreshToken: number
    expiresAt: number
    _all: number
  }


  export type OAuthIntegrationMinAggregateInputType = {
    id?: true
    userId?: true
    provider?: true
    accessToken?: true
    refreshToken?: true
    expiresAt?: true
  }

  export type OAuthIntegrationMaxAggregateInputType = {
    id?: true
    userId?: true
    provider?: true
    accessToken?: true
    refreshToken?: true
    expiresAt?: true
  }

  export type OAuthIntegrationCountAggregateInputType = {
    id?: true
    userId?: true
    provider?: true
    accessToken?: true
    refreshToken?: true
    expiresAt?: true
    _all?: true
  }

  export type OAuthIntegrationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OAuthIntegration to aggregate.
     */
    where?: OAuthIntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OAuthIntegrations to fetch.
     */
    orderBy?: OAuthIntegrationOrderByWithRelationInput | OAuthIntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OAuthIntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OAuthIntegrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OAuthIntegrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OAuthIntegrations
    **/
    _count?: true | OAuthIntegrationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OAuthIntegrationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OAuthIntegrationMaxAggregateInputType
  }

  export type GetOAuthIntegrationAggregateType<T extends OAuthIntegrationAggregateArgs> = {
        [P in keyof T & keyof AggregateOAuthIntegration]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOAuthIntegration[P]>
      : GetScalarType<T[P], AggregateOAuthIntegration[P]>
  }




  export type OAuthIntegrationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OAuthIntegrationWhereInput
    orderBy?: OAuthIntegrationOrderByWithAggregationInput | OAuthIntegrationOrderByWithAggregationInput[]
    by: OAuthIntegrationScalarFieldEnum[] | OAuthIntegrationScalarFieldEnum
    having?: OAuthIntegrationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OAuthIntegrationCountAggregateInputType | true
    _min?: OAuthIntegrationMinAggregateInputType
    _max?: OAuthIntegrationMaxAggregateInputType
  }

  export type OAuthIntegrationGroupByOutputType = {
    id: string
    userId: string
    provider: $Enums.Provider
    accessToken: string
    refreshToken: string | null
    expiresAt: Date | null
    _count: OAuthIntegrationCountAggregateOutputType | null
    _min: OAuthIntegrationMinAggregateOutputType | null
    _max: OAuthIntegrationMaxAggregateOutputType | null
  }

  type GetOAuthIntegrationGroupByPayload<T extends OAuthIntegrationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OAuthIntegrationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OAuthIntegrationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OAuthIntegrationGroupByOutputType[P]>
            : GetScalarType<T[P], OAuthIntegrationGroupByOutputType[P]>
        }
      >
    >


  export type OAuthIntegrationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    provider?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    expiresAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["oAuthIntegration"]>

  export type OAuthIntegrationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    provider?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    expiresAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["oAuthIntegration"]>

  export type OAuthIntegrationSelectScalar = {
    id?: boolean
    userId?: boolean
    provider?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    expiresAt?: boolean
  }

  export type OAuthIntegrationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type OAuthIntegrationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $OAuthIntegrationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OAuthIntegration"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      provider: $Enums.Provider
      accessToken: string
      refreshToken: string | null
      expiresAt: Date | null
    }, ExtArgs["result"]["oAuthIntegration"]>
    composites: {}
  }

  type OAuthIntegrationGetPayload<S extends boolean | null | undefined | OAuthIntegrationDefaultArgs> = $Result.GetResult<Prisma.$OAuthIntegrationPayload, S>

  type OAuthIntegrationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OAuthIntegrationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OAuthIntegrationCountAggregateInputType | true
    }

  export interface OAuthIntegrationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OAuthIntegration'], meta: { name: 'OAuthIntegration' } }
    /**
     * Find zero or one OAuthIntegration that matches the filter.
     * @param {OAuthIntegrationFindUniqueArgs} args - Arguments to find a OAuthIntegration
     * @example
     * // Get one OAuthIntegration
     * const oAuthIntegration = await prisma.oAuthIntegration.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OAuthIntegrationFindUniqueArgs>(args: SelectSubset<T, OAuthIntegrationFindUniqueArgs<ExtArgs>>): Prisma__OAuthIntegrationClient<$Result.GetResult<Prisma.$OAuthIntegrationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one OAuthIntegration that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OAuthIntegrationFindUniqueOrThrowArgs} args - Arguments to find a OAuthIntegration
     * @example
     * // Get one OAuthIntegration
     * const oAuthIntegration = await prisma.oAuthIntegration.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OAuthIntegrationFindUniqueOrThrowArgs>(args: SelectSubset<T, OAuthIntegrationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OAuthIntegrationClient<$Result.GetResult<Prisma.$OAuthIntegrationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first OAuthIntegration that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OAuthIntegrationFindFirstArgs} args - Arguments to find a OAuthIntegration
     * @example
     * // Get one OAuthIntegration
     * const oAuthIntegration = await prisma.oAuthIntegration.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OAuthIntegrationFindFirstArgs>(args?: SelectSubset<T, OAuthIntegrationFindFirstArgs<ExtArgs>>): Prisma__OAuthIntegrationClient<$Result.GetResult<Prisma.$OAuthIntegrationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first OAuthIntegration that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OAuthIntegrationFindFirstOrThrowArgs} args - Arguments to find a OAuthIntegration
     * @example
     * // Get one OAuthIntegration
     * const oAuthIntegration = await prisma.oAuthIntegration.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OAuthIntegrationFindFirstOrThrowArgs>(args?: SelectSubset<T, OAuthIntegrationFindFirstOrThrowArgs<ExtArgs>>): Prisma__OAuthIntegrationClient<$Result.GetResult<Prisma.$OAuthIntegrationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more OAuthIntegrations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OAuthIntegrationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OAuthIntegrations
     * const oAuthIntegrations = await prisma.oAuthIntegration.findMany()
     * 
     * // Get first 10 OAuthIntegrations
     * const oAuthIntegrations = await prisma.oAuthIntegration.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const oAuthIntegrationWithIdOnly = await prisma.oAuthIntegration.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OAuthIntegrationFindManyArgs>(args?: SelectSubset<T, OAuthIntegrationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OAuthIntegrationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a OAuthIntegration.
     * @param {OAuthIntegrationCreateArgs} args - Arguments to create a OAuthIntegration.
     * @example
     * // Create one OAuthIntegration
     * const OAuthIntegration = await prisma.oAuthIntegration.create({
     *   data: {
     *     // ... data to create a OAuthIntegration
     *   }
     * })
     * 
     */
    create<T extends OAuthIntegrationCreateArgs>(args: SelectSubset<T, OAuthIntegrationCreateArgs<ExtArgs>>): Prisma__OAuthIntegrationClient<$Result.GetResult<Prisma.$OAuthIntegrationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many OAuthIntegrations.
     * @param {OAuthIntegrationCreateManyArgs} args - Arguments to create many OAuthIntegrations.
     * @example
     * // Create many OAuthIntegrations
     * const oAuthIntegration = await prisma.oAuthIntegration.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OAuthIntegrationCreateManyArgs>(args?: SelectSubset<T, OAuthIntegrationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OAuthIntegrations and returns the data saved in the database.
     * @param {OAuthIntegrationCreateManyAndReturnArgs} args - Arguments to create many OAuthIntegrations.
     * @example
     * // Create many OAuthIntegrations
     * const oAuthIntegration = await prisma.oAuthIntegration.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OAuthIntegrations and only return the `id`
     * const oAuthIntegrationWithIdOnly = await prisma.oAuthIntegration.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OAuthIntegrationCreateManyAndReturnArgs>(args?: SelectSubset<T, OAuthIntegrationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OAuthIntegrationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a OAuthIntegration.
     * @param {OAuthIntegrationDeleteArgs} args - Arguments to delete one OAuthIntegration.
     * @example
     * // Delete one OAuthIntegration
     * const OAuthIntegration = await prisma.oAuthIntegration.delete({
     *   where: {
     *     // ... filter to delete one OAuthIntegration
     *   }
     * })
     * 
     */
    delete<T extends OAuthIntegrationDeleteArgs>(args: SelectSubset<T, OAuthIntegrationDeleteArgs<ExtArgs>>): Prisma__OAuthIntegrationClient<$Result.GetResult<Prisma.$OAuthIntegrationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one OAuthIntegration.
     * @param {OAuthIntegrationUpdateArgs} args - Arguments to update one OAuthIntegration.
     * @example
     * // Update one OAuthIntegration
     * const oAuthIntegration = await prisma.oAuthIntegration.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OAuthIntegrationUpdateArgs>(args: SelectSubset<T, OAuthIntegrationUpdateArgs<ExtArgs>>): Prisma__OAuthIntegrationClient<$Result.GetResult<Prisma.$OAuthIntegrationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more OAuthIntegrations.
     * @param {OAuthIntegrationDeleteManyArgs} args - Arguments to filter OAuthIntegrations to delete.
     * @example
     * // Delete a few OAuthIntegrations
     * const { count } = await prisma.oAuthIntegration.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OAuthIntegrationDeleteManyArgs>(args?: SelectSubset<T, OAuthIntegrationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OAuthIntegrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OAuthIntegrationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OAuthIntegrations
     * const oAuthIntegration = await prisma.oAuthIntegration.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OAuthIntegrationUpdateManyArgs>(args: SelectSubset<T, OAuthIntegrationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OAuthIntegration.
     * @param {OAuthIntegrationUpsertArgs} args - Arguments to update or create a OAuthIntegration.
     * @example
     * // Update or create a OAuthIntegration
     * const oAuthIntegration = await prisma.oAuthIntegration.upsert({
     *   create: {
     *     // ... data to create a OAuthIntegration
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OAuthIntegration we want to update
     *   }
     * })
     */
    upsert<T extends OAuthIntegrationUpsertArgs>(args: SelectSubset<T, OAuthIntegrationUpsertArgs<ExtArgs>>): Prisma__OAuthIntegrationClient<$Result.GetResult<Prisma.$OAuthIntegrationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of OAuthIntegrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OAuthIntegrationCountArgs} args - Arguments to filter OAuthIntegrations to count.
     * @example
     * // Count the number of OAuthIntegrations
     * const count = await prisma.oAuthIntegration.count({
     *   where: {
     *     // ... the filter for the OAuthIntegrations we want to count
     *   }
     * })
    **/
    count<T extends OAuthIntegrationCountArgs>(
      args?: Subset<T, OAuthIntegrationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OAuthIntegrationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OAuthIntegration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OAuthIntegrationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OAuthIntegrationAggregateArgs>(args: Subset<T, OAuthIntegrationAggregateArgs>): Prisma.PrismaPromise<GetOAuthIntegrationAggregateType<T>>

    /**
     * Group by OAuthIntegration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OAuthIntegrationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OAuthIntegrationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OAuthIntegrationGroupByArgs['orderBy'] }
        : { orderBy?: OAuthIntegrationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OAuthIntegrationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOAuthIntegrationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OAuthIntegration model
   */
  readonly fields: OAuthIntegrationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OAuthIntegration.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OAuthIntegrationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OAuthIntegration model
   */ 
  interface OAuthIntegrationFieldRefs {
    readonly id: FieldRef<"OAuthIntegration", 'String'>
    readonly userId: FieldRef<"OAuthIntegration", 'String'>
    readonly provider: FieldRef<"OAuthIntegration", 'Provider'>
    readonly accessToken: FieldRef<"OAuthIntegration", 'String'>
    readonly refreshToken: FieldRef<"OAuthIntegration", 'String'>
    readonly expiresAt: FieldRef<"OAuthIntegration", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OAuthIntegration findUnique
   */
  export type OAuthIntegrationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthIntegration
     */
    select?: OAuthIntegrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OAuthIntegrationInclude<ExtArgs> | null
    /**
     * Filter, which OAuthIntegration to fetch.
     */
    where: OAuthIntegrationWhereUniqueInput
  }

  /**
   * OAuthIntegration findUniqueOrThrow
   */
  export type OAuthIntegrationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthIntegration
     */
    select?: OAuthIntegrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OAuthIntegrationInclude<ExtArgs> | null
    /**
     * Filter, which OAuthIntegration to fetch.
     */
    where: OAuthIntegrationWhereUniqueInput
  }

  /**
   * OAuthIntegration findFirst
   */
  export type OAuthIntegrationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthIntegration
     */
    select?: OAuthIntegrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OAuthIntegrationInclude<ExtArgs> | null
    /**
     * Filter, which OAuthIntegration to fetch.
     */
    where?: OAuthIntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OAuthIntegrations to fetch.
     */
    orderBy?: OAuthIntegrationOrderByWithRelationInput | OAuthIntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OAuthIntegrations.
     */
    cursor?: OAuthIntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OAuthIntegrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OAuthIntegrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OAuthIntegrations.
     */
    distinct?: OAuthIntegrationScalarFieldEnum | OAuthIntegrationScalarFieldEnum[]
  }

  /**
   * OAuthIntegration findFirstOrThrow
   */
  export type OAuthIntegrationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthIntegration
     */
    select?: OAuthIntegrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OAuthIntegrationInclude<ExtArgs> | null
    /**
     * Filter, which OAuthIntegration to fetch.
     */
    where?: OAuthIntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OAuthIntegrations to fetch.
     */
    orderBy?: OAuthIntegrationOrderByWithRelationInput | OAuthIntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OAuthIntegrations.
     */
    cursor?: OAuthIntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OAuthIntegrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OAuthIntegrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OAuthIntegrations.
     */
    distinct?: OAuthIntegrationScalarFieldEnum | OAuthIntegrationScalarFieldEnum[]
  }

  /**
   * OAuthIntegration findMany
   */
  export type OAuthIntegrationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthIntegration
     */
    select?: OAuthIntegrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OAuthIntegrationInclude<ExtArgs> | null
    /**
     * Filter, which OAuthIntegrations to fetch.
     */
    where?: OAuthIntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OAuthIntegrations to fetch.
     */
    orderBy?: OAuthIntegrationOrderByWithRelationInput | OAuthIntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OAuthIntegrations.
     */
    cursor?: OAuthIntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OAuthIntegrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OAuthIntegrations.
     */
    skip?: number
    distinct?: OAuthIntegrationScalarFieldEnum | OAuthIntegrationScalarFieldEnum[]
  }

  /**
   * OAuthIntegration create
   */
  export type OAuthIntegrationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthIntegration
     */
    select?: OAuthIntegrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OAuthIntegrationInclude<ExtArgs> | null
    /**
     * The data needed to create a OAuthIntegration.
     */
    data: XOR<OAuthIntegrationCreateInput, OAuthIntegrationUncheckedCreateInput>
  }

  /**
   * OAuthIntegration createMany
   */
  export type OAuthIntegrationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OAuthIntegrations.
     */
    data: OAuthIntegrationCreateManyInput | OAuthIntegrationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OAuthIntegration createManyAndReturn
   */
  export type OAuthIntegrationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthIntegration
     */
    select?: OAuthIntegrationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many OAuthIntegrations.
     */
    data: OAuthIntegrationCreateManyInput | OAuthIntegrationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OAuthIntegrationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OAuthIntegration update
   */
  export type OAuthIntegrationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthIntegration
     */
    select?: OAuthIntegrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OAuthIntegrationInclude<ExtArgs> | null
    /**
     * The data needed to update a OAuthIntegration.
     */
    data: XOR<OAuthIntegrationUpdateInput, OAuthIntegrationUncheckedUpdateInput>
    /**
     * Choose, which OAuthIntegration to update.
     */
    where: OAuthIntegrationWhereUniqueInput
  }

  /**
   * OAuthIntegration updateMany
   */
  export type OAuthIntegrationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OAuthIntegrations.
     */
    data: XOR<OAuthIntegrationUpdateManyMutationInput, OAuthIntegrationUncheckedUpdateManyInput>
    /**
     * Filter which OAuthIntegrations to update
     */
    where?: OAuthIntegrationWhereInput
  }

  /**
   * OAuthIntegration upsert
   */
  export type OAuthIntegrationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthIntegration
     */
    select?: OAuthIntegrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OAuthIntegrationInclude<ExtArgs> | null
    /**
     * The filter to search for the OAuthIntegration to update in case it exists.
     */
    where: OAuthIntegrationWhereUniqueInput
    /**
     * In case the OAuthIntegration found by the `where` argument doesn't exist, create a new OAuthIntegration with this data.
     */
    create: XOR<OAuthIntegrationCreateInput, OAuthIntegrationUncheckedCreateInput>
    /**
     * In case the OAuthIntegration was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OAuthIntegrationUpdateInput, OAuthIntegrationUncheckedUpdateInput>
  }

  /**
   * OAuthIntegration delete
   */
  export type OAuthIntegrationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthIntegration
     */
    select?: OAuthIntegrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OAuthIntegrationInclude<ExtArgs> | null
    /**
     * Filter which OAuthIntegration to delete.
     */
    where: OAuthIntegrationWhereUniqueInput
  }

  /**
   * OAuthIntegration deleteMany
   */
  export type OAuthIntegrationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OAuthIntegrations to delete
     */
    where?: OAuthIntegrationWhereInput
  }

  /**
   * OAuthIntegration without action
   */
  export type OAuthIntegrationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthIntegration
     */
    select?: OAuthIntegrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OAuthIntegrationInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    passwordHash: 'passwordHash',
    name: 'name',
    profileImageURL: 'profileImageURL',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deviceTokens: 'deviceTokens',
    deletedAt: 'deletedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const HouseholdScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    currency: 'currency',
    icon: 'icon',
    timezone: 'timezone',
    language: 'language',
    deletedAt: 'deletedAt'
  };

  export type HouseholdScalarFieldEnum = (typeof HouseholdScalarFieldEnum)[keyof typeof HouseholdScalarFieldEnum]


  export const HouseholdMemberScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    householdId: 'householdId',
    role: 'role',
    joinedAt: 'joinedAt',
    leftAt: 'leftAt',
    isInvited: 'isInvited',
    isAccepted: 'isAccepted',
    isRejected: 'isRejected',
    isSelected: 'isSelected',
    lastAssignedChoreAt: 'lastAssignedChoreAt'
  };

  export type HouseholdMemberScalarFieldEnum = (typeof HouseholdMemberScalarFieldEnum)[keyof typeof HouseholdMemberScalarFieldEnum]


  export const RecurrenceRuleScalarFieldEnum: {
    id: 'id',
    frequency: 'frequency',
    interval: 'interval',
    byWeekDay: 'byWeekDay',
    byMonthDay: 'byMonthDay',
    bySetPos: 'bySetPos',
    count: 'count',
    until: 'until',
    customRuleString: 'customRuleString'
  };

  export type RecurrenceRuleScalarFieldEnum = (typeof RecurrenceRuleScalarFieldEnum)[keyof typeof RecurrenceRuleScalarFieldEnum]


  export const ThreadScalarFieldEnum: {
    id: 'id',
    householdId: 'householdId',
    authorId: 'authorId',
    title: 'title',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type ThreadScalarFieldEnum = (typeof ThreadScalarFieldEnum)[keyof typeof ThreadScalarFieldEnum]


  export const MessageScalarFieldEnum: {
    id: 'id',
    threadId: 'threadId',
    authorId: 'authorId',
    content: 'content',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type MessageScalarFieldEnum = (typeof MessageScalarFieldEnum)[keyof typeof MessageScalarFieldEnum]


  export const ReactionScalarFieldEnum: {
    id: 'id',
    messageId: 'messageId',
    userId: 'userId',
    emoji: 'emoji',
    type: 'type',
    createdAt: 'createdAt'
  };

  export type ReactionScalarFieldEnum = (typeof ReactionScalarFieldEnum)[keyof typeof ReactionScalarFieldEnum]


  export const MentionScalarFieldEnum: {
    id: 'id',
    messageId: 'messageId',
    userId: 'userId',
    mentionedAt: 'mentionedAt'
  };

  export type MentionScalarFieldEnum = (typeof MentionScalarFieldEnum)[keyof typeof MentionScalarFieldEnum]


  export const AttachmentScalarFieldEnum: {
    id: 'id',
    messageId: 'messageId',
    url: 'url',
    fileType: 'fileType',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type AttachmentScalarFieldEnum = (typeof AttachmentScalarFieldEnum)[keyof typeof AttachmentScalarFieldEnum]


  export const MessageReadScalarFieldEnum: {
    id: 'id',
    messageId: 'messageId',
    userId: 'userId',
    readAt: 'readAt'
  };

  export type MessageReadScalarFieldEnum = (typeof MessageReadScalarFieldEnum)[keyof typeof MessageReadScalarFieldEnum]


  export const ChoreScalarFieldEnum: {
    id: 'id',
    householdId: 'householdId',
    title: 'title',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    dueDate: 'dueDate',
    status: 'status',
    priority: 'priority',
    eventId: 'eventId',
    recurrenceRuleId: 'recurrenceRuleId',
    deletedAt: 'deletedAt'
  };

  export type ChoreScalarFieldEnum = (typeof ChoreScalarFieldEnum)[keyof typeof ChoreScalarFieldEnum]


  export const SubtaskScalarFieldEnum: {
    id: 'id',
    choreId: 'choreId',
    title: 'title',
    description: 'description',
    status: 'status'
  };

  export type SubtaskScalarFieldEnum = (typeof SubtaskScalarFieldEnum)[keyof typeof SubtaskScalarFieldEnum]


  export const ChoreAssignmentScalarFieldEnum: {
    id: 'id',
    choreId: 'choreId',
    userId: 'userId',
    assignedAt: 'assignedAt',
    completedAt: 'completedAt'
  };

  export type ChoreAssignmentScalarFieldEnum = (typeof ChoreAssignmentScalarFieldEnum)[keyof typeof ChoreAssignmentScalarFieldEnum]


  export const ChoreSwapRequestScalarFieldEnum: {
    id: 'id',
    choreId: 'choreId',
    requestingUserId: 'requestingUserId',
    targetUserId: 'targetUserId',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ChoreSwapRequestScalarFieldEnum = (typeof ChoreSwapRequestScalarFieldEnum)[keyof typeof ChoreSwapRequestScalarFieldEnum]


  export const ChoreTemplateScalarFieldEnum: {
    id: 'id',
    householdId: 'householdId',
    title: 'title',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ChoreTemplateScalarFieldEnum = (typeof ChoreTemplateScalarFieldEnum)[keyof typeof ChoreTemplateScalarFieldEnum]


  export const SubtaskTemplateScalarFieldEnum: {
    id: 'id',
    choreTemplateId: 'choreTemplateId',
    title: 'title',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SubtaskTemplateScalarFieldEnum = (typeof SubtaskTemplateScalarFieldEnum)[keyof typeof SubtaskTemplateScalarFieldEnum]


  export const ChoreHistoryScalarFieldEnum: {
    id: 'id',
    choreId: 'choreId',
    action: 'action',
    changedById: 'changedById',
    changedAt: 'changedAt'
  };

  export type ChoreHistoryScalarFieldEnum = (typeof ChoreHistoryScalarFieldEnum)[keyof typeof ChoreHistoryScalarFieldEnum]


  export const ExpenseScalarFieldEnum: {
    id: 'id',
    householdId: 'householdId',
    amount: 'amount',
    description: 'description',
    paidById: 'paidById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    dueDate: 'dueDate',
    deletedAt: 'deletedAt',
    category: 'category'
  };

  export type ExpenseScalarFieldEnum = (typeof ExpenseScalarFieldEnum)[keyof typeof ExpenseScalarFieldEnum]


  export const ExpenseSplitScalarFieldEnum: {
    id: 'id',
    expenseId: 'expenseId',
    userId: 'userId',
    amount: 'amount'
  };

  export type ExpenseSplitScalarFieldEnum = (typeof ExpenseSplitScalarFieldEnum)[keyof typeof ExpenseSplitScalarFieldEnum]


  export const TransactionScalarFieldEnum: {
    id: 'id',
    expenseId: 'expenseId',
    fromUserId: 'fromUserId',
    toUserId: 'toUserId',
    amount: 'amount',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type TransactionScalarFieldEnum = (typeof TransactionScalarFieldEnum)[keyof typeof TransactionScalarFieldEnum]


  export const ReceiptScalarFieldEnum: {
    id: 'id',
    expenseId: 'expenseId',
    url: 'url',
    fileType: 'fileType',
    createdAt: 'createdAt'
  };

  export type ReceiptScalarFieldEnum = (typeof ReceiptScalarFieldEnum)[keyof typeof ReceiptScalarFieldEnum]


  export const ExpenseHistoryScalarFieldEnum: {
    id: 'id',
    expenseId: 'expenseId',
    action: 'action',
    changedById: 'changedById',
    changedAt: 'changedAt'
  };

  export type ExpenseHistoryScalarFieldEnum = (typeof ExpenseHistoryScalarFieldEnum)[keyof typeof ExpenseHistoryScalarFieldEnum]


  export const EventScalarFieldEnum: {
    id: 'id',
    householdId: 'householdId',
    title: 'title',
    description: 'description',
    startTime: 'startTime',
    endTime: 'endTime',
    createdById: 'createdById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    choreId: 'choreId',
    recurrenceRuleId: 'recurrenceRuleId',
    category: 'category',
    isAllDay: 'isAllDay',
    location: 'location',
    isPrivate: 'isPrivate',
    status: 'status',
    deletedAt: 'deletedAt'
  };

  export type EventScalarFieldEnum = (typeof EventScalarFieldEnum)[keyof typeof EventScalarFieldEnum]


  export const EventReminderScalarFieldEnum: {
    id: 'id',
    eventId: 'eventId',
    time: 'time',
    type: 'type'
  };

  export type EventReminderScalarFieldEnum = (typeof EventReminderScalarFieldEnum)[keyof typeof EventReminderScalarFieldEnum]


  export const CalendarEventHistoryScalarFieldEnum: {
    id: 'id',
    eventId: 'eventId',
    action: 'action',
    changedById: 'changedById',
    changedAt: 'changedAt'
  };

  export type CalendarEventHistoryScalarFieldEnum = (typeof CalendarEventHistoryScalarFieldEnum)[keyof typeof CalendarEventHistoryScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    message: 'message',
    isRead: 'isRead',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const NotificationSettingsScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    householdId: 'householdId',
    messageNotif: 'messageNotif',
    mentionsNotif: 'mentionsNotif',
    reactionsNotif: 'reactionsNotif',
    choreNotif: 'choreNotif',
    financeNotif: 'financeNotif',
    calendarNotif: 'calendarNotif',
    remindersNotif: 'remindersNotif'
  };

  export type NotificationSettingsScalarFieldEnum = (typeof NotificationSettingsScalarFieldEnum)[keyof typeof NotificationSettingsScalarFieldEnum]


  export const OAuthIntegrationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    provider: 'provider',
    accessToken: 'accessToken',
    refreshToken: 'refreshToken',
    expiresAt: 'expiresAt'
  };

  export type OAuthIntegrationScalarFieldEnum = (typeof OAuthIntegrationScalarFieldEnum)[keyof typeof OAuthIntegrationScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'HouseholdRole'
   */
  export type EnumHouseholdRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'HouseholdRole'>
    


  /**
   * Reference to a field of type 'HouseholdRole[]'
   */
  export type ListEnumHouseholdRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'HouseholdRole[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'RecurrenceFrequency'
   */
  export type EnumRecurrenceFrequencyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RecurrenceFrequency'>
    


  /**
   * Reference to a field of type 'RecurrenceFrequency[]'
   */
  export type ListEnumRecurrenceFrequencyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RecurrenceFrequency[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'DaysOfWeek[]'
   */
  export type ListEnumDaysOfWeekFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DaysOfWeek[]'>
    


  /**
   * Reference to a field of type 'DaysOfWeek'
   */
  export type EnumDaysOfWeekFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DaysOfWeek'>
    


  /**
   * Reference to a field of type 'ReactionType'
   */
  export type EnumReactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReactionType'>
    


  /**
   * Reference to a field of type 'ReactionType[]'
   */
  export type ListEnumReactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReactionType[]'>
    


  /**
   * Reference to a field of type 'ChoreStatus'
   */
  export type EnumChoreStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ChoreStatus'>
    


  /**
   * Reference to a field of type 'ChoreStatus[]'
   */
  export type ListEnumChoreStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ChoreStatus[]'>
    


  /**
   * Reference to a field of type 'SubtaskStatus'
   */
  export type EnumSubtaskStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubtaskStatus'>
    


  /**
   * Reference to a field of type 'SubtaskStatus[]'
   */
  export type ListEnumSubtaskStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubtaskStatus[]'>
    


  /**
   * Reference to a field of type 'ChoreSwapRequestStatus'
   */
  export type EnumChoreSwapRequestStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ChoreSwapRequestStatus'>
    


  /**
   * Reference to a field of type 'ChoreSwapRequestStatus[]'
   */
  export type ListEnumChoreSwapRequestStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ChoreSwapRequestStatus[]'>
    


  /**
   * Reference to a field of type 'ChoreAction'
   */
  export type EnumChoreActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ChoreAction'>
    


  /**
   * Reference to a field of type 'ChoreAction[]'
   */
  export type ListEnumChoreActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ChoreAction[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'ExpenseCategory'
   */
  export type EnumExpenseCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ExpenseCategory'>
    


  /**
   * Reference to a field of type 'ExpenseCategory[]'
   */
  export type ListEnumExpenseCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ExpenseCategory[]'>
    


  /**
   * Reference to a field of type 'TransactionStatus'
   */
  export type EnumTransactionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionStatus'>
    


  /**
   * Reference to a field of type 'TransactionStatus[]'
   */
  export type ListEnumTransactionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionStatus[]'>
    


  /**
   * Reference to a field of type 'ExpenseAction'
   */
  export type EnumExpenseActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ExpenseAction'>
    


  /**
   * Reference to a field of type 'ExpenseAction[]'
   */
  export type ListEnumExpenseActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ExpenseAction[]'>
    


  /**
   * Reference to a field of type 'EventCategory'
   */
  export type EnumEventCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EventCategory'>
    


  /**
   * Reference to a field of type 'EventCategory[]'
   */
  export type ListEnumEventCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EventCategory[]'>
    


  /**
   * Reference to a field of type 'EventStatus'
   */
  export type EnumEventStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EventStatus'>
    


  /**
   * Reference to a field of type 'EventStatus[]'
   */
  export type ListEnumEventStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EventStatus[]'>
    


  /**
   * Reference to a field of type 'EventReminderType'
   */
  export type EnumEventReminderTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EventReminderType'>
    


  /**
   * Reference to a field of type 'EventReminderType[]'
   */
  export type ListEnumEventReminderTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EventReminderType[]'>
    


  /**
   * Reference to a field of type 'CalendarEventAction'
   */
  export type EnumCalendarEventActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CalendarEventAction'>
    


  /**
   * Reference to a field of type 'CalendarEventAction[]'
   */
  export type ListEnumCalendarEventActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CalendarEventAction[]'>
    


  /**
   * Reference to a field of type 'NotificationType'
   */
  export type EnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType'>
    


  /**
   * Reference to a field of type 'NotificationType[]'
   */
  export type ListEnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType[]'>
    


  /**
   * Reference to a field of type 'Provider'
   */
  export type EnumProviderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Provider'>
    


  /**
   * Reference to a field of type 'Provider[]'
   */
  export type ListEnumProviderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Provider[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    passwordHash?: StringNullableFilter<"User"> | string | null
    name?: StringFilter<"User"> | string
    profileImageURL?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    deviceTokens?: StringNullableListFilter<"User">
    deletedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    households?: HouseholdMemberListRelationFilter
    messages?: MessageListRelationFilter
    threads?: ThreadListRelationFilter
    assignedChores?: ChoreAssignmentListRelationFilter
    expensesPaid?: ExpenseListRelationFilter
    expenseSplits?: ExpenseSplitListRelationFilter
    transactionsFrom?: TransactionListRelationFilter
    transactionsTo?: TransactionListRelationFilter
    notifications?: NotificationListRelationFilter
    oauthIntegrations?: OAuthIntegrationListRelationFilter
    eventsCreated?: EventListRelationFilter
    choreSwapRequestsInitiated?: ChoreSwapRequestListRelationFilter
    choreSwapRequestsReceived?: ChoreSwapRequestListRelationFilter
    reactions?: ReactionListRelationFilter
    mentions?: MentionListRelationFilter
    choreHistory?: ChoreHistoryListRelationFilter
    notificationSettings?: NotificationSettingsListRelationFilter
    calendarEventHistory?: CalendarEventHistoryListRelationFilter
    expenseHistory?: ExpenseHistoryListRelationFilter
    messageReads?: MessageReadListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrderInput | SortOrder
    name?: SortOrder
    profileImageURL?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deviceTokens?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    households?: HouseholdMemberOrderByRelationAggregateInput
    messages?: MessageOrderByRelationAggregateInput
    threads?: ThreadOrderByRelationAggregateInput
    assignedChores?: ChoreAssignmentOrderByRelationAggregateInput
    expensesPaid?: ExpenseOrderByRelationAggregateInput
    expenseSplits?: ExpenseSplitOrderByRelationAggregateInput
    transactionsFrom?: TransactionOrderByRelationAggregateInput
    transactionsTo?: TransactionOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    oauthIntegrations?: OAuthIntegrationOrderByRelationAggregateInput
    eventsCreated?: EventOrderByRelationAggregateInput
    choreSwapRequestsInitiated?: ChoreSwapRequestOrderByRelationAggregateInput
    choreSwapRequestsReceived?: ChoreSwapRequestOrderByRelationAggregateInput
    reactions?: ReactionOrderByRelationAggregateInput
    mentions?: MentionOrderByRelationAggregateInput
    choreHistory?: ChoreHistoryOrderByRelationAggregateInput
    notificationSettings?: NotificationSettingsOrderByRelationAggregateInput
    calendarEventHistory?: CalendarEventHistoryOrderByRelationAggregateInput
    expenseHistory?: ExpenseHistoryOrderByRelationAggregateInput
    messageReads?: MessageReadOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    passwordHash?: StringNullableFilter<"User"> | string | null
    name?: StringFilter<"User"> | string
    profileImageURL?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    deviceTokens?: StringNullableListFilter<"User">
    deletedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    households?: HouseholdMemberListRelationFilter
    messages?: MessageListRelationFilter
    threads?: ThreadListRelationFilter
    assignedChores?: ChoreAssignmentListRelationFilter
    expensesPaid?: ExpenseListRelationFilter
    expenseSplits?: ExpenseSplitListRelationFilter
    transactionsFrom?: TransactionListRelationFilter
    transactionsTo?: TransactionListRelationFilter
    notifications?: NotificationListRelationFilter
    oauthIntegrations?: OAuthIntegrationListRelationFilter
    eventsCreated?: EventListRelationFilter
    choreSwapRequestsInitiated?: ChoreSwapRequestListRelationFilter
    choreSwapRequestsReceived?: ChoreSwapRequestListRelationFilter
    reactions?: ReactionListRelationFilter
    mentions?: MentionListRelationFilter
    choreHistory?: ChoreHistoryListRelationFilter
    notificationSettings?: NotificationSettingsListRelationFilter
    calendarEventHistory?: CalendarEventHistoryListRelationFilter
    expenseHistory?: ExpenseHistoryListRelationFilter
    messageReads?: MessageReadListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrderInput | SortOrder
    name?: SortOrder
    profileImageURL?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deviceTokens?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    passwordHash?: StringNullableWithAggregatesFilter<"User"> | string | null
    name?: StringWithAggregatesFilter<"User"> | string
    profileImageURL?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    deviceTokens?: StringNullableListFilter<"User">
    deletedAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
  }

  export type HouseholdWhereInput = {
    AND?: HouseholdWhereInput | HouseholdWhereInput[]
    OR?: HouseholdWhereInput[]
    NOT?: HouseholdWhereInput | HouseholdWhereInput[]
    id?: StringFilter<"Household"> | string
    name?: StringFilter<"Household"> | string
    createdAt?: DateTimeFilter<"Household"> | Date | string
    updatedAt?: DateTimeFilter<"Household"> | Date | string
    currency?: StringFilter<"Household"> | string
    icon?: StringNullableFilter<"Household"> | string | null
    timezone?: StringFilter<"Household"> | string
    language?: StringFilter<"Household"> | string
    deletedAt?: DateTimeNullableFilter<"Household"> | Date | string | null
    members?: HouseholdMemberListRelationFilter
    threads?: ThreadListRelationFilter
    chores?: ChoreListRelationFilter
    expenses?: ExpenseListRelationFilter
    events?: EventListRelationFilter
    choreTemplates?: ChoreTemplateListRelationFilter
    notificationSettings?: NotificationSettingsListRelationFilter
  }

  export type HouseholdOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    currency?: SortOrder
    icon?: SortOrderInput | SortOrder
    timezone?: SortOrder
    language?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    members?: HouseholdMemberOrderByRelationAggregateInput
    threads?: ThreadOrderByRelationAggregateInput
    chores?: ChoreOrderByRelationAggregateInput
    expenses?: ExpenseOrderByRelationAggregateInput
    events?: EventOrderByRelationAggregateInput
    choreTemplates?: ChoreTemplateOrderByRelationAggregateInput
    notificationSettings?: NotificationSettingsOrderByRelationAggregateInput
  }

  export type HouseholdWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: HouseholdWhereInput | HouseholdWhereInput[]
    OR?: HouseholdWhereInput[]
    NOT?: HouseholdWhereInput | HouseholdWhereInput[]
    name?: StringFilter<"Household"> | string
    createdAt?: DateTimeFilter<"Household"> | Date | string
    updatedAt?: DateTimeFilter<"Household"> | Date | string
    currency?: StringFilter<"Household"> | string
    icon?: StringNullableFilter<"Household"> | string | null
    timezone?: StringFilter<"Household"> | string
    language?: StringFilter<"Household"> | string
    deletedAt?: DateTimeNullableFilter<"Household"> | Date | string | null
    members?: HouseholdMemberListRelationFilter
    threads?: ThreadListRelationFilter
    chores?: ChoreListRelationFilter
    expenses?: ExpenseListRelationFilter
    events?: EventListRelationFilter
    choreTemplates?: ChoreTemplateListRelationFilter
    notificationSettings?: NotificationSettingsListRelationFilter
  }, "id">

  export type HouseholdOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    currency?: SortOrder
    icon?: SortOrderInput | SortOrder
    timezone?: SortOrder
    language?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: HouseholdCountOrderByAggregateInput
    _max?: HouseholdMaxOrderByAggregateInput
    _min?: HouseholdMinOrderByAggregateInput
  }

  export type HouseholdScalarWhereWithAggregatesInput = {
    AND?: HouseholdScalarWhereWithAggregatesInput | HouseholdScalarWhereWithAggregatesInput[]
    OR?: HouseholdScalarWhereWithAggregatesInput[]
    NOT?: HouseholdScalarWhereWithAggregatesInput | HouseholdScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Household"> | string
    name?: StringWithAggregatesFilter<"Household"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Household"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Household"> | Date | string
    currency?: StringWithAggregatesFilter<"Household"> | string
    icon?: StringNullableWithAggregatesFilter<"Household"> | string | null
    timezone?: StringWithAggregatesFilter<"Household"> | string
    language?: StringWithAggregatesFilter<"Household"> | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Household"> | Date | string | null
  }

  export type HouseholdMemberWhereInput = {
    AND?: HouseholdMemberWhereInput | HouseholdMemberWhereInput[]
    OR?: HouseholdMemberWhereInput[]
    NOT?: HouseholdMemberWhereInput | HouseholdMemberWhereInput[]
    id?: StringFilter<"HouseholdMember"> | string
    userId?: StringFilter<"HouseholdMember"> | string
    householdId?: StringFilter<"HouseholdMember"> | string
    role?: EnumHouseholdRoleFilter<"HouseholdMember"> | $Enums.HouseholdRole
    joinedAt?: DateTimeFilter<"HouseholdMember"> | Date | string
    leftAt?: DateTimeNullableFilter<"HouseholdMember"> | Date | string | null
    isInvited?: BoolFilter<"HouseholdMember"> | boolean
    isAccepted?: BoolFilter<"HouseholdMember"> | boolean
    isRejected?: BoolFilter<"HouseholdMember"> | boolean
    isSelected?: BoolFilter<"HouseholdMember"> | boolean
    lastAssignedChoreAt?: DateTimeNullableFilter<"HouseholdMember"> | Date | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    household?: XOR<HouseholdRelationFilter, HouseholdWhereInput>
    threads?: ThreadListRelationFilter
  }

  export type HouseholdMemberOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    householdId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
    leftAt?: SortOrderInput | SortOrder
    isInvited?: SortOrder
    isAccepted?: SortOrder
    isRejected?: SortOrder
    isSelected?: SortOrder
    lastAssignedChoreAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    household?: HouseholdOrderByWithRelationInput
    threads?: ThreadOrderByRelationAggregateInput
  }

  export type HouseholdMemberWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_householdId?: HouseholdMemberUserIdHouseholdIdCompoundUniqueInput
    AND?: HouseholdMemberWhereInput | HouseholdMemberWhereInput[]
    OR?: HouseholdMemberWhereInput[]
    NOT?: HouseholdMemberWhereInput | HouseholdMemberWhereInput[]
    userId?: StringFilter<"HouseholdMember"> | string
    householdId?: StringFilter<"HouseholdMember"> | string
    role?: EnumHouseholdRoleFilter<"HouseholdMember"> | $Enums.HouseholdRole
    joinedAt?: DateTimeFilter<"HouseholdMember"> | Date | string
    leftAt?: DateTimeNullableFilter<"HouseholdMember"> | Date | string | null
    isInvited?: BoolFilter<"HouseholdMember"> | boolean
    isAccepted?: BoolFilter<"HouseholdMember"> | boolean
    isRejected?: BoolFilter<"HouseholdMember"> | boolean
    isSelected?: BoolFilter<"HouseholdMember"> | boolean
    lastAssignedChoreAt?: DateTimeNullableFilter<"HouseholdMember"> | Date | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    household?: XOR<HouseholdRelationFilter, HouseholdWhereInput>
    threads?: ThreadListRelationFilter
  }, "id" | "userId_householdId">

  export type HouseholdMemberOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    householdId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
    leftAt?: SortOrderInput | SortOrder
    isInvited?: SortOrder
    isAccepted?: SortOrder
    isRejected?: SortOrder
    isSelected?: SortOrder
    lastAssignedChoreAt?: SortOrderInput | SortOrder
    _count?: HouseholdMemberCountOrderByAggregateInput
    _max?: HouseholdMemberMaxOrderByAggregateInput
    _min?: HouseholdMemberMinOrderByAggregateInput
  }

  export type HouseholdMemberScalarWhereWithAggregatesInput = {
    AND?: HouseholdMemberScalarWhereWithAggregatesInput | HouseholdMemberScalarWhereWithAggregatesInput[]
    OR?: HouseholdMemberScalarWhereWithAggregatesInput[]
    NOT?: HouseholdMemberScalarWhereWithAggregatesInput | HouseholdMemberScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"HouseholdMember"> | string
    userId?: StringWithAggregatesFilter<"HouseholdMember"> | string
    householdId?: StringWithAggregatesFilter<"HouseholdMember"> | string
    role?: EnumHouseholdRoleWithAggregatesFilter<"HouseholdMember"> | $Enums.HouseholdRole
    joinedAt?: DateTimeWithAggregatesFilter<"HouseholdMember"> | Date | string
    leftAt?: DateTimeNullableWithAggregatesFilter<"HouseholdMember"> | Date | string | null
    isInvited?: BoolWithAggregatesFilter<"HouseholdMember"> | boolean
    isAccepted?: BoolWithAggregatesFilter<"HouseholdMember"> | boolean
    isRejected?: BoolWithAggregatesFilter<"HouseholdMember"> | boolean
    isSelected?: BoolWithAggregatesFilter<"HouseholdMember"> | boolean
    lastAssignedChoreAt?: DateTimeNullableWithAggregatesFilter<"HouseholdMember"> | Date | string | null
  }

  export type RecurrenceRuleWhereInput = {
    AND?: RecurrenceRuleWhereInput | RecurrenceRuleWhereInput[]
    OR?: RecurrenceRuleWhereInput[]
    NOT?: RecurrenceRuleWhereInput | RecurrenceRuleWhereInput[]
    id?: StringFilter<"RecurrenceRule"> | string
    frequency?: EnumRecurrenceFrequencyFilter<"RecurrenceRule"> | $Enums.RecurrenceFrequency
    interval?: IntFilter<"RecurrenceRule"> | number
    byWeekDay?: EnumDaysOfWeekNullableListFilter<"RecurrenceRule">
    byMonthDay?: IntNullableListFilter<"RecurrenceRule">
    bySetPos?: IntNullableFilter<"RecurrenceRule"> | number | null
    count?: IntNullableFilter<"RecurrenceRule"> | number | null
    until?: DateTimeNullableFilter<"RecurrenceRule"> | Date | string | null
    customRuleString?: StringNullableFilter<"RecurrenceRule"> | string | null
    chores?: ChoreListRelationFilter
    events?: EventListRelationFilter
  }

  export type RecurrenceRuleOrderByWithRelationInput = {
    id?: SortOrder
    frequency?: SortOrder
    interval?: SortOrder
    byWeekDay?: SortOrder
    byMonthDay?: SortOrder
    bySetPos?: SortOrderInput | SortOrder
    count?: SortOrderInput | SortOrder
    until?: SortOrderInput | SortOrder
    customRuleString?: SortOrderInput | SortOrder
    chores?: ChoreOrderByRelationAggregateInput
    events?: EventOrderByRelationAggregateInput
  }

  export type RecurrenceRuleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RecurrenceRuleWhereInput | RecurrenceRuleWhereInput[]
    OR?: RecurrenceRuleWhereInput[]
    NOT?: RecurrenceRuleWhereInput | RecurrenceRuleWhereInput[]
    frequency?: EnumRecurrenceFrequencyFilter<"RecurrenceRule"> | $Enums.RecurrenceFrequency
    interval?: IntFilter<"RecurrenceRule"> | number
    byWeekDay?: EnumDaysOfWeekNullableListFilter<"RecurrenceRule">
    byMonthDay?: IntNullableListFilter<"RecurrenceRule">
    bySetPos?: IntNullableFilter<"RecurrenceRule"> | number | null
    count?: IntNullableFilter<"RecurrenceRule"> | number | null
    until?: DateTimeNullableFilter<"RecurrenceRule"> | Date | string | null
    customRuleString?: StringNullableFilter<"RecurrenceRule"> | string | null
    chores?: ChoreListRelationFilter
    events?: EventListRelationFilter
  }, "id">

  export type RecurrenceRuleOrderByWithAggregationInput = {
    id?: SortOrder
    frequency?: SortOrder
    interval?: SortOrder
    byWeekDay?: SortOrder
    byMonthDay?: SortOrder
    bySetPos?: SortOrderInput | SortOrder
    count?: SortOrderInput | SortOrder
    until?: SortOrderInput | SortOrder
    customRuleString?: SortOrderInput | SortOrder
    _count?: RecurrenceRuleCountOrderByAggregateInput
    _avg?: RecurrenceRuleAvgOrderByAggregateInput
    _max?: RecurrenceRuleMaxOrderByAggregateInput
    _min?: RecurrenceRuleMinOrderByAggregateInput
    _sum?: RecurrenceRuleSumOrderByAggregateInput
  }

  export type RecurrenceRuleScalarWhereWithAggregatesInput = {
    AND?: RecurrenceRuleScalarWhereWithAggregatesInput | RecurrenceRuleScalarWhereWithAggregatesInput[]
    OR?: RecurrenceRuleScalarWhereWithAggregatesInput[]
    NOT?: RecurrenceRuleScalarWhereWithAggregatesInput | RecurrenceRuleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RecurrenceRule"> | string
    frequency?: EnumRecurrenceFrequencyWithAggregatesFilter<"RecurrenceRule"> | $Enums.RecurrenceFrequency
    interval?: IntWithAggregatesFilter<"RecurrenceRule"> | number
    byWeekDay?: EnumDaysOfWeekNullableListFilter<"RecurrenceRule">
    byMonthDay?: IntNullableListFilter<"RecurrenceRule">
    bySetPos?: IntNullableWithAggregatesFilter<"RecurrenceRule"> | number | null
    count?: IntNullableWithAggregatesFilter<"RecurrenceRule"> | number | null
    until?: DateTimeNullableWithAggregatesFilter<"RecurrenceRule"> | Date | string | null
    customRuleString?: StringNullableWithAggregatesFilter<"RecurrenceRule"> | string | null
  }

  export type ThreadWhereInput = {
    AND?: ThreadWhereInput | ThreadWhereInput[]
    OR?: ThreadWhereInput[]
    NOT?: ThreadWhereInput | ThreadWhereInput[]
    id?: StringFilter<"Thread"> | string
    householdId?: StringFilter<"Thread"> | string
    authorId?: StringFilter<"Thread"> | string
    title?: StringNullableFilter<"Thread"> | string | null
    createdAt?: DateTimeFilter<"Thread"> | Date | string
    updatedAt?: DateTimeFilter<"Thread"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Thread"> | Date | string | null
    household?: XOR<HouseholdRelationFilter, HouseholdWhereInput>
    author?: XOR<UserRelationFilter, UserWhereInput>
    messages?: MessageListRelationFilter
    participants?: HouseholdMemberListRelationFilter
  }

  export type ThreadOrderByWithRelationInput = {
    id?: SortOrder
    householdId?: SortOrder
    authorId?: SortOrder
    title?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    household?: HouseholdOrderByWithRelationInput
    author?: UserOrderByWithRelationInput
    messages?: MessageOrderByRelationAggregateInput
    participants?: HouseholdMemberOrderByRelationAggregateInput
  }

  export type ThreadWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ThreadWhereInput | ThreadWhereInput[]
    OR?: ThreadWhereInput[]
    NOT?: ThreadWhereInput | ThreadWhereInput[]
    householdId?: StringFilter<"Thread"> | string
    authorId?: StringFilter<"Thread"> | string
    title?: StringNullableFilter<"Thread"> | string | null
    createdAt?: DateTimeFilter<"Thread"> | Date | string
    updatedAt?: DateTimeFilter<"Thread"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Thread"> | Date | string | null
    household?: XOR<HouseholdRelationFilter, HouseholdWhereInput>
    author?: XOR<UserRelationFilter, UserWhereInput>
    messages?: MessageListRelationFilter
    participants?: HouseholdMemberListRelationFilter
  }, "id">

  export type ThreadOrderByWithAggregationInput = {
    id?: SortOrder
    householdId?: SortOrder
    authorId?: SortOrder
    title?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: ThreadCountOrderByAggregateInput
    _max?: ThreadMaxOrderByAggregateInput
    _min?: ThreadMinOrderByAggregateInput
  }

  export type ThreadScalarWhereWithAggregatesInput = {
    AND?: ThreadScalarWhereWithAggregatesInput | ThreadScalarWhereWithAggregatesInput[]
    OR?: ThreadScalarWhereWithAggregatesInput[]
    NOT?: ThreadScalarWhereWithAggregatesInput | ThreadScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Thread"> | string
    householdId?: StringWithAggregatesFilter<"Thread"> | string
    authorId?: StringWithAggregatesFilter<"Thread"> | string
    title?: StringNullableWithAggregatesFilter<"Thread"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Thread"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Thread"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Thread"> | Date | string | null
  }

  export type MessageWhereInput = {
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    id?: StringFilter<"Message"> | string
    threadId?: StringFilter<"Message"> | string
    authorId?: StringFilter<"Message"> | string
    content?: StringFilter<"Message"> | string
    createdAt?: DateTimeFilter<"Message"> | Date | string
    updatedAt?: DateTimeFilter<"Message"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Message"> | Date | string | null
    thread?: XOR<ThreadRelationFilter, ThreadWhereInput>
    author?: XOR<UserRelationFilter, UserWhereInput>
    attachments?: AttachmentListRelationFilter
    reactions?: ReactionListRelationFilter
    mentions?: MentionListRelationFilter
    reads?: MessageReadListRelationFilter
  }

  export type MessageOrderByWithRelationInput = {
    id?: SortOrder
    threadId?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    thread?: ThreadOrderByWithRelationInput
    author?: UserOrderByWithRelationInput
    attachments?: AttachmentOrderByRelationAggregateInput
    reactions?: ReactionOrderByRelationAggregateInput
    mentions?: MentionOrderByRelationAggregateInput
    reads?: MessageReadOrderByRelationAggregateInput
  }

  export type MessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    threadId?: StringFilter<"Message"> | string
    authorId?: StringFilter<"Message"> | string
    content?: StringFilter<"Message"> | string
    createdAt?: DateTimeFilter<"Message"> | Date | string
    updatedAt?: DateTimeFilter<"Message"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Message"> | Date | string | null
    thread?: XOR<ThreadRelationFilter, ThreadWhereInput>
    author?: XOR<UserRelationFilter, UserWhereInput>
    attachments?: AttachmentListRelationFilter
    reactions?: ReactionListRelationFilter
    mentions?: MentionListRelationFilter
    reads?: MessageReadListRelationFilter
  }, "id">

  export type MessageOrderByWithAggregationInput = {
    id?: SortOrder
    threadId?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: MessageCountOrderByAggregateInput
    _max?: MessageMaxOrderByAggregateInput
    _min?: MessageMinOrderByAggregateInput
  }

  export type MessageScalarWhereWithAggregatesInput = {
    AND?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    OR?: MessageScalarWhereWithAggregatesInput[]
    NOT?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Message"> | string
    threadId?: StringWithAggregatesFilter<"Message"> | string
    authorId?: StringWithAggregatesFilter<"Message"> | string
    content?: StringWithAggregatesFilter<"Message"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Message"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Message"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Message"> | Date | string | null
  }

  export type ReactionWhereInput = {
    AND?: ReactionWhereInput | ReactionWhereInput[]
    OR?: ReactionWhereInput[]
    NOT?: ReactionWhereInput | ReactionWhereInput[]
    id?: StringFilter<"Reaction"> | string
    messageId?: StringFilter<"Reaction"> | string
    userId?: StringFilter<"Reaction"> | string
    emoji?: StringFilter<"Reaction"> | string
    type?: EnumReactionTypeFilter<"Reaction"> | $Enums.ReactionType
    createdAt?: DateTimeFilter<"Reaction"> | Date | string
    message?: XOR<MessageRelationFilter, MessageWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ReactionOrderByWithRelationInput = {
    id?: SortOrder
    messageId?: SortOrder
    userId?: SortOrder
    emoji?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    message?: MessageOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type ReactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ReactionWhereInput | ReactionWhereInput[]
    OR?: ReactionWhereInput[]
    NOT?: ReactionWhereInput | ReactionWhereInput[]
    messageId?: StringFilter<"Reaction"> | string
    userId?: StringFilter<"Reaction"> | string
    emoji?: StringFilter<"Reaction"> | string
    type?: EnumReactionTypeFilter<"Reaction"> | $Enums.ReactionType
    createdAt?: DateTimeFilter<"Reaction"> | Date | string
    message?: XOR<MessageRelationFilter, MessageWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type ReactionOrderByWithAggregationInput = {
    id?: SortOrder
    messageId?: SortOrder
    userId?: SortOrder
    emoji?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    _count?: ReactionCountOrderByAggregateInput
    _max?: ReactionMaxOrderByAggregateInput
    _min?: ReactionMinOrderByAggregateInput
  }

  export type ReactionScalarWhereWithAggregatesInput = {
    AND?: ReactionScalarWhereWithAggregatesInput | ReactionScalarWhereWithAggregatesInput[]
    OR?: ReactionScalarWhereWithAggregatesInput[]
    NOT?: ReactionScalarWhereWithAggregatesInput | ReactionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Reaction"> | string
    messageId?: StringWithAggregatesFilter<"Reaction"> | string
    userId?: StringWithAggregatesFilter<"Reaction"> | string
    emoji?: StringWithAggregatesFilter<"Reaction"> | string
    type?: EnumReactionTypeWithAggregatesFilter<"Reaction"> | $Enums.ReactionType
    createdAt?: DateTimeWithAggregatesFilter<"Reaction"> | Date | string
  }

  export type MentionWhereInput = {
    AND?: MentionWhereInput | MentionWhereInput[]
    OR?: MentionWhereInput[]
    NOT?: MentionWhereInput | MentionWhereInput[]
    id?: StringFilter<"Mention"> | string
    messageId?: StringFilter<"Mention"> | string
    userId?: StringFilter<"Mention"> | string
    mentionedAt?: DateTimeFilter<"Mention"> | Date | string
    message?: XOR<MessageRelationFilter, MessageWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type MentionOrderByWithRelationInput = {
    id?: SortOrder
    messageId?: SortOrder
    userId?: SortOrder
    mentionedAt?: SortOrder
    message?: MessageOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type MentionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MentionWhereInput | MentionWhereInput[]
    OR?: MentionWhereInput[]
    NOT?: MentionWhereInput | MentionWhereInput[]
    messageId?: StringFilter<"Mention"> | string
    userId?: StringFilter<"Mention"> | string
    mentionedAt?: DateTimeFilter<"Mention"> | Date | string
    message?: XOR<MessageRelationFilter, MessageWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type MentionOrderByWithAggregationInput = {
    id?: SortOrder
    messageId?: SortOrder
    userId?: SortOrder
    mentionedAt?: SortOrder
    _count?: MentionCountOrderByAggregateInput
    _max?: MentionMaxOrderByAggregateInput
    _min?: MentionMinOrderByAggregateInput
  }

  export type MentionScalarWhereWithAggregatesInput = {
    AND?: MentionScalarWhereWithAggregatesInput | MentionScalarWhereWithAggregatesInput[]
    OR?: MentionScalarWhereWithAggregatesInput[]
    NOT?: MentionScalarWhereWithAggregatesInput | MentionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Mention"> | string
    messageId?: StringWithAggregatesFilter<"Mention"> | string
    userId?: StringWithAggregatesFilter<"Mention"> | string
    mentionedAt?: DateTimeWithAggregatesFilter<"Mention"> | Date | string
  }

  export type AttachmentWhereInput = {
    AND?: AttachmentWhereInput | AttachmentWhereInput[]
    OR?: AttachmentWhereInput[]
    NOT?: AttachmentWhereInput | AttachmentWhereInput[]
    id?: StringFilter<"Attachment"> | string
    messageId?: StringFilter<"Attachment"> | string
    url?: StringFilter<"Attachment"> | string
    fileType?: StringFilter<"Attachment"> | string
    createdAt?: DateTimeFilter<"Attachment"> | Date | string
    updatedAt?: DateTimeFilter<"Attachment"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Attachment"> | Date | string | null
    message?: XOR<MessageRelationFilter, MessageWhereInput>
  }

  export type AttachmentOrderByWithRelationInput = {
    id?: SortOrder
    messageId?: SortOrder
    url?: SortOrder
    fileType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    message?: MessageOrderByWithRelationInput
  }

  export type AttachmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AttachmentWhereInput | AttachmentWhereInput[]
    OR?: AttachmentWhereInput[]
    NOT?: AttachmentWhereInput | AttachmentWhereInput[]
    messageId?: StringFilter<"Attachment"> | string
    url?: StringFilter<"Attachment"> | string
    fileType?: StringFilter<"Attachment"> | string
    createdAt?: DateTimeFilter<"Attachment"> | Date | string
    updatedAt?: DateTimeFilter<"Attachment"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Attachment"> | Date | string | null
    message?: XOR<MessageRelationFilter, MessageWhereInput>
  }, "id">

  export type AttachmentOrderByWithAggregationInput = {
    id?: SortOrder
    messageId?: SortOrder
    url?: SortOrder
    fileType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: AttachmentCountOrderByAggregateInput
    _max?: AttachmentMaxOrderByAggregateInput
    _min?: AttachmentMinOrderByAggregateInput
  }

  export type AttachmentScalarWhereWithAggregatesInput = {
    AND?: AttachmentScalarWhereWithAggregatesInput | AttachmentScalarWhereWithAggregatesInput[]
    OR?: AttachmentScalarWhereWithAggregatesInput[]
    NOT?: AttachmentScalarWhereWithAggregatesInput | AttachmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Attachment"> | string
    messageId?: StringWithAggregatesFilter<"Attachment"> | string
    url?: StringWithAggregatesFilter<"Attachment"> | string
    fileType?: StringWithAggregatesFilter<"Attachment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Attachment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Attachment"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Attachment"> | Date | string | null
  }

  export type MessageReadWhereInput = {
    AND?: MessageReadWhereInput | MessageReadWhereInput[]
    OR?: MessageReadWhereInput[]
    NOT?: MessageReadWhereInput | MessageReadWhereInput[]
    id?: StringFilter<"MessageRead"> | string
    messageId?: StringFilter<"MessageRead"> | string
    userId?: StringFilter<"MessageRead"> | string
    readAt?: DateTimeFilter<"MessageRead"> | Date | string
    message?: XOR<MessageRelationFilter, MessageWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type MessageReadOrderByWithRelationInput = {
    id?: SortOrder
    messageId?: SortOrder
    userId?: SortOrder
    readAt?: SortOrder
    message?: MessageOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type MessageReadWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MessageReadWhereInput | MessageReadWhereInput[]
    OR?: MessageReadWhereInput[]
    NOT?: MessageReadWhereInput | MessageReadWhereInput[]
    messageId?: StringFilter<"MessageRead"> | string
    userId?: StringFilter<"MessageRead"> | string
    readAt?: DateTimeFilter<"MessageRead"> | Date | string
    message?: XOR<MessageRelationFilter, MessageWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type MessageReadOrderByWithAggregationInput = {
    id?: SortOrder
    messageId?: SortOrder
    userId?: SortOrder
    readAt?: SortOrder
    _count?: MessageReadCountOrderByAggregateInput
    _max?: MessageReadMaxOrderByAggregateInput
    _min?: MessageReadMinOrderByAggregateInput
  }

  export type MessageReadScalarWhereWithAggregatesInput = {
    AND?: MessageReadScalarWhereWithAggregatesInput | MessageReadScalarWhereWithAggregatesInput[]
    OR?: MessageReadScalarWhereWithAggregatesInput[]
    NOT?: MessageReadScalarWhereWithAggregatesInput | MessageReadScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MessageRead"> | string
    messageId?: StringWithAggregatesFilter<"MessageRead"> | string
    userId?: StringWithAggregatesFilter<"MessageRead"> | string
    readAt?: DateTimeWithAggregatesFilter<"MessageRead"> | Date | string
  }

  export type ChoreWhereInput = {
    AND?: ChoreWhereInput | ChoreWhereInput[]
    OR?: ChoreWhereInput[]
    NOT?: ChoreWhereInput | ChoreWhereInput[]
    id?: StringFilter<"Chore"> | string
    householdId?: StringFilter<"Chore"> | string
    title?: StringFilter<"Chore"> | string
    description?: StringNullableFilter<"Chore"> | string | null
    createdAt?: DateTimeFilter<"Chore"> | Date | string
    updatedAt?: DateTimeFilter<"Chore"> | Date | string
    dueDate?: DateTimeNullableFilter<"Chore"> | Date | string | null
    status?: EnumChoreStatusFilter<"Chore"> | $Enums.ChoreStatus
    priority?: IntNullableFilter<"Chore"> | number | null
    eventId?: StringNullableFilter<"Chore"> | string | null
    recurrenceRuleId?: StringNullableFilter<"Chore"> | string | null
    deletedAt?: DateTimeNullableFilter<"Chore"> | Date | string | null
    household?: XOR<HouseholdRelationFilter, HouseholdWhereInput>
    subtasks?: SubtaskListRelationFilter
    assignedUsers?: ChoreAssignmentListRelationFilter
    event?: XOR<EventNullableRelationFilter, EventWhereInput> | null
    choreSwapRequests?: ChoreSwapRequestListRelationFilter
    recurrenceRule?: XOR<RecurrenceRuleNullableRelationFilter, RecurrenceRuleWhereInput> | null
    history?: ChoreHistoryListRelationFilter
  }

  export type ChoreOrderByWithRelationInput = {
    id?: SortOrder
    householdId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    status?: SortOrder
    priority?: SortOrderInput | SortOrder
    eventId?: SortOrderInput | SortOrder
    recurrenceRuleId?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    household?: HouseholdOrderByWithRelationInput
    subtasks?: SubtaskOrderByRelationAggregateInput
    assignedUsers?: ChoreAssignmentOrderByRelationAggregateInput
    event?: EventOrderByWithRelationInput
    choreSwapRequests?: ChoreSwapRequestOrderByRelationAggregateInput
    recurrenceRule?: RecurrenceRuleOrderByWithRelationInput
    history?: ChoreHistoryOrderByRelationAggregateInput
  }

  export type ChoreWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    eventId?: string
    AND?: ChoreWhereInput | ChoreWhereInput[]
    OR?: ChoreWhereInput[]
    NOT?: ChoreWhereInput | ChoreWhereInput[]
    householdId?: StringFilter<"Chore"> | string
    title?: StringFilter<"Chore"> | string
    description?: StringNullableFilter<"Chore"> | string | null
    createdAt?: DateTimeFilter<"Chore"> | Date | string
    updatedAt?: DateTimeFilter<"Chore"> | Date | string
    dueDate?: DateTimeNullableFilter<"Chore"> | Date | string | null
    status?: EnumChoreStatusFilter<"Chore"> | $Enums.ChoreStatus
    priority?: IntNullableFilter<"Chore"> | number | null
    recurrenceRuleId?: StringNullableFilter<"Chore"> | string | null
    deletedAt?: DateTimeNullableFilter<"Chore"> | Date | string | null
    household?: XOR<HouseholdRelationFilter, HouseholdWhereInput>
    subtasks?: SubtaskListRelationFilter
    assignedUsers?: ChoreAssignmentListRelationFilter
    event?: XOR<EventNullableRelationFilter, EventWhereInput> | null
    choreSwapRequests?: ChoreSwapRequestListRelationFilter
    recurrenceRule?: XOR<RecurrenceRuleNullableRelationFilter, RecurrenceRuleWhereInput> | null
    history?: ChoreHistoryListRelationFilter
  }, "id" | "eventId">

  export type ChoreOrderByWithAggregationInput = {
    id?: SortOrder
    householdId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    status?: SortOrder
    priority?: SortOrderInput | SortOrder
    eventId?: SortOrderInput | SortOrder
    recurrenceRuleId?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: ChoreCountOrderByAggregateInput
    _avg?: ChoreAvgOrderByAggregateInput
    _max?: ChoreMaxOrderByAggregateInput
    _min?: ChoreMinOrderByAggregateInput
    _sum?: ChoreSumOrderByAggregateInput
  }

  export type ChoreScalarWhereWithAggregatesInput = {
    AND?: ChoreScalarWhereWithAggregatesInput | ChoreScalarWhereWithAggregatesInput[]
    OR?: ChoreScalarWhereWithAggregatesInput[]
    NOT?: ChoreScalarWhereWithAggregatesInput | ChoreScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Chore"> | string
    householdId?: StringWithAggregatesFilter<"Chore"> | string
    title?: StringWithAggregatesFilter<"Chore"> | string
    description?: StringNullableWithAggregatesFilter<"Chore"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Chore"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Chore"> | Date | string
    dueDate?: DateTimeNullableWithAggregatesFilter<"Chore"> | Date | string | null
    status?: EnumChoreStatusWithAggregatesFilter<"Chore"> | $Enums.ChoreStatus
    priority?: IntNullableWithAggregatesFilter<"Chore"> | number | null
    eventId?: StringNullableWithAggregatesFilter<"Chore"> | string | null
    recurrenceRuleId?: StringNullableWithAggregatesFilter<"Chore"> | string | null
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Chore"> | Date | string | null
  }

  export type SubtaskWhereInput = {
    AND?: SubtaskWhereInput | SubtaskWhereInput[]
    OR?: SubtaskWhereInput[]
    NOT?: SubtaskWhereInput | SubtaskWhereInput[]
    id?: StringFilter<"Subtask"> | string
    choreId?: StringFilter<"Subtask"> | string
    title?: StringFilter<"Subtask"> | string
    description?: StringNullableFilter<"Subtask"> | string | null
    status?: EnumSubtaskStatusFilter<"Subtask"> | $Enums.SubtaskStatus
    chore?: XOR<ChoreRelationFilter, ChoreWhereInput>
  }

  export type SubtaskOrderByWithRelationInput = {
    id?: SortOrder
    choreId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    chore?: ChoreOrderByWithRelationInput
  }

  export type SubtaskWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SubtaskWhereInput | SubtaskWhereInput[]
    OR?: SubtaskWhereInput[]
    NOT?: SubtaskWhereInput | SubtaskWhereInput[]
    choreId?: StringFilter<"Subtask"> | string
    title?: StringFilter<"Subtask"> | string
    description?: StringNullableFilter<"Subtask"> | string | null
    status?: EnumSubtaskStatusFilter<"Subtask"> | $Enums.SubtaskStatus
    chore?: XOR<ChoreRelationFilter, ChoreWhereInput>
  }, "id">

  export type SubtaskOrderByWithAggregationInput = {
    id?: SortOrder
    choreId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    _count?: SubtaskCountOrderByAggregateInput
    _max?: SubtaskMaxOrderByAggregateInput
    _min?: SubtaskMinOrderByAggregateInput
  }

  export type SubtaskScalarWhereWithAggregatesInput = {
    AND?: SubtaskScalarWhereWithAggregatesInput | SubtaskScalarWhereWithAggregatesInput[]
    OR?: SubtaskScalarWhereWithAggregatesInput[]
    NOT?: SubtaskScalarWhereWithAggregatesInput | SubtaskScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Subtask"> | string
    choreId?: StringWithAggregatesFilter<"Subtask"> | string
    title?: StringWithAggregatesFilter<"Subtask"> | string
    description?: StringNullableWithAggregatesFilter<"Subtask"> | string | null
    status?: EnumSubtaskStatusWithAggregatesFilter<"Subtask"> | $Enums.SubtaskStatus
  }

  export type ChoreAssignmentWhereInput = {
    AND?: ChoreAssignmentWhereInput | ChoreAssignmentWhereInput[]
    OR?: ChoreAssignmentWhereInput[]
    NOT?: ChoreAssignmentWhereInput | ChoreAssignmentWhereInput[]
    id?: StringFilter<"ChoreAssignment"> | string
    choreId?: StringFilter<"ChoreAssignment"> | string
    userId?: StringFilter<"ChoreAssignment"> | string
    assignedAt?: DateTimeFilter<"ChoreAssignment"> | Date | string
    completedAt?: DateTimeNullableFilter<"ChoreAssignment"> | Date | string | null
    chore?: XOR<ChoreRelationFilter, ChoreWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ChoreAssignmentOrderByWithRelationInput = {
    id?: SortOrder
    choreId?: SortOrder
    userId?: SortOrder
    assignedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    chore?: ChoreOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type ChoreAssignmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    choreId_userId?: ChoreAssignmentChoreIdUserIdCompoundUniqueInput
    AND?: ChoreAssignmentWhereInput | ChoreAssignmentWhereInput[]
    OR?: ChoreAssignmentWhereInput[]
    NOT?: ChoreAssignmentWhereInput | ChoreAssignmentWhereInput[]
    choreId?: StringFilter<"ChoreAssignment"> | string
    userId?: StringFilter<"ChoreAssignment"> | string
    assignedAt?: DateTimeFilter<"ChoreAssignment"> | Date | string
    completedAt?: DateTimeNullableFilter<"ChoreAssignment"> | Date | string | null
    chore?: XOR<ChoreRelationFilter, ChoreWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "choreId_userId">

  export type ChoreAssignmentOrderByWithAggregationInput = {
    id?: SortOrder
    choreId?: SortOrder
    userId?: SortOrder
    assignedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    _count?: ChoreAssignmentCountOrderByAggregateInput
    _max?: ChoreAssignmentMaxOrderByAggregateInput
    _min?: ChoreAssignmentMinOrderByAggregateInput
  }

  export type ChoreAssignmentScalarWhereWithAggregatesInput = {
    AND?: ChoreAssignmentScalarWhereWithAggregatesInput | ChoreAssignmentScalarWhereWithAggregatesInput[]
    OR?: ChoreAssignmentScalarWhereWithAggregatesInput[]
    NOT?: ChoreAssignmentScalarWhereWithAggregatesInput | ChoreAssignmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ChoreAssignment"> | string
    choreId?: StringWithAggregatesFilter<"ChoreAssignment"> | string
    userId?: StringWithAggregatesFilter<"ChoreAssignment"> | string
    assignedAt?: DateTimeWithAggregatesFilter<"ChoreAssignment"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"ChoreAssignment"> | Date | string | null
  }

  export type ChoreSwapRequestWhereInput = {
    AND?: ChoreSwapRequestWhereInput | ChoreSwapRequestWhereInput[]
    OR?: ChoreSwapRequestWhereInput[]
    NOT?: ChoreSwapRequestWhereInput | ChoreSwapRequestWhereInput[]
    id?: StringFilter<"ChoreSwapRequest"> | string
    choreId?: StringFilter<"ChoreSwapRequest"> | string
    requestingUserId?: StringFilter<"ChoreSwapRequest"> | string
    targetUserId?: StringFilter<"ChoreSwapRequest"> | string
    status?: EnumChoreSwapRequestStatusFilter<"ChoreSwapRequest"> | $Enums.ChoreSwapRequestStatus
    createdAt?: DateTimeFilter<"ChoreSwapRequest"> | Date | string
    updatedAt?: DateTimeFilter<"ChoreSwapRequest"> | Date | string
    requestingUser?: XOR<UserRelationFilter, UserWhereInput>
    targetUser?: XOR<UserRelationFilter, UserWhereInput>
    chore?: XOR<ChoreRelationFilter, ChoreWhereInput>
  }

  export type ChoreSwapRequestOrderByWithRelationInput = {
    id?: SortOrder
    choreId?: SortOrder
    requestingUserId?: SortOrder
    targetUserId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    requestingUser?: UserOrderByWithRelationInput
    targetUser?: UserOrderByWithRelationInput
    chore?: ChoreOrderByWithRelationInput
  }

  export type ChoreSwapRequestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ChoreSwapRequestWhereInput | ChoreSwapRequestWhereInput[]
    OR?: ChoreSwapRequestWhereInput[]
    NOT?: ChoreSwapRequestWhereInput | ChoreSwapRequestWhereInput[]
    choreId?: StringFilter<"ChoreSwapRequest"> | string
    requestingUserId?: StringFilter<"ChoreSwapRequest"> | string
    targetUserId?: StringFilter<"ChoreSwapRequest"> | string
    status?: EnumChoreSwapRequestStatusFilter<"ChoreSwapRequest"> | $Enums.ChoreSwapRequestStatus
    createdAt?: DateTimeFilter<"ChoreSwapRequest"> | Date | string
    updatedAt?: DateTimeFilter<"ChoreSwapRequest"> | Date | string
    requestingUser?: XOR<UserRelationFilter, UserWhereInput>
    targetUser?: XOR<UserRelationFilter, UserWhereInput>
    chore?: XOR<ChoreRelationFilter, ChoreWhereInput>
  }, "id">

  export type ChoreSwapRequestOrderByWithAggregationInput = {
    id?: SortOrder
    choreId?: SortOrder
    requestingUserId?: SortOrder
    targetUserId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ChoreSwapRequestCountOrderByAggregateInput
    _max?: ChoreSwapRequestMaxOrderByAggregateInput
    _min?: ChoreSwapRequestMinOrderByAggregateInput
  }

  export type ChoreSwapRequestScalarWhereWithAggregatesInput = {
    AND?: ChoreSwapRequestScalarWhereWithAggregatesInput | ChoreSwapRequestScalarWhereWithAggregatesInput[]
    OR?: ChoreSwapRequestScalarWhereWithAggregatesInput[]
    NOT?: ChoreSwapRequestScalarWhereWithAggregatesInput | ChoreSwapRequestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ChoreSwapRequest"> | string
    choreId?: StringWithAggregatesFilter<"ChoreSwapRequest"> | string
    requestingUserId?: StringWithAggregatesFilter<"ChoreSwapRequest"> | string
    targetUserId?: StringWithAggregatesFilter<"ChoreSwapRequest"> | string
    status?: EnumChoreSwapRequestStatusWithAggregatesFilter<"ChoreSwapRequest"> | $Enums.ChoreSwapRequestStatus
    createdAt?: DateTimeWithAggregatesFilter<"ChoreSwapRequest"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ChoreSwapRequest"> | Date | string
  }

  export type ChoreTemplateWhereInput = {
    AND?: ChoreTemplateWhereInput | ChoreTemplateWhereInput[]
    OR?: ChoreTemplateWhereInput[]
    NOT?: ChoreTemplateWhereInput | ChoreTemplateWhereInput[]
    id?: StringFilter<"ChoreTemplate"> | string
    householdId?: StringFilter<"ChoreTemplate"> | string
    title?: StringFilter<"ChoreTemplate"> | string
    description?: StringNullableFilter<"ChoreTemplate"> | string | null
    createdAt?: DateTimeFilter<"ChoreTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"ChoreTemplate"> | Date | string
    household?: XOR<HouseholdRelationFilter, HouseholdWhereInput>
    subtasks?: SubtaskTemplateListRelationFilter
  }

  export type ChoreTemplateOrderByWithRelationInput = {
    id?: SortOrder
    householdId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    household?: HouseholdOrderByWithRelationInput
    subtasks?: SubtaskTemplateOrderByRelationAggregateInput
  }

  export type ChoreTemplateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ChoreTemplateWhereInput | ChoreTemplateWhereInput[]
    OR?: ChoreTemplateWhereInput[]
    NOT?: ChoreTemplateWhereInput | ChoreTemplateWhereInput[]
    householdId?: StringFilter<"ChoreTemplate"> | string
    title?: StringFilter<"ChoreTemplate"> | string
    description?: StringNullableFilter<"ChoreTemplate"> | string | null
    createdAt?: DateTimeFilter<"ChoreTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"ChoreTemplate"> | Date | string
    household?: XOR<HouseholdRelationFilter, HouseholdWhereInput>
    subtasks?: SubtaskTemplateListRelationFilter
  }, "id">

  export type ChoreTemplateOrderByWithAggregationInput = {
    id?: SortOrder
    householdId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ChoreTemplateCountOrderByAggregateInput
    _max?: ChoreTemplateMaxOrderByAggregateInput
    _min?: ChoreTemplateMinOrderByAggregateInput
  }

  export type ChoreTemplateScalarWhereWithAggregatesInput = {
    AND?: ChoreTemplateScalarWhereWithAggregatesInput | ChoreTemplateScalarWhereWithAggregatesInput[]
    OR?: ChoreTemplateScalarWhereWithAggregatesInput[]
    NOT?: ChoreTemplateScalarWhereWithAggregatesInput | ChoreTemplateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ChoreTemplate"> | string
    householdId?: StringWithAggregatesFilter<"ChoreTemplate"> | string
    title?: StringWithAggregatesFilter<"ChoreTemplate"> | string
    description?: StringNullableWithAggregatesFilter<"ChoreTemplate"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ChoreTemplate"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ChoreTemplate"> | Date | string
  }

  export type SubtaskTemplateWhereInput = {
    AND?: SubtaskTemplateWhereInput | SubtaskTemplateWhereInput[]
    OR?: SubtaskTemplateWhereInput[]
    NOT?: SubtaskTemplateWhereInput | SubtaskTemplateWhereInput[]
    id?: StringFilter<"SubtaskTemplate"> | string
    choreTemplateId?: StringFilter<"SubtaskTemplate"> | string
    title?: StringFilter<"SubtaskTemplate"> | string
    createdAt?: DateTimeFilter<"SubtaskTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"SubtaskTemplate"> | Date | string
    choreTemplate?: XOR<ChoreTemplateRelationFilter, ChoreTemplateWhereInput>
  }

  export type SubtaskTemplateOrderByWithRelationInput = {
    id?: SortOrder
    choreTemplateId?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    choreTemplate?: ChoreTemplateOrderByWithRelationInput
  }

  export type SubtaskTemplateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SubtaskTemplateWhereInput | SubtaskTemplateWhereInput[]
    OR?: SubtaskTemplateWhereInput[]
    NOT?: SubtaskTemplateWhereInput | SubtaskTemplateWhereInput[]
    choreTemplateId?: StringFilter<"SubtaskTemplate"> | string
    title?: StringFilter<"SubtaskTemplate"> | string
    createdAt?: DateTimeFilter<"SubtaskTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"SubtaskTemplate"> | Date | string
    choreTemplate?: XOR<ChoreTemplateRelationFilter, ChoreTemplateWhereInput>
  }, "id">

  export type SubtaskTemplateOrderByWithAggregationInput = {
    id?: SortOrder
    choreTemplateId?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SubtaskTemplateCountOrderByAggregateInput
    _max?: SubtaskTemplateMaxOrderByAggregateInput
    _min?: SubtaskTemplateMinOrderByAggregateInput
  }

  export type SubtaskTemplateScalarWhereWithAggregatesInput = {
    AND?: SubtaskTemplateScalarWhereWithAggregatesInput | SubtaskTemplateScalarWhereWithAggregatesInput[]
    OR?: SubtaskTemplateScalarWhereWithAggregatesInput[]
    NOT?: SubtaskTemplateScalarWhereWithAggregatesInput | SubtaskTemplateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SubtaskTemplate"> | string
    choreTemplateId?: StringWithAggregatesFilter<"SubtaskTemplate"> | string
    title?: StringWithAggregatesFilter<"SubtaskTemplate"> | string
    createdAt?: DateTimeWithAggregatesFilter<"SubtaskTemplate"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SubtaskTemplate"> | Date | string
  }

  export type ChoreHistoryWhereInput = {
    AND?: ChoreHistoryWhereInput | ChoreHistoryWhereInput[]
    OR?: ChoreHistoryWhereInput[]
    NOT?: ChoreHistoryWhereInput | ChoreHistoryWhereInput[]
    id?: StringFilter<"ChoreHistory"> | string
    choreId?: StringFilter<"ChoreHistory"> | string
    action?: EnumChoreActionFilter<"ChoreHistory"> | $Enums.ChoreAction
    changedById?: StringFilter<"ChoreHistory"> | string
    changedAt?: DateTimeFilter<"ChoreHistory"> | Date | string
    chore?: XOR<ChoreRelationFilter, ChoreWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ChoreHistoryOrderByWithRelationInput = {
    id?: SortOrder
    choreId?: SortOrder
    action?: SortOrder
    changedById?: SortOrder
    changedAt?: SortOrder
    chore?: ChoreOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type ChoreHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ChoreHistoryWhereInput | ChoreHistoryWhereInput[]
    OR?: ChoreHistoryWhereInput[]
    NOT?: ChoreHistoryWhereInput | ChoreHistoryWhereInput[]
    choreId?: StringFilter<"ChoreHistory"> | string
    action?: EnumChoreActionFilter<"ChoreHistory"> | $Enums.ChoreAction
    changedById?: StringFilter<"ChoreHistory"> | string
    changedAt?: DateTimeFilter<"ChoreHistory"> | Date | string
    chore?: XOR<ChoreRelationFilter, ChoreWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type ChoreHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    choreId?: SortOrder
    action?: SortOrder
    changedById?: SortOrder
    changedAt?: SortOrder
    _count?: ChoreHistoryCountOrderByAggregateInput
    _max?: ChoreHistoryMaxOrderByAggregateInput
    _min?: ChoreHistoryMinOrderByAggregateInput
  }

  export type ChoreHistoryScalarWhereWithAggregatesInput = {
    AND?: ChoreHistoryScalarWhereWithAggregatesInput | ChoreHistoryScalarWhereWithAggregatesInput[]
    OR?: ChoreHistoryScalarWhereWithAggregatesInput[]
    NOT?: ChoreHistoryScalarWhereWithAggregatesInput | ChoreHistoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ChoreHistory"> | string
    choreId?: StringWithAggregatesFilter<"ChoreHistory"> | string
    action?: EnumChoreActionWithAggregatesFilter<"ChoreHistory"> | $Enums.ChoreAction
    changedById?: StringWithAggregatesFilter<"ChoreHistory"> | string
    changedAt?: DateTimeWithAggregatesFilter<"ChoreHistory"> | Date | string
  }

  export type ExpenseWhereInput = {
    AND?: ExpenseWhereInput | ExpenseWhereInput[]
    OR?: ExpenseWhereInput[]
    NOT?: ExpenseWhereInput | ExpenseWhereInput[]
    id?: StringFilter<"Expense"> | string
    householdId?: StringFilter<"Expense"> | string
    amount?: FloatFilter<"Expense"> | number
    description?: StringFilter<"Expense"> | string
    paidById?: StringFilter<"Expense"> | string
    createdAt?: DateTimeFilter<"Expense"> | Date | string
    updatedAt?: DateTimeFilter<"Expense"> | Date | string
    dueDate?: DateTimeNullableFilter<"Expense"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"Expense"> | Date | string | null
    category?: EnumExpenseCategoryFilter<"Expense"> | $Enums.ExpenseCategory
    household?: XOR<HouseholdRelationFilter, HouseholdWhereInput>
    paidBy?: XOR<UserRelationFilter, UserWhereInput>
    splits?: ExpenseSplitListRelationFilter
    transactions?: TransactionListRelationFilter
    receipts?: ReceiptListRelationFilter
    history?: ExpenseHistoryListRelationFilter
  }

  export type ExpenseOrderByWithRelationInput = {
    id?: SortOrder
    householdId?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    paidById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    category?: SortOrder
    household?: HouseholdOrderByWithRelationInput
    paidBy?: UserOrderByWithRelationInput
    splits?: ExpenseSplitOrderByRelationAggregateInput
    transactions?: TransactionOrderByRelationAggregateInput
    receipts?: ReceiptOrderByRelationAggregateInput
    history?: ExpenseHistoryOrderByRelationAggregateInput
  }

  export type ExpenseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ExpenseWhereInput | ExpenseWhereInput[]
    OR?: ExpenseWhereInput[]
    NOT?: ExpenseWhereInput | ExpenseWhereInput[]
    householdId?: StringFilter<"Expense"> | string
    amount?: FloatFilter<"Expense"> | number
    description?: StringFilter<"Expense"> | string
    paidById?: StringFilter<"Expense"> | string
    createdAt?: DateTimeFilter<"Expense"> | Date | string
    updatedAt?: DateTimeFilter<"Expense"> | Date | string
    dueDate?: DateTimeNullableFilter<"Expense"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"Expense"> | Date | string | null
    category?: EnumExpenseCategoryFilter<"Expense"> | $Enums.ExpenseCategory
    household?: XOR<HouseholdRelationFilter, HouseholdWhereInput>
    paidBy?: XOR<UserRelationFilter, UserWhereInput>
    splits?: ExpenseSplitListRelationFilter
    transactions?: TransactionListRelationFilter
    receipts?: ReceiptListRelationFilter
    history?: ExpenseHistoryListRelationFilter
  }, "id">

  export type ExpenseOrderByWithAggregationInput = {
    id?: SortOrder
    householdId?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    paidById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    category?: SortOrder
    _count?: ExpenseCountOrderByAggregateInput
    _avg?: ExpenseAvgOrderByAggregateInput
    _max?: ExpenseMaxOrderByAggregateInput
    _min?: ExpenseMinOrderByAggregateInput
    _sum?: ExpenseSumOrderByAggregateInput
  }

  export type ExpenseScalarWhereWithAggregatesInput = {
    AND?: ExpenseScalarWhereWithAggregatesInput | ExpenseScalarWhereWithAggregatesInput[]
    OR?: ExpenseScalarWhereWithAggregatesInput[]
    NOT?: ExpenseScalarWhereWithAggregatesInput | ExpenseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Expense"> | string
    householdId?: StringWithAggregatesFilter<"Expense"> | string
    amount?: FloatWithAggregatesFilter<"Expense"> | number
    description?: StringWithAggregatesFilter<"Expense"> | string
    paidById?: StringWithAggregatesFilter<"Expense"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Expense"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Expense"> | Date | string
    dueDate?: DateTimeNullableWithAggregatesFilter<"Expense"> | Date | string | null
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Expense"> | Date | string | null
    category?: EnumExpenseCategoryWithAggregatesFilter<"Expense"> | $Enums.ExpenseCategory
  }

  export type ExpenseSplitWhereInput = {
    AND?: ExpenseSplitWhereInput | ExpenseSplitWhereInput[]
    OR?: ExpenseSplitWhereInput[]
    NOT?: ExpenseSplitWhereInput | ExpenseSplitWhereInput[]
    id?: StringFilter<"ExpenseSplit"> | string
    expenseId?: StringFilter<"ExpenseSplit"> | string
    userId?: StringFilter<"ExpenseSplit"> | string
    amount?: FloatFilter<"ExpenseSplit"> | number
    expense?: XOR<ExpenseRelationFilter, ExpenseWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ExpenseSplitOrderByWithRelationInput = {
    id?: SortOrder
    expenseId?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    expense?: ExpenseOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type ExpenseSplitWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    expenseId_userId?: ExpenseSplitExpenseIdUserIdCompoundUniqueInput
    AND?: ExpenseSplitWhereInput | ExpenseSplitWhereInput[]
    OR?: ExpenseSplitWhereInput[]
    NOT?: ExpenseSplitWhereInput | ExpenseSplitWhereInput[]
    expenseId?: StringFilter<"ExpenseSplit"> | string
    userId?: StringFilter<"ExpenseSplit"> | string
    amount?: FloatFilter<"ExpenseSplit"> | number
    expense?: XOR<ExpenseRelationFilter, ExpenseWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "expenseId_userId">

  export type ExpenseSplitOrderByWithAggregationInput = {
    id?: SortOrder
    expenseId?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    _count?: ExpenseSplitCountOrderByAggregateInput
    _avg?: ExpenseSplitAvgOrderByAggregateInput
    _max?: ExpenseSplitMaxOrderByAggregateInput
    _min?: ExpenseSplitMinOrderByAggregateInput
    _sum?: ExpenseSplitSumOrderByAggregateInput
  }

  export type ExpenseSplitScalarWhereWithAggregatesInput = {
    AND?: ExpenseSplitScalarWhereWithAggregatesInput | ExpenseSplitScalarWhereWithAggregatesInput[]
    OR?: ExpenseSplitScalarWhereWithAggregatesInput[]
    NOT?: ExpenseSplitScalarWhereWithAggregatesInput | ExpenseSplitScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ExpenseSplit"> | string
    expenseId?: StringWithAggregatesFilter<"ExpenseSplit"> | string
    userId?: StringWithAggregatesFilter<"ExpenseSplit"> | string
    amount?: FloatWithAggregatesFilter<"ExpenseSplit"> | number
  }

  export type TransactionWhereInput = {
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    id?: StringFilter<"Transaction"> | string
    expenseId?: StringFilter<"Transaction"> | string
    fromUserId?: StringFilter<"Transaction"> | string
    toUserId?: StringFilter<"Transaction"> | string
    amount?: FloatFilter<"Transaction"> | number
    status?: EnumTransactionStatusFilter<"Transaction"> | $Enums.TransactionStatus
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeFilter<"Transaction"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Transaction"> | Date | string | null
    expense?: XOR<ExpenseRelationFilter, ExpenseWhereInput>
    fromUser?: XOR<UserRelationFilter, UserWhereInput>
    toUser?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type TransactionOrderByWithRelationInput = {
    id?: SortOrder
    expenseId?: SortOrder
    fromUserId?: SortOrder
    toUserId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    expense?: ExpenseOrderByWithRelationInput
    fromUser?: UserOrderByWithRelationInput
    toUser?: UserOrderByWithRelationInput
  }

  export type TransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    expenseId?: StringFilter<"Transaction"> | string
    fromUserId?: StringFilter<"Transaction"> | string
    toUserId?: StringFilter<"Transaction"> | string
    amount?: FloatFilter<"Transaction"> | number
    status?: EnumTransactionStatusFilter<"Transaction"> | $Enums.TransactionStatus
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeFilter<"Transaction"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Transaction"> | Date | string | null
    expense?: XOR<ExpenseRelationFilter, ExpenseWhereInput>
    fromUser?: XOR<UserRelationFilter, UserWhereInput>
    toUser?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type TransactionOrderByWithAggregationInput = {
    id?: SortOrder
    expenseId?: SortOrder
    fromUserId?: SortOrder
    toUserId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: TransactionCountOrderByAggregateInput
    _avg?: TransactionAvgOrderByAggregateInput
    _max?: TransactionMaxOrderByAggregateInput
    _min?: TransactionMinOrderByAggregateInput
    _sum?: TransactionSumOrderByAggregateInput
  }

  export type TransactionScalarWhereWithAggregatesInput = {
    AND?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    OR?: TransactionScalarWhereWithAggregatesInput[]
    NOT?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Transaction"> | string
    expenseId?: StringWithAggregatesFilter<"Transaction"> | string
    fromUserId?: StringWithAggregatesFilter<"Transaction"> | string
    toUserId?: StringWithAggregatesFilter<"Transaction"> | string
    amount?: FloatWithAggregatesFilter<"Transaction"> | number
    status?: EnumTransactionStatusWithAggregatesFilter<"Transaction"> | $Enums.TransactionStatus
    createdAt?: DateTimeWithAggregatesFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Transaction"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Transaction"> | Date | string | null
  }

  export type ReceiptWhereInput = {
    AND?: ReceiptWhereInput | ReceiptWhereInput[]
    OR?: ReceiptWhereInput[]
    NOT?: ReceiptWhereInput | ReceiptWhereInput[]
    id?: StringFilter<"Receipt"> | string
    expenseId?: StringFilter<"Receipt"> | string
    url?: StringFilter<"Receipt"> | string
    fileType?: StringFilter<"Receipt"> | string
    createdAt?: DateTimeFilter<"Receipt"> | Date | string
    expense?: XOR<ExpenseRelationFilter, ExpenseWhereInput>
  }

  export type ReceiptOrderByWithRelationInput = {
    id?: SortOrder
    expenseId?: SortOrder
    url?: SortOrder
    fileType?: SortOrder
    createdAt?: SortOrder
    expense?: ExpenseOrderByWithRelationInput
  }

  export type ReceiptWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ReceiptWhereInput | ReceiptWhereInput[]
    OR?: ReceiptWhereInput[]
    NOT?: ReceiptWhereInput | ReceiptWhereInput[]
    expenseId?: StringFilter<"Receipt"> | string
    url?: StringFilter<"Receipt"> | string
    fileType?: StringFilter<"Receipt"> | string
    createdAt?: DateTimeFilter<"Receipt"> | Date | string
    expense?: XOR<ExpenseRelationFilter, ExpenseWhereInput>
  }, "id">

  export type ReceiptOrderByWithAggregationInput = {
    id?: SortOrder
    expenseId?: SortOrder
    url?: SortOrder
    fileType?: SortOrder
    createdAt?: SortOrder
    _count?: ReceiptCountOrderByAggregateInput
    _max?: ReceiptMaxOrderByAggregateInput
    _min?: ReceiptMinOrderByAggregateInput
  }

  export type ReceiptScalarWhereWithAggregatesInput = {
    AND?: ReceiptScalarWhereWithAggregatesInput | ReceiptScalarWhereWithAggregatesInput[]
    OR?: ReceiptScalarWhereWithAggregatesInput[]
    NOT?: ReceiptScalarWhereWithAggregatesInput | ReceiptScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Receipt"> | string
    expenseId?: StringWithAggregatesFilter<"Receipt"> | string
    url?: StringWithAggregatesFilter<"Receipt"> | string
    fileType?: StringWithAggregatesFilter<"Receipt"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Receipt"> | Date | string
  }

  export type ExpenseHistoryWhereInput = {
    AND?: ExpenseHistoryWhereInput | ExpenseHistoryWhereInput[]
    OR?: ExpenseHistoryWhereInput[]
    NOT?: ExpenseHistoryWhereInput | ExpenseHistoryWhereInput[]
    id?: StringFilter<"ExpenseHistory"> | string
    expenseId?: StringFilter<"ExpenseHistory"> | string
    action?: EnumExpenseActionFilter<"ExpenseHistory"> | $Enums.ExpenseAction
    changedById?: StringFilter<"ExpenseHistory"> | string
    changedAt?: DateTimeFilter<"ExpenseHistory"> | Date | string
    expense?: XOR<ExpenseRelationFilter, ExpenseWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ExpenseHistoryOrderByWithRelationInput = {
    id?: SortOrder
    expenseId?: SortOrder
    action?: SortOrder
    changedById?: SortOrder
    changedAt?: SortOrder
    expense?: ExpenseOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type ExpenseHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ExpenseHistoryWhereInput | ExpenseHistoryWhereInput[]
    OR?: ExpenseHistoryWhereInput[]
    NOT?: ExpenseHistoryWhereInput | ExpenseHistoryWhereInput[]
    expenseId?: StringFilter<"ExpenseHistory"> | string
    action?: EnumExpenseActionFilter<"ExpenseHistory"> | $Enums.ExpenseAction
    changedById?: StringFilter<"ExpenseHistory"> | string
    changedAt?: DateTimeFilter<"ExpenseHistory"> | Date | string
    expense?: XOR<ExpenseRelationFilter, ExpenseWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type ExpenseHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    expenseId?: SortOrder
    action?: SortOrder
    changedById?: SortOrder
    changedAt?: SortOrder
    _count?: ExpenseHistoryCountOrderByAggregateInput
    _max?: ExpenseHistoryMaxOrderByAggregateInput
    _min?: ExpenseHistoryMinOrderByAggregateInput
  }

  export type ExpenseHistoryScalarWhereWithAggregatesInput = {
    AND?: ExpenseHistoryScalarWhereWithAggregatesInput | ExpenseHistoryScalarWhereWithAggregatesInput[]
    OR?: ExpenseHistoryScalarWhereWithAggregatesInput[]
    NOT?: ExpenseHistoryScalarWhereWithAggregatesInput | ExpenseHistoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ExpenseHistory"> | string
    expenseId?: StringWithAggregatesFilter<"ExpenseHistory"> | string
    action?: EnumExpenseActionWithAggregatesFilter<"ExpenseHistory"> | $Enums.ExpenseAction
    changedById?: StringWithAggregatesFilter<"ExpenseHistory"> | string
    changedAt?: DateTimeWithAggregatesFilter<"ExpenseHistory"> | Date | string
  }

  export type EventWhereInput = {
    AND?: EventWhereInput | EventWhereInput[]
    OR?: EventWhereInput[]
    NOT?: EventWhereInput | EventWhereInput[]
    id?: StringFilter<"Event"> | string
    householdId?: StringFilter<"Event"> | string
    title?: StringFilter<"Event"> | string
    description?: StringNullableFilter<"Event"> | string | null
    startTime?: DateTimeFilter<"Event"> | Date | string
    endTime?: DateTimeFilter<"Event"> | Date | string
    createdById?: StringFilter<"Event"> | string
    createdAt?: DateTimeFilter<"Event"> | Date | string
    updatedAt?: DateTimeFilter<"Event"> | Date | string
    choreId?: StringNullableFilter<"Event"> | string | null
    recurrenceRuleId?: StringNullableFilter<"Event"> | string | null
    category?: EnumEventCategoryFilter<"Event"> | $Enums.EventCategory
    isAllDay?: BoolFilter<"Event"> | boolean
    location?: StringNullableFilter<"Event"> | string | null
    isPrivate?: BoolFilter<"Event"> | boolean
    status?: EnumEventStatusFilter<"Event"> | $Enums.EventStatus
    deletedAt?: DateTimeNullableFilter<"Event"> | Date | string | null
    reminders?: EventReminderListRelationFilter
    household?: XOR<HouseholdRelationFilter, HouseholdWhereInput>
    createdBy?: XOR<UserRelationFilter, UserWhereInput>
    chore?: XOR<ChoreNullableRelationFilter, ChoreWhereInput> | null
    recurrenceRule?: XOR<RecurrenceRuleNullableRelationFilter, RecurrenceRuleWhereInput> | null
    history?: CalendarEventHistoryListRelationFilter
  }

  export type EventOrderByWithRelationInput = {
    id?: SortOrder
    householdId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    choreId?: SortOrderInput | SortOrder
    recurrenceRuleId?: SortOrderInput | SortOrder
    category?: SortOrder
    isAllDay?: SortOrder
    location?: SortOrderInput | SortOrder
    isPrivate?: SortOrder
    status?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    reminders?: EventReminderOrderByRelationAggregateInput
    household?: HouseholdOrderByWithRelationInput
    createdBy?: UserOrderByWithRelationInput
    chore?: ChoreOrderByWithRelationInput
    recurrenceRule?: RecurrenceRuleOrderByWithRelationInput
    history?: CalendarEventHistoryOrderByRelationAggregateInput
  }

  export type EventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    choreId?: string
    AND?: EventWhereInput | EventWhereInput[]
    OR?: EventWhereInput[]
    NOT?: EventWhereInput | EventWhereInput[]
    householdId?: StringFilter<"Event"> | string
    title?: StringFilter<"Event"> | string
    description?: StringNullableFilter<"Event"> | string | null
    startTime?: DateTimeFilter<"Event"> | Date | string
    endTime?: DateTimeFilter<"Event"> | Date | string
    createdById?: StringFilter<"Event"> | string
    createdAt?: DateTimeFilter<"Event"> | Date | string
    updatedAt?: DateTimeFilter<"Event"> | Date | string
    recurrenceRuleId?: StringNullableFilter<"Event"> | string | null
    category?: EnumEventCategoryFilter<"Event"> | $Enums.EventCategory
    isAllDay?: BoolFilter<"Event"> | boolean
    location?: StringNullableFilter<"Event"> | string | null
    isPrivate?: BoolFilter<"Event"> | boolean
    status?: EnumEventStatusFilter<"Event"> | $Enums.EventStatus
    deletedAt?: DateTimeNullableFilter<"Event"> | Date | string | null
    reminders?: EventReminderListRelationFilter
    household?: XOR<HouseholdRelationFilter, HouseholdWhereInput>
    createdBy?: XOR<UserRelationFilter, UserWhereInput>
    chore?: XOR<ChoreNullableRelationFilter, ChoreWhereInput> | null
    recurrenceRule?: XOR<RecurrenceRuleNullableRelationFilter, RecurrenceRuleWhereInput> | null
    history?: CalendarEventHistoryListRelationFilter
  }, "id" | "choreId">

  export type EventOrderByWithAggregationInput = {
    id?: SortOrder
    householdId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    choreId?: SortOrderInput | SortOrder
    recurrenceRuleId?: SortOrderInput | SortOrder
    category?: SortOrder
    isAllDay?: SortOrder
    location?: SortOrderInput | SortOrder
    isPrivate?: SortOrder
    status?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: EventCountOrderByAggregateInput
    _max?: EventMaxOrderByAggregateInput
    _min?: EventMinOrderByAggregateInput
  }

  export type EventScalarWhereWithAggregatesInput = {
    AND?: EventScalarWhereWithAggregatesInput | EventScalarWhereWithAggregatesInput[]
    OR?: EventScalarWhereWithAggregatesInput[]
    NOT?: EventScalarWhereWithAggregatesInput | EventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Event"> | string
    householdId?: StringWithAggregatesFilter<"Event"> | string
    title?: StringWithAggregatesFilter<"Event"> | string
    description?: StringNullableWithAggregatesFilter<"Event"> | string | null
    startTime?: DateTimeWithAggregatesFilter<"Event"> | Date | string
    endTime?: DateTimeWithAggregatesFilter<"Event"> | Date | string
    createdById?: StringWithAggregatesFilter<"Event"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Event"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Event"> | Date | string
    choreId?: StringNullableWithAggregatesFilter<"Event"> | string | null
    recurrenceRuleId?: StringNullableWithAggregatesFilter<"Event"> | string | null
    category?: EnumEventCategoryWithAggregatesFilter<"Event"> | $Enums.EventCategory
    isAllDay?: BoolWithAggregatesFilter<"Event"> | boolean
    location?: StringNullableWithAggregatesFilter<"Event"> | string | null
    isPrivate?: BoolWithAggregatesFilter<"Event"> | boolean
    status?: EnumEventStatusWithAggregatesFilter<"Event"> | $Enums.EventStatus
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Event"> | Date | string | null
  }

  export type EventReminderWhereInput = {
    AND?: EventReminderWhereInput | EventReminderWhereInput[]
    OR?: EventReminderWhereInput[]
    NOT?: EventReminderWhereInput | EventReminderWhereInput[]
    id?: StringFilter<"EventReminder"> | string
    eventId?: StringFilter<"EventReminder"> | string
    time?: DateTimeFilter<"EventReminder"> | Date | string
    type?: EnumEventReminderTypeFilter<"EventReminder"> | $Enums.EventReminderType
    event?: XOR<EventRelationFilter, EventWhereInput>
  }

  export type EventReminderOrderByWithRelationInput = {
    id?: SortOrder
    eventId?: SortOrder
    time?: SortOrder
    type?: SortOrder
    event?: EventOrderByWithRelationInput
  }

  export type EventReminderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EventReminderWhereInput | EventReminderWhereInput[]
    OR?: EventReminderWhereInput[]
    NOT?: EventReminderWhereInput | EventReminderWhereInput[]
    eventId?: StringFilter<"EventReminder"> | string
    time?: DateTimeFilter<"EventReminder"> | Date | string
    type?: EnumEventReminderTypeFilter<"EventReminder"> | $Enums.EventReminderType
    event?: XOR<EventRelationFilter, EventWhereInput>
  }, "id">

  export type EventReminderOrderByWithAggregationInput = {
    id?: SortOrder
    eventId?: SortOrder
    time?: SortOrder
    type?: SortOrder
    _count?: EventReminderCountOrderByAggregateInput
    _max?: EventReminderMaxOrderByAggregateInput
    _min?: EventReminderMinOrderByAggregateInput
  }

  export type EventReminderScalarWhereWithAggregatesInput = {
    AND?: EventReminderScalarWhereWithAggregatesInput | EventReminderScalarWhereWithAggregatesInput[]
    OR?: EventReminderScalarWhereWithAggregatesInput[]
    NOT?: EventReminderScalarWhereWithAggregatesInput | EventReminderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EventReminder"> | string
    eventId?: StringWithAggregatesFilter<"EventReminder"> | string
    time?: DateTimeWithAggregatesFilter<"EventReminder"> | Date | string
    type?: EnumEventReminderTypeWithAggregatesFilter<"EventReminder"> | $Enums.EventReminderType
  }

  export type CalendarEventHistoryWhereInput = {
    AND?: CalendarEventHistoryWhereInput | CalendarEventHistoryWhereInput[]
    OR?: CalendarEventHistoryWhereInput[]
    NOT?: CalendarEventHistoryWhereInput | CalendarEventHistoryWhereInput[]
    id?: StringFilter<"CalendarEventHistory"> | string
    eventId?: StringFilter<"CalendarEventHistory"> | string
    action?: EnumCalendarEventActionFilter<"CalendarEventHistory"> | $Enums.CalendarEventAction
    changedById?: StringFilter<"CalendarEventHistory"> | string
    changedAt?: DateTimeFilter<"CalendarEventHistory"> | Date | string
    event?: XOR<EventRelationFilter, EventWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type CalendarEventHistoryOrderByWithRelationInput = {
    id?: SortOrder
    eventId?: SortOrder
    action?: SortOrder
    changedById?: SortOrder
    changedAt?: SortOrder
    event?: EventOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type CalendarEventHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CalendarEventHistoryWhereInput | CalendarEventHistoryWhereInput[]
    OR?: CalendarEventHistoryWhereInput[]
    NOT?: CalendarEventHistoryWhereInput | CalendarEventHistoryWhereInput[]
    eventId?: StringFilter<"CalendarEventHistory"> | string
    action?: EnumCalendarEventActionFilter<"CalendarEventHistory"> | $Enums.CalendarEventAction
    changedById?: StringFilter<"CalendarEventHistory"> | string
    changedAt?: DateTimeFilter<"CalendarEventHistory"> | Date | string
    event?: XOR<EventRelationFilter, EventWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type CalendarEventHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    eventId?: SortOrder
    action?: SortOrder
    changedById?: SortOrder
    changedAt?: SortOrder
    _count?: CalendarEventHistoryCountOrderByAggregateInput
    _max?: CalendarEventHistoryMaxOrderByAggregateInput
    _min?: CalendarEventHistoryMinOrderByAggregateInput
  }

  export type CalendarEventHistoryScalarWhereWithAggregatesInput = {
    AND?: CalendarEventHistoryScalarWhereWithAggregatesInput | CalendarEventHistoryScalarWhereWithAggregatesInput[]
    OR?: CalendarEventHistoryScalarWhereWithAggregatesInput[]
    NOT?: CalendarEventHistoryScalarWhereWithAggregatesInput | CalendarEventHistoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CalendarEventHistory"> | string
    eventId?: StringWithAggregatesFilter<"CalendarEventHistory"> | string
    action?: EnumCalendarEventActionWithAggregatesFilter<"CalendarEventHistory"> | $Enums.CalendarEventAction
    changedById?: StringWithAggregatesFilter<"CalendarEventHistory"> | string
    changedAt?: DateTimeWithAggregatesFilter<"CalendarEventHistory"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    message?: StringFilter<"Notification"> | string
    isRead?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    userId?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    message?: StringFilter<"Notification"> | string
    isRead?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    userId?: StringWithAggregatesFilter<"Notification"> | string
    type?: EnumNotificationTypeWithAggregatesFilter<"Notification"> | $Enums.NotificationType
    message?: StringWithAggregatesFilter<"Notification"> | string
    isRead?: BoolWithAggregatesFilter<"Notification"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type NotificationSettingsWhereInput = {
    AND?: NotificationSettingsWhereInput | NotificationSettingsWhereInput[]
    OR?: NotificationSettingsWhereInput[]
    NOT?: NotificationSettingsWhereInput | NotificationSettingsWhereInput[]
    id?: StringFilter<"NotificationSettings"> | string
    userId?: StringNullableFilter<"NotificationSettings"> | string | null
    householdId?: StringNullableFilter<"NotificationSettings"> | string | null
    messageNotif?: BoolFilter<"NotificationSettings"> | boolean
    mentionsNotif?: BoolFilter<"NotificationSettings"> | boolean
    reactionsNotif?: BoolFilter<"NotificationSettings"> | boolean
    choreNotif?: BoolFilter<"NotificationSettings"> | boolean
    financeNotif?: BoolFilter<"NotificationSettings"> | boolean
    calendarNotif?: BoolFilter<"NotificationSettings"> | boolean
    remindersNotif?: BoolFilter<"NotificationSettings"> | boolean
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    household?: XOR<HouseholdNullableRelationFilter, HouseholdWhereInput> | null
  }

  export type NotificationSettingsOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    householdId?: SortOrderInput | SortOrder
    messageNotif?: SortOrder
    mentionsNotif?: SortOrder
    reactionsNotif?: SortOrder
    choreNotif?: SortOrder
    financeNotif?: SortOrder
    calendarNotif?: SortOrder
    remindersNotif?: SortOrder
    user?: UserOrderByWithRelationInput
    household?: HouseholdOrderByWithRelationInput
  }

  export type NotificationSettingsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationSettingsWhereInput | NotificationSettingsWhereInput[]
    OR?: NotificationSettingsWhereInput[]
    NOT?: NotificationSettingsWhereInput | NotificationSettingsWhereInput[]
    userId?: StringNullableFilter<"NotificationSettings"> | string | null
    householdId?: StringNullableFilter<"NotificationSettings"> | string | null
    messageNotif?: BoolFilter<"NotificationSettings"> | boolean
    mentionsNotif?: BoolFilter<"NotificationSettings"> | boolean
    reactionsNotif?: BoolFilter<"NotificationSettings"> | boolean
    choreNotif?: BoolFilter<"NotificationSettings"> | boolean
    financeNotif?: BoolFilter<"NotificationSettings"> | boolean
    calendarNotif?: BoolFilter<"NotificationSettings"> | boolean
    remindersNotif?: BoolFilter<"NotificationSettings"> | boolean
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    household?: XOR<HouseholdNullableRelationFilter, HouseholdWhereInput> | null
  }, "id">

  export type NotificationSettingsOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    householdId?: SortOrderInput | SortOrder
    messageNotif?: SortOrder
    mentionsNotif?: SortOrder
    reactionsNotif?: SortOrder
    choreNotif?: SortOrder
    financeNotif?: SortOrder
    calendarNotif?: SortOrder
    remindersNotif?: SortOrder
    _count?: NotificationSettingsCountOrderByAggregateInput
    _max?: NotificationSettingsMaxOrderByAggregateInput
    _min?: NotificationSettingsMinOrderByAggregateInput
  }

  export type NotificationSettingsScalarWhereWithAggregatesInput = {
    AND?: NotificationSettingsScalarWhereWithAggregatesInput | NotificationSettingsScalarWhereWithAggregatesInput[]
    OR?: NotificationSettingsScalarWhereWithAggregatesInput[]
    NOT?: NotificationSettingsScalarWhereWithAggregatesInput | NotificationSettingsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NotificationSettings"> | string
    userId?: StringNullableWithAggregatesFilter<"NotificationSettings"> | string | null
    householdId?: StringNullableWithAggregatesFilter<"NotificationSettings"> | string | null
    messageNotif?: BoolWithAggregatesFilter<"NotificationSettings"> | boolean
    mentionsNotif?: BoolWithAggregatesFilter<"NotificationSettings"> | boolean
    reactionsNotif?: BoolWithAggregatesFilter<"NotificationSettings"> | boolean
    choreNotif?: BoolWithAggregatesFilter<"NotificationSettings"> | boolean
    financeNotif?: BoolWithAggregatesFilter<"NotificationSettings"> | boolean
    calendarNotif?: BoolWithAggregatesFilter<"NotificationSettings"> | boolean
    remindersNotif?: BoolWithAggregatesFilter<"NotificationSettings"> | boolean
  }

  export type OAuthIntegrationWhereInput = {
    AND?: OAuthIntegrationWhereInput | OAuthIntegrationWhereInput[]
    OR?: OAuthIntegrationWhereInput[]
    NOT?: OAuthIntegrationWhereInput | OAuthIntegrationWhereInput[]
    id?: StringFilter<"OAuthIntegration"> | string
    userId?: StringFilter<"OAuthIntegration"> | string
    provider?: EnumProviderFilter<"OAuthIntegration"> | $Enums.Provider
    accessToken?: StringFilter<"OAuthIntegration"> | string
    refreshToken?: StringNullableFilter<"OAuthIntegration"> | string | null
    expiresAt?: DateTimeNullableFilter<"OAuthIntegration"> | Date | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type OAuthIntegrationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type OAuthIntegrationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_provider?: OAuthIntegrationUserIdProviderCompoundUniqueInput
    AND?: OAuthIntegrationWhereInput | OAuthIntegrationWhereInput[]
    OR?: OAuthIntegrationWhereInput[]
    NOT?: OAuthIntegrationWhereInput | OAuthIntegrationWhereInput[]
    userId?: StringFilter<"OAuthIntegration"> | string
    provider?: EnumProviderFilter<"OAuthIntegration"> | $Enums.Provider
    accessToken?: StringFilter<"OAuthIntegration"> | string
    refreshToken?: StringNullableFilter<"OAuthIntegration"> | string | null
    expiresAt?: DateTimeNullableFilter<"OAuthIntegration"> | Date | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "userId_provider">

  export type OAuthIntegrationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    _count?: OAuthIntegrationCountOrderByAggregateInput
    _max?: OAuthIntegrationMaxOrderByAggregateInput
    _min?: OAuthIntegrationMinOrderByAggregateInput
  }

  export type OAuthIntegrationScalarWhereWithAggregatesInput = {
    AND?: OAuthIntegrationScalarWhereWithAggregatesInput | OAuthIntegrationScalarWhereWithAggregatesInput[]
    OR?: OAuthIntegrationScalarWhereWithAggregatesInput[]
    NOT?: OAuthIntegrationScalarWhereWithAggregatesInput | OAuthIntegrationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OAuthIntegration"> | string
    userId?: StringWithAggregatesFilter<"OAuthIntegration"> | string
    provider?: EnumProviderWithAggregatesFilter<"OAuthIntegration"> | $Enums.Provider
    accessToken?: StringWithAggregatesFilter<"OAuthIntegration"> | string
    refreshToken?: StringNullableWithAggregatesFilter<"OAuthIntegration"> | string | null
    expiresAt?: DateTimeNullableWithAggregatesFilter<"OAuthIntegration"> | Date | string | null
  }

  export type UserCreateInput = {
    id?: string
    email: string
    passwordHash?: string | null
    name: string
    profileImageURL?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deviceTokens?: UserCreatedeviceTokensInput | string[]
    deletedAt?: Date | string | null
    households?: HouseholdMemberCreateNestedManyWithoutUserInput
    messages?: MessageCreateNestedManyWithoutAuthorInput
    threads?: ThreadCreateNestedManyWithoutAuthorInput
    assignedChores?: ChoreAssignmentCreateNestedManyWithoutUserInput
    expensesPaid?: ExpenseCreateNestedManyWithoutPaidByInput
    expenseSplits?: ExpenseSplitCreateNestedManyWithoutUserInput
    transactionsFrom?: TransactionCreateNestedManyWithoutFromUserInput
    transactionsTo?: TransactionCreateNestedManyWithoutToUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    oauthIntegrations?: OAuthIntegrationCreateNestedManyWithoutUserInput
    eventsCreated?: EventCreateNestedManyWithoutCreatedByInput
    choreSwapRequestsInitiated?: ChoreSwapRequestCreateNestedManyWithoutRequestingUserInput
    choreSwapRequestsReceived?: ChoreSwapRequestCreateNestedManyWithoutTargetUserInput
    reactions?: ReactionCreateNestedManyWithoutUserInput
    mentions?: MentionCreateNestedManyWithoutUserInput
    choreHistory?: ChoreHistoryCreateNestedManyWithoutUserInput
    notificationSettings?: NotificationSettingsCreateNestedManyWithoutUserInput
    calendarEventHistory?: CalendarEventHistoryCreateNestedManyWithoutUserInput
    expenseHistory?: ExpenseHistoryCreateNestedManyWithoutUserInput
    messageReads?: MessageReadCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    passwordHash?: string | null
    name: string
    profileImageURL?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deviceTokens?: UserCreatedeviceTokensInput | string[]
    deletedAt?: Date | string | null
    households?: HouseholdMemberUncheckedCreateNestedManyWithoutUserInput
    messages?: MessageUncheckedCreateNestedManyWithoutAuthorInput
    threads?: ThreadUncheckedCreateNestedManyWithoutAuthorInput
    assignedChores?: ChoreAssignmentUncheckedCreateNestedManyWithoutUserInput
    expensesPaid?: ExpenseUncheckedCreateNestedManyWithoutPaidByInput
    expenseSplits?: ExpenseSplitUncheckedCreateNestedManyWithoutUserInput
    transactionsFrom?: TransactionUncheckedCreateNestedManyWithoutFromUserInput
    transactionsTo?: TransactionUncheckedCreateNestedManyWithoutToUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    oauthIntegrations?: OAuthIntegrationUncheckedCreateNestedManyWithoutUserInput
    eventsCreated?: EventUncheckedCreateNestedManyWithoutCreatedByInput
    choreSwapRequestsInitiated?: ChoreSwapRequestUncheckedCreateNestedManyWithoutRequestingUserInput
    choreSwapRequestsReceived?: ChoreSwapRequestUncheckedCreateNestedManyWithoutTargetUserInput
    reactions?: ReactionUncheckedCreateNestedManyWithoutUserInput
    mentions?: MentionUncheckedCreateNestedManyWithoutUserInput
    choreHistory?: ChoreHistoryUncheckedCreateNestedManyWithoutUserInput
    notificationSettings?: NotificationSettingsUncheckedCreateNestedManyWithoutUserInput
    calendarEventHistory?: CalendarEventHistoryUncheckedCreateNestedManyWithoutUserInput
    expenseHistory?: ExpenseHistoryUncheckedCreateNestedManyWithoutUserInput
    messageReads?: MessageReadUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    profileImageURL?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deviceTokens?: UserUpdatedeviceTokensInput | string[]
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    households?: HouseholdMemberUpdateManyWithoutUserNestedInput
    messages?: MessageUpdateManyWithoutAuthorNestedInput
    threads?: ThreadUpdateManyWithoutAuthorNestedInput
    assignedChores?: ChoreAssignmentUpdateManyWithoutUserNestedInput
    expensesPaid?: ExpenseUpdateManyWithoutPaidByNestedInput
    expenseSplits?: ExpenseSplitUpdateManyWithoutUserNestedInput
    transactionsFrom?: TransactionUpdateManyWithoutFromUserNestedInput
    transactionsTo?: TransactionUpdateManyWithoutToUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    oauthIntegrations?: OAuthIntegrationUpdateManyWithoutUserNestedInput
    eventsCreated?: EventUpdateManyWithoutCreatedByNestedInput
    choreSwapRequestsInitiated?: ChoreSwapRequestUpdateManyWithoutRequestingUserNestedInput
    choreSwapRequestsReceived?: ChoreSwapRequestUpdateManyWithoutTargetUserNestedInput
    reactions?: ReactionUpdateManyWithoutUserNestedInput
    mentions?: MentionUpdateManyWithoutUserNestedInput
    choreHistory?: ChoreHistoryUpdateManyWithoutUserNestedInput
    notificationSettings?: NotificationSettingsUpdateManyWithoutUserNestedInput
    calendarEventHistory?: CalendarEventHistoryUpdateManyWithoutUserNestedInput
    expenseHistory?: ExpenseHistoryUpdateManyWithoutUserNestedInput
    messageReads?: MessageReadUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    profileImageURL?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deviceTokens?: UserUpdatedeviceTokensInput | string[]
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    households?: HouseholdMemberUncheckedUpdateManyWithoutUserNestedInput
    messages?: MessageUncheckedUpdateManyWithoutAuthorNestedInput
    threads?: ThreadUncheckedUpdateManyWithoutAuthorNestedInput
    assignedChores?: ChoreAssignmentUncheckedUpdateManyWithoutUserNestedInput
    expensesPaid?: ExpenseUncheckedUpdateManyWithoutPaidByNestedInput
    expenseSplits?: ExpenseSplitUncheckedUpdateManyWithoutUserNestedInput
    transactionsFrom?: TransactionUncheckedUpdateManyWithoutFromUserNestedInput
    transactionsTo?: TransactionUncheckedUpdateManyWithoutToUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    oauthIntegrations?: OAuthIntegrationUncheckedUpdateManyWithoutUserNestedInput
    eventsCreated?: EventUncheckedUpdateManyWithoutCreatedByNestedInput
    choreSwapRequestsInitiated?: ChoreSwapRequestUncheckedUpdateManyWithoutRequestingUserNestedInput
    choreSwapRequestsReceived?: ChoreSwapRequestUncheckedUpdateManyWithoutTargetUserNestedInput
    reactions?: ReactionUncheckedUpdateManyWithoutUserNestedInput
    mentions?: MentionUncheckedUpdateManyWithoutUserNestedInput
    choreHistory?: ChoreHistoryUncheckedUpdateManyWithoutUserNestedInput
    notificationSettings?: NotificationSettingsUncheckedUpdateManyWithoutUserNestedInput
    calendarEventHistory?: CalendarEventHistoryUncheckedUpdateManyWithoutUserNestedInput
    expenseHistory?: ExpenseHistoryUncheckedUpdateManyWithoutUserNestedInput
    messageReads?: MessageReadUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    passwordHash?: string | null
    name: string
    profileImageURL?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deviceTokens?: UserCreatedeviceTokensInput | string[]
    deletedAt?: Date | string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    profileImageURL?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deviceTokens?: UserUpdatedeviceTokensInput | string[]
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    profileImageURL?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deviceTokens?: UserUpdatedeviceTokensInput | string[]
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type HouseholdCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    currency?: string
    icon?: string | null
    timezone?: string
    language?: string
    deletedAt?: Date | string | null
    members?: HouseholdMemberCreateNestedManyWithoutHouseholdInput
    threads?: ThreadCreateNestedManyWithoutHouseholdInput
    chores?: ChoreCreateNestedManyWithoutHouseholdInput
    expenses?: ExpenseCreateNestedManyWithoutHouseholdInput
    events?: EventCreateNestedManyWithoutHouseholdInput
    choreTemplates?: ChoreTemplateCreateNestedManyWithoutHouseholdInput
    notificationSettings?: NotificationSettingsCreateNestedManyWithoutHouseholdInput
  }

  export type HouseholdUncheckedCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    currency?: string
    icon?: string | null
    timezone?: string
    language?: string
    deletedAt?: Date | string | null
    members?: HouseholdMemberUncheckedCreateNestedManyWithoutHouseholdInput
    threads?: ThreadUncheckedCreateNestedManyWithoutHouseholdInput
    chores?: ChoreUncheckedCreateNestedManyWithoutHouseholdInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutHouseholdInput
    events?: EventUncheckedCreateNestedManyWithoutHouseholdInput
    choreTemplates?: ChoreTemplateUncheckedCreateNestedManyWithoutHouseholdInput
    notificationSettings?: NotificationSettingsUncheckedCreateNestedManyWithoutHouseholdInput
  }

  export type HouseholdUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    members?: HouseholdMemberUpdateManyWithoutHouseholdNestedInput
    threads?: ThreadUpdateManyWithoutHouseholdNestedInput
    chores?: ChoreUpdateManyWithoutHouseholdNestedInput
    expenses?: ExpenseUpdateManyWithoutHouseholdNestedInput
    events?: EventUpdateManyWithoutHouseholdNestedInput
    choreTemplates?: ChoreTemplateUpdateManyWithoutHouseholdNestedInput
    notificationSettings?: NotificationSettingsUpdateManyWithoutHouseholdNestedInput
  }

  export type HouseholdUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    members?: HouseholdMemberUncheckedUpdateManyWithoutHouseholdNestedInput
    threads?: ThreadUncheckedUpdateManyWithoutHouseholdNestedInput
    chores?: ChoreUncheckedUpdateManyWithoutHouseholdNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutHouseholdNestedInput
    events?: EventUncheckedUpdateManyWithoutHouseholdNestedInput
    choreTemplates?: ChoreTemplateUncheckedUpdateManyWithoutHouseholdNestedInput
    notificationSettings?: NotificationSettingsUncheckedUpdateManyWithoutHouseholdNestedInput
  }

  export type HouseholdCreateManyInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    currency?: string
    icon?: string | null
    timezone?: string
    language?: string
    deletedAt?: Date | string | null
  }

  export type HouseholdUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type HouseholdUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type HouseholdMemberCreateInput = {
    id?: string
    role?: $Enums.HouseholdRole
    joinedAt?: Date | string
    leftAt?: Date | string | null
    isInvited?: boolean
    isAccepted?: boolean
    isRejected?: boolean
    isSelected?: boolean
    lastAssignedChoreAt?: Date | string | null
    user: UserCreateNestedOneWithoutHouseholdsInput
    household: HouseholdCreateNestedOneWithoutMembersInput
    threads?: ThreadCreateNestedManyWithoutParticipantsInput
  }

  export type HouseholdMemberUncheckedCreateInput = {
    id?: string
    userId: string
    householdId: string
    role?: $Enums.HouseholdRole
    joinedAt?: Date | string
    leftAt?: Date | string | null
    isInvited?: boolean
    isAccepted?: boolean
    isRejected?: boolean
    isSelected?: boolean
    lastAssignedChoreAt?: Date | string | null
    threads?: ThreadUncheckedCreateNestedManyWithoutParticipantsInput
  }

  export type HouseholdMemberUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumHouseholdRoleFieldUpdateOperationsInput | $Enums.HouseholdRole
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isInvited?: BoolFieldUpdateOperationsInput | boolean
    isAccepted?: BoolFieldUpdateOperationsInput | boolean
    isRejected?: BoolFieldUpdateOperationsInput | boolean
    isSelected?: BoolFieldUpdateOperationsInput | boolean
    lastAssignedChoreAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutHouseholdsNestedInput
    household?: HouseholdUpdateOneRequiredWithoutMembersNestedInput
    threads?: ThreadUpdateManyWithoutParticipantsNestedInput
  }

  export type HouseholdMemberUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    role?: EnumHouseholdRoleFieldUpdateOperationsInput | $Enums.HouseholdRole
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isInvited?: BoolFieldUpdateOperationsInput | boolean
    isAccepted?: BoolFieldUpdateOperationsInput | boolean
    isRejected?: BoolFieldUpdateOperationsInput | boolean
    isSelected?: BoolFieldUpdateOperationsInput | boolean
    lastAssignedChoreAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    threads?: ThreadUncheckedUpdateManyWithoutParticipantsNestedInput
  }

  export type HouseholdMemberCreateManyInput = {
    id?: string
    userId: string
    householdId: string
    role?: $Enums.HouseholdRole
    joinedAt?: Date | string
    leftAt?: Date | string | null
    isInvited?: boolean
    isAccepted?: boolean
    isRejected?: boolean
    isSelected?: boolean
    lastAssignedChoreAt?: Date | string | null
  }

  export type HouseholdMemberUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumHouseholdRoleFieldUpdateOperationsInput | $Enums.HouseholdRole
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isInvited?: BoolFieldUpdateOperationsInput | boolean
    isAccepted?: BoolFieldUpdateOperationsInput | boolean
    isRejected?: BoolFieldUpdateOperationsInput | boolean
    isSelected?: BoolFieldUpdateOperationsInput | boolean
    lastAssignedChoreAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type HouseholdMemberUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    role?: EnumHouseholdRoleFieldUpdateOperationsInput | $Enums.HouseholdRole
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isInvited?: BoolFieldUpdateOperationsInput | boolean
    isAccepted?: BoolFieldUpdateOperationsInput | boolean
    isRejected?: BoolFieldUpdateOperationsInput | boolean
    isSelected?: BoolFieldUpdateOperationsInput | boolean
    lastAssignedChoreAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RecurrenceRuleCreateInput = {
    id?: string
    frequency: $Enums.RecurrenceFrequency
    interval?: number
    byWeekDay?: RecurrenceRuleCreatebyWeekDayInput | $Enums.DaysOfWeek[]
    byMonthDay?: RecurrenceRuleCreatebyMonthDayInput | number[]
    bySetPos?: number | null
    count?: number | null
    until?: Date | string | null
    customRuleString?: string | null
    chores?: ChoreCreateNestedManyWithoutRecurrenceRuleInput
    events?: EventCreateNestedManyWithoutRecurrenceRuleInput
  }

  export type RecurrenceRuleUncheckedCreateInput = {
    id?: string
    frequency: $Enums.RecurrenceFrequency
    interval?: number
    byWeekDay?: RecurrenceRuleCreatebyWeekDayInput | $Enums.DaysOfWeek[]
    byMonthDay?: RecurrenceRuleCreatebyMonthDayInput | number[]
    bySetPos?: number | null
    count?: number | null
    until?: Date | string | null
    customRuleString?: string | null
    chores?: ChoreUncheckedCreateNestedManyWithoutRecurrenceRuleInput
    events?: EventUncheckedCreateNestedManyWithoutRecurrenceRuleInput
  }

  export type RecurrenceRuleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    frequency?: EnumRecurrenceFrequencyFieldUpdateOperationsInput | $Enums.RecurrenceFrequency
    interval?: IntFieldUpdateOperationsInput | number
    byWeekDay?: RecurrenceRuleUpdatebyWeekDayInput | $Enums.DaysOfWeek[]
    byMonthDay?: RecurrenceRuleUpdatebyMonthDayInput | number[]
    bySetPos?: NullableIntFieldUpdateOperationsInput | number | null
    count?: NullableIntFieldUpdateOperationsInput | number | null
    until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customRuleString?: NullableStringFieldUpdateOperationsInput | string | null
    chores?: ChoreUpdateManyWithoutRecurrenceRuleNestedInput
    events?: EventUpdateManyWithoutRecurrenceRuleNestedInput
  }

  export type RecurrenceRuleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    frequency?: EnumRecurrenceFrequencyFieldUpdateOperationsInput | $Enums.RecurrenceFrequency
    interval?: IntFieldUpdateOperationsInput | number
    byWeekDay?: RecurrenceRuleUpdatebyWeekDayInput | $Enums.DaysOfWeek[]
    byMonthDay?: RecurrenceRuleUpdatebyMonthDayInput | number[]
    bySetPos?: NullableIntFieldUpdateOperationsInput | number | null
    count?: NullableIntFieldUpdateOperationsInput | number | null
    until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customRuleString?: NullableStringFieldUpdateOperationsInput | string | null
    chores?: ChoreUncheckedUpdateManyWithoutRecurrenceRuleNestedInput
    events?: EventUncheckedUpdateManyWithoutRecurrenceRuleNestedInput
  }

  export type RecurrenceRuleCreateManyInput = {
    id?: string
    frequency: $Enums.RecurrenceFrequency
    interval?: number
    byWeekDay?: RecurrenceRuleCreatebyWeekDayInput | $Enums.DaysOfWeek[]
    byMonthDay?: RecurrenceRuleCreatebyMonthDayInput | number[]
    bySetPos?: number | null
    count?: number | null
    until?: Date | string | null
    customRuleString?: string | null
  }

  export type RecurrenceRuleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    frequency?: EnumRecurrenceFrequencyFieldUpdateOperationsInput | $Enums.RecurrenceFrequency
    interval?: IntFieldUpdateOperationsInput | number
    byWeekDay?: RecurrenceRuleUpdatebyWeekDayInput | $Enums.DaysOfWeek[]
    byMonthDay?: RecurrenceRuleUpdatebyMonthDayInput | number[]
    bySetPos?: NullableIntFieldUpdateOperationsInput | number | null
    count?: NullableIntFieldUpdateOperationsInput | number | null
    until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customRuleString?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RecurrenceRuleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    frequency?: EnumRecurrenceFrequencyFieldUpdateOperationsInput | $Enums.RecurrenceFrequency
    interval?: IntFieldUpdateOperationsInput | number
    byWeekDay?: RecurrenceRuleUpdatebyWeekDayInput | $Enums.DaysOfWeek[]
    byMonthDay?: RecurrenceRuleUpdatebyMonthDayInput | number[]
    bySetPos?: NullableIntFieldUpdateOperationsInput | number | null
    count?: NullableIntFieldUpdateOperationsInput | number | null
    until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customRuleString?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ThreadCreateInput = {
    id?: string
    title?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    household: HouseholdCreateNestedOneWithoutThreadsInput
    author: UserCreateNestedOneWithoutThreadsInput
    messages?: MessageCreateNestedManyWithoutThreadInput
    participants?: HouseholdMemberCreateNestedManyWithoutThreadsInput
  }

  export type ThreadUncheckedCreateInput = {
    id?: string
    householdId: string
    authorId: string
    title?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    messages?: MessageUncheckedCreateNestedManyWithoutThreadInput
    participants?: HouseholdMemberUncheckedCreateNestedManyWithoutThreadsInput
  }

  export type ThreadUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    household?: HouseholdUpdateOneRequiredWithoutThreadsNestedInput
    author?: UserUpdateOneRequiredWithoutThreadsNestedInput
    messages?: MessageUpdateManyWithoutThreadNestedInput
    participants?: HouseholdMemberUpdateManyWithoutThreadsNestedInput
  }

  export type ThreadUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: MessageUncheckedUpdateManyWithoutThreadNestedInput
    participants?: HouseholdMemberUncheckedUpdateManyWithoutThreadsNestedInput
  }

  export type ThreadCreateManyInput = {
    id?: string
    householdId: string
    authorId: string
    title?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ThreadUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ThreadUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MessageCreateInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    thread: ThreadCreateNestedOneWithoutMessagesInput
    author: UserCreateNestedOneWithoutMessagesInput
    attachments?: AttachmentCreateNestedManyWithoutMessageInput
    reactions?: ReactionCreateNestedManyWithoutMessageInput
    mentions?: MentionCreateNestedManyWithoutMessageInput
    reads?: MessageReadCreateNestedManyWithoutMessageInput
  }

  export type MessageUncheckedCreateInput = {
    id?: string
    threadId: string
    authorId: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    attachments?: AttachmentUncheckedCreateNestedManyWithoutMessageInput
    reactions?: ReactionUncheckedCreateNestedManyWithoutMessageInput
    mentions?: MentionUncheckedCreateNestedManyWithoutMessageInput
    reads?: MessageReadUncheckedCreateNestedManyWithoutMessageInput
  }

  export type MessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    thread?: ThreadUpdateOneRequiredWithoutMessagesNestedInput
    author?: UserUpdateOneRequiredWithoutMessagesNestedInput
    attachments?: AttachmentUpdateManyWithoutMessageNestedInput
    reactions?: ReactionUpdateManyWithoutMessageNestedInput
    mentions?: MentionUpdateManyWithoutMessageNestedInput
    reads?: MessageReadUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    threadId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attachments?: AttachmentUncheckedUpdateManyWithoutMessageNestedInput
    reactions?: ReactionUncheckedUpdateManyWithoutMessageNestedInput
    mentions?: MentionUncheckedUpdateManyWithoutMessageNestedInput
    reads?: MessageReadUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type MessageCreateManyInput = {
    id?: string
    threadId: string
    authorId: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type MessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    threadId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReactionCreateInput = {
    id?: string
    emoji: string
    type: $Enums.ReactionType
    createdAt?: Date | string
    message: MessageCreateNestedOneWithoutReactionsInput
    user: UserCreateNestedOneWithoutReactionsInput
  }

  export type ReactionUncheckedCreateInput = {
    id?: string
    messageId: string
    userId: string
    emoji: string
    type: $Enums.ReactionType
    createdAt?: Date | string
  }

  export type ReactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    emoji?: StringFieldUpdateOperationsInput | string
    type?: EnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: MessageUpdateOneRequiredWithoutReactionsNestedInput
    user?: UserUpdateOneRequiredWithoutReactionsNestedInput
  }

  export type ReactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    emoji?: StringFieldUpdateOperationsInput | string
    type?: EnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReactionCreateManyInput = {
    id?: string
    messageId: string
    userId: string
    emoji: string
    type: $Enums.ReactionType
    createdAt?: Date | string
  }

  export type ReactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    emoji?: StringFieldUpdateOperationsInput | string
    type?: EnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    emoji?: StringFieldUpdateOperationsInput | string
    type?: EnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MentionCreateInput = {
    id?: string
    mentionedAt?: Date | string
    message: MessageCreateNestedOneWithoutMentionsInput
    user: UserCreateNestedOneWithoutMentionsInput
  }

  export type MentionUncheckedCreateInput = {
    id?: string
    messageId: string
    userId: string
    mentionedAt?: Date | string
  }

  export type MentionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    mentionedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: MessageUpdateOneRequiredWithoutMentionsNestedInput
    user?: UserUpdateOneRequiredWithoutMentionsNestedInput
  }

  export type MentionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    mentionedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MentionCreateManyInput = {
    id?: string
    messageId: string
    userId: string
    mentionedAt?: Date | string
  }

  export type MentionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    mentionedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MentionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    mentionedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttachmentCreateInput = {
    id?: string
    url: string
    fileType: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    message: MessageCreateNestedOneWithoutAttachmentsInput
  }

  export type AttachmentUncheckedCreateInput = {
    id?: string
    messageId: string
    url: string
    fileType: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type AttachmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    message?: MessageUpdateOneRequiredWithoutAttachmentsNestedInput
  }

  export type AttachmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AttachmentCreateManyInput = {
    id?: string
    messageId: string
    url: string
    fileType: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type AttachmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AttachmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MessageReadCreateInput = {
    id?: string
    readAt?: Date | string
    message: MessageCreateNestedOneWithoutReadsInput
    user: UserCreateNestedOneWithoutMessageReadsInput
  }

  export type MessageReadUncheckedCreateInput = {
    id?: string
    messageId: string
    userId: string
    readAt?: Date | string
  }

  export type MessageReadUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: MessageUpdateOneRequiredWithoutReadsNestedInput
    user?: UserUpdateOneRequiredWithoutMessageReadsNestedInput
  }

  export type MessageReadUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageReadCreateManyInput = {
    id?: string
    messageId: string
    userId: string
    readAt?: Date | string
  }

  export type MessageReadUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageReadUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChoreCreateInput = {
    id?: string
    title: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dueDate?: Date | string | null
    status?: $Enums.ChoreStatus
    priority?: number | null
    deletedAt?: Date | string | null
    household: HouseholdCreateNestedOneWithoutChoresInput
    subtasks?: SubtaskCreateNestedManyWithoutChoreInput
    assignedUsers?: ChoreAssignmentCreateNestedManyWithoutChoreInput
    event?: EventCreateNestedOneWithoutChoreInput
    choreSwapRequests?: ChoreSwapRequestCreateNestedManyWithoutChoreInput
    recurrenceRule?: RecurrenceRuleCreateNestedOneWithoutChoresInput
    history?: ChoreHistoryCreateNestedManyWithoutChoreInput
  }

  export type ChoreUncheckedCreateInput = {
    id?: string
    householdId: string
    title: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dueDate?: Date | string | null
    status?: $Enums.ChoreStatus
    priority?: number | null
    eventId?: string | null
    recurrenceRuleId?: string | null
    deletedAt?: Date | string | null
    subtasks?: SubtaskUncheckedCreateNestedManyWithoutChoreInput
    assignedUsers?: ChoreAssignmentUncheckedCreateNestedManyWithoutChoreInput
    choreSwapRequests?: ChoreSwapRequestUncheckedCreateNestedManyWithoutChoreInput
    history?: ChoreHistoryUncheckedCreateNestedManyWithoutChoreInput
  }

  export type ChoreUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumChoreStatusFieldUpdateOperationsInput | $Enums.ChoreStatus
    priority?: NullableIntFieldUpdateOperationsInput | number | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    household?: HouseholdUpdateOneRequiredWithoutChoresNestedInput
    subtasks?: SubtaskUpdateManyWithoutChoreNestedInput
    assignedUsers?: ChoreAssignmentUpdateManyWithoutChoreNestedInput
    event?: EventUpdateOneWithoutChoreNestedInput
    choreSwapRequests?: ChoreSwapRequestUpdateManyWithoutChoreNestedInput
    recurrenceRule?: RecurrenceRuleUpdateOneWithoutChoresNestedInput
    history?: ChoreHistoryUpdateManyWithoutChoreNestedInput
  }

  export type ChoreUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumChoreStatusFieldUpdateOperationsInput | $Enums.ChoreStatus
    priority?: NullableIntFieldUpdateOperationsInput | number | null
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    recurrenceRuleId?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtasks?: SubtaskUncheckedUpdateManyWithoutChoreNestedInput
    assignedUsers?: ChoreAssignmentUncheckedUpdateManyWithoutChoreNestedInput
    choreSwapRequests?: ChoreSwapRequestUncheckedUpdateManyWithoutChoreNestedInput
    history?: ChoreHistoryUncheckedUpdateManyWithoutChoreNestedInput
  }

  export type ChoreCreateManyInput = {
    id?: string
    householdId: string
    title: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dueDate?: Date | string | null
    status?: $Enums.ChoreStatus
    priority?: number | null
    eventId?: string | null
    recurrenceRuleId?: string | null
    deletedAt?: Date | string | null
  }

  export type ChoreUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumChoreStatusFieldUpdateOperationsInput | $Enums.ChoreStatus
    priority?: NullableIntFieldUpdateOperationsInput | number | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ChoreUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumChoreStatusFieldUpdateOperationsInput | $Enums.ChoreStatus
    priority?: NullableIntFieldUpdateOperationsInput | number | null
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    recurrenceRuleId?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SubtaskCreateInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.SubtaskStatus
    chore: ChoreCreateNestedOneWithoutSubtasksInput
  }

  export type SubtaskUncheckedCreateInput = {
    id?: string
    choreId: string
    title: string
    description?: string | null
    status?: $Enums.SubtaskStatus
  }

  export type SubtaskUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSubtaskStatusFieldUpdateOperationsInput | $Enums.SubtaskStatus
    chore?: ChoreUpdateOneRequiredWithoutSubtasksNestedInput
  }

  export type SubtaskUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    choreId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSubtaskStatusFieldUpdateOperationsInput | $Enums.SubtaskStatus
  }

  export type SubtaskCreateManyInput = {
    id?: string
    choreId: string
    title: string
    description?: string | null
    status?: $Enums.SubtaskStatus
  }

  export type SubtaskUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSubtaskStatusFieldUpdateOperationsInput | $Enums.SubtaskStatus
  }

  export type SubtaskUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    choreId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSubtaskStatusFieldUpdateOperationsInput | $Enums.SubtaskStatus
  }

  export type ChoreAssignmentCreateInput = {
    id?: string
    assignedAt?: Date | string
    completedAt?: Date | string | null
    chore: ChoreCreateNestedOneWithoutAssignedUsersInput
    user: UserCreateNestedOneWithoutAssignedChoresInput
  }

  export type ChoreAssignmentUncheckedCreateInput = {
    id?: string
    choreId: string
    userId: string
    assignedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type ChoreAssignmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chore?: ChoreUpdateOneRequiredWithoutAssignedUsersNestedInput
    user?: UserUpdateOneRequiredWithoutAssignedChoresNestedInput
  }

  export type ChoreAssignmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    choreId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ChoreAssignmentCreateManyInput = {
    id?: string
    choreId: string
    userId: string
    assignedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type ChoreAssignmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ChoreAssignmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    choreId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ChoreSwapRequestCreateInput = {
    id?: string
    status?: $Enums.ChoreSwapRequestStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    requestingUser: UserCreateNestedOneWithoutChoreSwapRequestsInitiatedInput
    targetUser: UserCreateNestedOneWithoutChoreSwapRequestsReceivedInput
    chore: ChoreCreateNestedOneWithoutChoreSwapRequestsInput
  }

  export type ChoreSwapRequestUncheckedCreateInput = {
    id?: string
    choreId: string
    requestingUserId: string
    targetUserId: string
    status?: $Enums.ChoreSwapRequestStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChoreSwapRequestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumChoreSwapRequestStatusFieldUpdateOperationsInput | $Enums.ChoreSwapRequestStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requestingUser?: UserUpdateOneRequiredWithoutChoreSwapRequestsInitiatedNestedInput
    targetUser?: UserUpdateOneRequiredWithoutChoreSwapRequestsReceivedNestedInput
    chore?: ChoreUpdateOneRequiredWithoutChoreSwapRequestsNestedInput
  }

  export type ChoreSwapRequestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    choreId?: StringFieldUpdateOperationsInput | string
    requestingUserId?: StringFieldUpdateOperationsInput | string
    targetUserId?: StringFieldUpdateOperationsInput | string
    status?: EnumChoreSwapRequestStatusFieldUpdateOperationsInput | $Enums.ChoreSwapRequestStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChoreSwapRequestCreateManyInput = {
    id?: string
    choreId: string
    requestingUserId: string
    targetUserId: string
    status?: $Enums.ChoreSwapRequestStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChoreSwapRequestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumChoreSwapRequestStatusFieldUpdateOperationsInput | $Enums.ChoreSwapRequestStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChoreSwapRequestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    choreId?: StringFieldUpdateOperationsInput | string
    requestingUserId?: StringFieldUpdateOperationsInput | string
    targetUserId?: StringFieldUpdateOperationsInput | string
    status?: EnumChoreSwapRequestStatusFieldUpdateOperationsInput | $Enums.ChoreSwapRequestStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChoreTemplateCreateInput = {
    id?: string
    title: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    household: HouseholdCreateNestedOneWithoutChoreTemplatesInput
    subtasks?: SubtaskTemplateCreateNestedManyWithoutChoreTemplateInput
  }

  export type ChoreTemplateUncheckedCreateInput = {
    id?: string
    householdId: string
    title: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subtasks?: SubtaskTemplateUncheckedCreateNestedManyWithoutChoreTemplateInput
  }

  export type ChoreTemplateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    household?: HouseholdUpdateOneRequiredWithoutChoreTemplatesNestedInput
    subtasks?: SubtaskTemplateUpdateManyWithoutChoreTemplateNestedInput
  }

  export type ChoreTemplateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subtasks?: SubtaskTemplateUncheckedUpdateManyWithoutChoreTemplateNestedInput
  }

  export type ChoreTemplateCreateManyInput = {
    id?: string
    householdId: string
    title: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChoreTemplateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChoreTemplateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubtaskTemplateCreateInput = {
    id?: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    choreTemplate: ChoreTemplateCreateNestedOneWithoutSubtasksInput
  }

  export type SubtaskTemplateUncheckedCreateInput = {
    id?: string
    choreTemplateId: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubtaskTemplateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    choreTemplate?: ChoreTemplateUpdateOneRequiredWithoutSubtasksNestedInput
  }

  export type SubtaskTemplateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    choreTemplateId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubtaskTemplateCreateManyInput = {
    id?: string
    choreTemplateId: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubtaskTemplateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubtaskTemplateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    choreTemplateId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChoreHistoryCreateInput = {
    id?: string
    action: $Enums.ChoreAction
    changedAt?: Date | string
    chore: ChoreCreateNestedOneWithoutHistoryInput
    user: UserCreateNestedOneWithoutChoreHistoryInput
  }

  export type ChoreHistoryUncheckedCreateInput = {
    id?: string
    choreId: string
    action: $Enums.ChoreAction
    changedById: string
    changedAt?: Date | string
  }

  export type ChoreHistoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumChoreActionFieldUpdateOperationsInput | $Enums.ChoreAction
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chore?: ChoreUpdateOneRequiredWithoutHistoryNestedInput
    user?: UserUpdateOneRequiredWithoutChoreHistoryNestedInput
  }

  export type ChoreHistoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    choreId?: StringFieldUpdateOperationsInput | string
    action?: EnumChoreActionFieldUpdateOperationsInput | $Enums.ChoreAction
    changedById?: StringFieldUpdateOperationsInput | string
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChoreHistoryCreateManyInput = {
    id?: string
    choreId: string
    action: $Enums.ChoreAction
    changedById: string
    changedAt?: Date | string
  }

  export type ChoreHistoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumChoreActionFieldUpdateOperationsInput | $Enums.ChoreAction
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChoreHistoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    choreId?: StringFieldUpdateOperationsInput | string
    action?: EnumChoreActionFieldUpdateOperationsInput | $Enums.ChoreAction
    changedById?: StringFieldUpdateOperationsInput | string
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseCreateInput = {
    id?: string
    amount: number
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    dueDate?: Date | string | null
    deletedAt?: Date | string | null
    category: $Enums.ExpenseCategory
    household: HouseholdCreateNestedOneWithoutExpensesInput
    paidBy: UserCreateNestedOneWithoutExpensesPaidInput
    splits?: ExpenseSplitCreateNestedManyWithoutExpenseInput
    transactions?: TransactionCreateNestedManyWithoutExpenseInput
    receipts?: ReceiptCreateNestedManyWithoutExpenseInput
    history?: ExpenseHistoryCreateNestedManyWithoutExpenseInput
  }

  export type ExpenseUncheckedCreateInput = {
    id?: string
    householdId: string
    amount: number
    description: string
    paidById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    dueDate?: Date | string | null
    deletedAt?: Date | string | null
    category: $Enums.ExpenseCategory
    splits?: ExpenseSplitUncheckedCreateNestedManyWithoutExpenseInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutExpenseInput
    receipts?: ReceiptUncheckedCreateNestedManyWithoutExpenseInput
    history?: ExpenseHistoryUncheckedCreateNestedManyWithoutExpenseInput
  }

  export type ExpenseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: EnumExpenseCategoryFieldUpdateOperationsInput | $Enums.ExpenseCategory
    household?: HouseholdUpdateOneRequiredWithoutExpensesNestedInput
    paidBy?: UserUpdateOneRequiredWithoutExpensesPaidNestedInput
    splits?: ExpenseSplitUpdateManyWithoutExpenseNestedInput
    transactions?: TransactionUpdateManyWithoutExpenseNestedInput
    receipts?: ReceiptUpdateManyWithoutExpenseNestedInput
    history?: ExpenseHistoryUpdateManyWithoutExpenseNestedInput
  }

  export type ExpenseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    paidById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: EnumExpenseCategoryFieldUpdateOperationsInput | $Enums.ExpenseCategory
    splits?: ExpenseSplitUncheckedUpdateManyWithoutExpenseNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutExpenseNestedInput
    receipts?: ReceiptUncheckedUpdateManyWithoutExpenseNestedInput
    history?: ExpenseHistoryUncheckedUpdateManyWithoutExpenseNestedInput
  }

  export type ExpenseCreateManyInput = {
    id?: string
    householdId: string
    amount: number
    description: string
    paidById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    dueDate?: Date | string | null
    deletedAt?: Date | string | null
    category: $Enums.ExpenseCategory
  }

  export type ExpenseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: EnumExpenseCategoryFieldUpdateOperationsInput | $Enums.ExpenseCategory
  }

  export type ExpenseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    paidById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: EnumExpenseCategoryFieldUpdateOperationsInput | $Enums.ExpenseCategory
  }

  export type ExpenseSplitCreateInput = {
    id?: string
    amount: number
    expense: ExpenseCreateNestedOneWithoutSplitsInput
    user: UserCreateNestedOneWithoutExpenseSplitsInput
  }

  export type ExpenseSplitUncheckedCreateInput = {
    id?: string
    expenseId: string
    userId: string
    amount: number
  }

  export type ExpenseSplitUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    expense?: ExpenseUpdateOneRequiredWithoutSplitsNestedInput
    user?: UserUpdateOneRequiredWithoutExpenseSplitsNestedInput
  }

  export type ExpenseSplitUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    expenseId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
  }

  export type ExpenseSplitCreateManyInput = {
    id?: string
    expenseId: string
    userId: string
    amount: number
  }

  export type ExpenseSplitUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
  }

  export type ExpenseSplitUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    expenseId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
  }

  export type TransactionCreateInput = {
    id?: string
    amount: number
    status?: $Enums.TransactionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    expense: ExpenseCreateNestedOneWithoutTransactionsInput
    fromUser: UserCreateNestedOneWithoutTransactionsFromInput
    toUser: UserCreateNestedOneWithoutTransactionsToInput
  }

  export type TransactionUncheckedCreateInput = {
    id?: string
    expenseId: string
    fromUserId: string
    toUserId: string
    amount: number
    status?: $Enums.TransactionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type TransactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expense?: ExpenseUpdateOneRequiredWithoutTransactionsNestedInput
    fromUser?: UserUpdateOneRequiredWithoutTransactionsFromNestedInput
    toUser?: UserUpdateOneRequiredWithoutTransactionsToNestedInput
  }

  export type TransactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    expenseId?: StringFieldUpdateOperationsInput | string
    fromUserId?: StringFieldUpdateOperationsInput | string
    toUserId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TransactionCreateManyInput = {
    id?: string
    expenseId: string
    fromUserId: string
    toUserId: string
    amount: number
    status?: $Enums.TransactionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type TransactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TransactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    expenseId?: StringFieldUpdateOperationsInput | string
    fromUserId?: StringFieldUpdateOperationsInput | string
    toUserId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReceiptCreateInput = {
    id?: string
    url: string
    fileType: string
    createdAt?: Date | string
    expense: ExpenseCreateNestedOneWithoutReceiptsInput
  }

  export type ReceiptUncheckedCreateInput = {
    id?: string
    expenseId: string
    url: string
    fileType: string
    createdAt?: Date | string
  }

  export type ReceiptUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expense?: ExpenseUpdateOneRequiredWithoutReceiptsNestedInput
  }

  export type ReceiptUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    expenseId?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReceiptCreateManyInput = {
    id?: string
    expenseId: string
    url: string
    fileType: string
    createdAt?: Date | string
  }

  export type ReceiptUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReceiptUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    expenseId?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseHistoryCreateInput = {
    id?: string
    action: $Enums.ExpenseAction
    changedAt?: Date | string
    expense: ExpenseCreateNestedOneWithoutHistoryInput
    user: UserCreateNestedOneWithoutExpenseHistoryInput
  }

  export type ExpenseHistoryUncheckedCreateInput = {
    id?: string
    expenseId: string
    action: $Enums.ExpenseAction
    changedById: string
    changedAt?: Date | string
  }

  export type ExpenseHistoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumExpenseActionFieldUpdateOperationsInput | $Enums.ExpenseAction
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expense?: ExpenseUpdateOneRequiredWithoutHistoryNestedInput
    user?: UserUpdateOneRequiredWithoutExpenseHistoryNestedInput
  }

  export type ExpenseHistoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    expenseId?: StringFieldUpdateOperationsInput | string
    action?: EnumExpenseActionFieldUpdateOperationsInput | $Enums.ExpenseAction
    changedById?: StringFieldUpdateOperationsInput | string
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseHistoryCreateManyInput = {
    id?: string
    expenseId: string
    action: $Enums.ExpenseAction
    changedById: string
    changedAt?: Date | string
  }

  export type ExpenseHistoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumExpenseActionFieldUpdateOperationsInput | $Enums.ExpenseAction
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseHistoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    expenseId?: StringFieldUpdateOperationsInput | string
    action?: EnumExpenseActionFieldUpdateOperationsInput | $Enums.ExpenseAction
    changedById?: StringFieldUpdateOperationsInput | string
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventCreateInput = {
    id?: string
    title: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    choreId?: string | null
    category?: $Enums.EventCategory
    isAllDay?: boolean
    location?: string | null
    isPrivate?: boolean
    status?: $Enums.EventStatus
    deletedAt?: Date | string | null
    reminders?: EventReminderCreateNestedManyWithoutEventInput
    household: HouseholdCreateNestedOneWithoutEventsInput
    createdBy: UserCreateNestedOneWithoutEventsCreatedInput
    chore?: ChoreCreateNestedOneWithoutEventInput
    recurrenceRule?: RecurrenceRuleCreateNestedOneWithoutEventsInput
    history?: CalendarEventHistoryCreateNestedManyWithoutEventInput
  }

  export type EventUncheckedCreateInput = {
    id?: string
    householdId: string
    title: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    choreId?: string | null
    recurrenceRuleId?: string | null
    category?: $Enums.EventCategory
    isAllDay?: boolean
    location?: string | null
    isPrivate?: boolean
    status?: $Enums.EventStatus
    deletedAt?: Date | string | null
    reminders?: EventReminderUncheckedCreateNestedManyWithoutEventInput
    chore?: ChoreUncheckedCreateNestedOneWithoutEventInput
    history?: CalendarEventHistoryUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    choreId?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumEventCategoryFieldUpdateOperationsInput | $Enums.EventCategory
    isAllDay?: BoolFieldUpdateOperationsInput | boolean
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumEventStatusFieldUpdateOperationsInput | $Enums.EventStatus
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminders?: EventReminderUpdateManyWithoutEventNestedInput
    household?: HouseholdUpdateOneRequiredWithoutEventsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutEventsCreatedNestedInput
    chore?: ChoreUpdateOneWithoutEventNestedInput
    recurrenceRule?: RecurrenceRuleUpdateOneWithoutEventsNestedInput
    history?: CalendarEventHistoryUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    choreId?: NullableStringFieldUpdateOperationsInput | string | null
    recurrenceRuleId?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumEventCategoryFieldUpdateOperationsInput | $Enums.EventCategory
    isAllDay?: BoolFieldUpdateOperationsInput | boolean
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumEventStatusFieldUpdateOperationsInput | $Enums.EventStatus
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminders?: EventReminderUncheckedUpdateManyWithoutEventNestedInput
    chore?: ChoreUncheckedUpdateOneWithoutEventNestedInput
    history?: CalendarEventHistoryUncheckedUpdateManyWithoutEventNestedInput
  }

  export type EventCreateManyInput = {
    id?: string
    householdId: string
    title: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    choreId?: string | null
    recurrenceRuleId?: string | null
    category?: $Enums.EventCategory
    isAllDay?: boolean
    location?: string | null
    isPrivate?: boolean
    status?: $Enums.EventStatus
    deletedAt?: Date | string | null
  }

  export type EventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    choreId?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumEventCategoryFieldUpdateOperationsInput | $Enums.EventCategory
    isAllDay?: BoolFieldUpdateOperationsInput | boolean
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumEventStatusFieldUpdateOperationsInput | $Enums.EventStatus
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    choreId?: NullableStringFieldUpdateOperationsInput | string | null
    recurrenceRuleId?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumEventCategoryFieldUpdateOperationsInput | $Enums.EventCategory
    isAllDay?: BoolFieldUpdateOperationsInput | boolean
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumEventStatusFieldUpdateOperationsInput | $Enums.EventStatus
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EventReminderCreateInput = {
    id?: string
    time: Date | string
    type: $Enums.EventReminderType
    event: EventCreateNestedOneWithoutRemindersInput
  }

  export type EventReminderUncheckedCreateInput = {
    id?: string
    eventId: string
    time: Date | string
    type: $Enums.EventReminderType
  }

  export type EventReminderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumEventReminderTypeFieldUpdateOperationsInput | $Enums.EventReminderType
    event?: EventUpdateOneRequiredWithoutRemindersNestedInput
  }

  export type EventReminderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumEventReminderTypeFieldUpdateOperationsInput | $Enums.EventReminderType
  }

  export type EventReminderCreateManyInput = {
    id?: string
    eventId: string
    time: Date | string
    type: $Enums.EventReminderType
  }

  export type EventReminderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumEventReminderTypeFieldUpdateOperationsInput | $Enums.EventReminderType
  }

  export type EventReminderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumEventReminderTypeFieldUpdateOperationsInput | $Enums.EventReminderType
  }

  export type CalendarEventHistoryCreateInput = {
    id?: string
    action: $Enums.CalendarEventAction
    changedAt?: Date | string
    event: EventCreateNestedOneWithoutHistoryInput
    user: UserCreateNestedOneWithoutCalendarEventHistoryInput
  }

  export type CalendarEventHistoryUncheckedCreateInput = {
    id?: string
    eventId: string
    action: $Enums.CalendarEventAction
    changedById: string
    changedAt?: Date | string
  }

  export type CalendarEventHistoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumCalendarEventActionFieldUpdateOperationsInput | $Enums.CalendarEventAction
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    event?: EventUpdateOneRequiredWithoutHistoryNestedInput
    user?: UserUpdateOneRequiredWithoutCalendarEventHistoryNestedInput
  }

  export type CalendarEventHistoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    action?: EnumCalendarEventActionFieldUpdateOperationsInput | $Enums.CalendarEventAction
    changedById?: StringFieldUpdateOperationsInput | string
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalendarEventHistoryCreateManyInput = {
    id?: string
    eventId: string
    action: $Enums.CalendarEventAction
    changedById: string
    changedAt?: Date | string
  }

  export type CalendarEventHistoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumCalendarEventActionFieldUpdateOperationsInput | $Enums.CalendarEventAction
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalendarEventHistoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    action?: EnumCalendarEventActionFieldUpdateOperationsInput | $Enums.CalendarEventAction
    changedById?: StringFieldUpdateOperationsInput | string
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    id?: string
    type: $Enums.NotificationType
    message: string
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    userId: string
    type: $Enums.NotificationType
    message: string
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: string
    userId: string
    type: $Enums.NotificationType
    message: string
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationSettingsCreateInput = {
    id?: string
    messageNotif?: boolean
    mentionsNotif?: boolean
    reactionsNotif?: boolean
    choreNotif?: boolean
    financeNotif?: boolean
    calendarNotif?: boolean
    remindersNotif?: boolean
    user?: UserCreateNestedOneWithoutNotificationSettingsInput
    household?: HouseholdCreateNestedOneWithoutNotificationSettingsInput
  }

  export type NotificationSettingsUncheckedCreateInput = {
    id?: string
    userId?: string | null
    householdId?: string | null
    messageNotif?: boolean
    mentionsNotif?: boolean
    reactionsNotif?: boolean
    choreNotif?: boolean
    financeNotif?: boolean
    calendarNotif?: boolean
    remindersNotif?: boolean
  }

  export type NotificationSettingsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageNotif?: BoolFieldUpdateOperationsInput | boolean
    mentionsNotif?: BoolFieldUpdateOperationsInput | boolean
    reactionsNotif?: BoolFieldUpdateOperationsInput | boolean
    choreNotif?: BoolFieldUpdateOperationsInput | boolean
    financeNotif?: BoolFieldUpdateOperationsInput | boolean
    calendarNotif?: BoolFieldUpdateOperationsInput | boolean
    remindersNotif?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneWithoutNotificationSettingsNestedInput
    household?: HouseholdUpdateOneWithoutNotificationSettingsNestedInput
  }

  export type NotificationSettingsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    householdId?: NullableStringFieldUpdateOperationsInput | string | null
    messageNotif?: BoolFieldUpdateOperationsInput | boolean
    mentionsNotif?: BoolFieldUpdateOperationsInput | boolean
    reactionsNotif?: BoolFieldUpdateOperationsInput | boolean
    choreNotif?: BoolFieldUpdateOperationsInput | boolean
    financeNotif?: BoolFieldUpdateOperationsInput | boolean
    calendarNotif?: BoolFieldUpdateOperationsInput | boolean
    remindersNotif?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NotificationSettingsCreateManyInput = {
    id?: string
    userId?: string | null
    householdId?: string | null
    messageNotif?: boolean
    mentionsNotif?: boolean
    reactionsNotif?: boolean
    choreNotif?: boolean
    financeNotif?: boolean
    calendarNotif?: boolean
    remindersNotif?: boolean
  }

  export type NotificationSettingsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageNotif?: BoolFieldUpdateOperationsInput | boolean
    mentionsNotif?: BoolFieldUpdateOperationsInput | boolean
    reactionsNotif?: BoolFieldUpdateOperationsInput | boolean
    choreNotif?: BoolFieldUpdateOperationsInput | boolean
    financeNotif?: BoolFieldUpdateOperationsInput | boolean
    calendarNotif?: BoolFieldUpdateOperationsInput | boolean
    remindersNotif?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NotificationSettingsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    householdId?: NullableStringFieldUpdateOperationsInput | string | null
    messageNotif?: BoolFieldUpdateOperationsInput | boolean
    mentionsNotif?: BoolFieldUpdateOperationsInput | boolean
    reactionsNotif?: BoolFieldUpdateOperationsInput | boolean
    choreNotif?: BoolFieldUpdateOperationsInput | boolean
    financeNotif?: BoolFieldUpdateOperationsInput | boolean
    calendarNotif?: BoolFieldUpdateOperationsInput | boolean
    remindersNotif?: BoolFieldUpdateOperationsInput | boolean
  }

  export type OAuthIntegrationCreateInput = {
    id?: string
    provider: $Enums.Provider
    accessToken: string
    refreshToken?: string | null
    expiresAt?: Date | string | null
    user: UserCreateNestedOneWithoutOauthIntegrationsInput
  }

  export type OAuthIntegrationUncheckedCreateInput = {
    id?: string
    userId: string
    provider: $Enums.Provider
    accessToken: string
    refreshToken?: string | null
    expiresAt?: Date | string | null
  }

  export type OAuthIntegrationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumProviderFieldUpdateOperationsInput | $Enums.Provider
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutOauthIntegrationsNestedInput
  }

  export type OAuthIntegrationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    provider?: EnumProviderFieldUpdateOperationsInput | $Enums.Provider
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OAuthIntegrationCreateManyInput = {
    id?: string
    userId: string
    provider: $Enums.Provider
    accessToken: string
    refreshToken?: string | null
    expiresAt?: Date | string | null
  }

  export type OAuthIntegrationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumProviderFieldUpdateOperationsInput | $Enums.Provider
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OAuthIntegrationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    provider?: EnumProviderFieldUpdateOperationsInput | $Enums.Provider
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type HouseholdMemberListRelationFilter = {
    every?: HouseholdMemberWhereInput
    some?: HouseholdMemberWhereInput
    none?: HouseholdMemberWhereInput
  }

  export type MessageListRelationFilter = {
    every?: MessageWhereInput
    some?: MessageWhereInput
    none?: MessageWhereInput
  }

  export type ThreadListRelationFilter = {
    every?: ThreadWhereInput
    some?: ThreadWhereInput
    none?: ThreadWhereInput
  }

  export type ChoreAssignmentListRelationFilter = {
    every?: ChoreAssignmentWhereInput
    some?: ChoreAssignmentWhereInput
    none?: ChoreAssignmentWhereInput
  }

  export type ExpenseListRelationFilter = {
    every?: ExpenseWhereInput
    some?: ExpenseWhereInput
    none?: ExpenseWhereInput
  }

  export type ExpenseSplitListRelationFilter = {
    every?: ExpenseSplitWhereInput
    some?: ExpenseSplitWhereInput
    none?: ExpenseSplitWhereInput
  }

  export type TransactionListRelationFilter = {
    every?: TransactionWhereInput
    some?: TransactionWhereInput
    none?: TransactionWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type OAuthIntegrationListRelationFilter = {
    every?: OAuthIntegrationWhereInput
    some?: OAuthIntegrationWhereInput
    none?: OAuthIntegrationWhereInput
  }

  export type EventListRelationFilter = {
    every?: EventWhereInput
    some?: EventWhereInput
    none?: EventWhereInput
  }

  export type ChoreSwapRequestListRelationFilter = {
    every?: ChoreSwapRequestWhereInput
    some?: ChoreSwapRequestWhereInput
    none?: ChoreSwapRequestWhereInput
  }

  export type ReactionListRelationFilter = {
    every?: ReactionWhereInput
    some?: ReactionWhereInput
    none?: ReactionWhereInput
  }

  export type MentionListRelationFilter = {
    every?: MentionWhereInput
    some?: MentionWhereInput
    none?: MentionWhereInput
  }

  export type ChoreHistoryListRelationFilter = {
    every?: ChoreHistoryWhereInput
    some?: ChoreHistoryWhereInput
    none?: ChoreHistoryWhereInput
  }

  export type NotificationSettingsListRelationFilter = {
    every?: NotificationSettingsWhereInput
    some?: NotificationSettingsWhereInput
    none?: NotificationSettingsWhereInput
  }

  export type CalendarEventHistoryListRelationFilter = {
    every?: CalendarEventHistoryWhereInput
    some?: CalendarEventHistoryWhereInput
    none?: CalendarEventHistoryWhereInput
  }

  export type ExpenseHistoryListRelationFilter = {
    every?: ExpenseHistoryWhereInput
    some?: ExpenseHistoryWhereInput
    none?: ExpenseHistoryWhereInput
  }

  export type MessageReadListRelationFilter = {
    every?: MessageReadWhereInput
    some?: MessageReadWhereInput
    none?: MessageReadWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type HouseholdMemberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ThreadOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChoreAssignmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExpenseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExpenseSplitOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OAuthIntegrationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChoreSwapRequestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MentionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChoreHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationSettingsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CalendarEventHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExpenseHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessageReadOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    name?: SortOrder
    profileImageURL?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deviceTokens?: SortOrder
    deletedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    name?: SortOrder
    profileImageURL?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    name?: SortOrder
    profileImageURL?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type ChoreListRelationFilter = {
    every?: ChoreWhereInput
    some?: ChoreWhereInput
    none?: ChoreWhereInput
  }

  export type ChoreTemplateListRelationFilter = {
    every?: ChoreTemplateWhereInput
    some?: ChoreTemplateWhereInput
    none?: ChoreTemplateWhereInput
  }

  export type ChoreOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChoreTemplateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HouseholdCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    currency?: SortOrder
    icon?: SortOrder
    timezone?: SortOrder
    language?: SortOrder
    deletedAt?: SortOrder
  }

  export type HouseholdMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    currency?: SortOrder
    icon?: SortOrder
    timezone?: SortOrder
    language?: SortOrder
    deletedAt?: SortOrder
  }

  export type HouseholdMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    currency?: SortOrder
    icon?: SortOrder
    timezone?: SortOrder
    language?: SortOrder
    deletedAt?: SortOrder
  }

  export type EnumHouseholdRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.HouseholdRole | EnumHouseholdRoleFieldRefInput<$PrismaModel>
    in?: $Enums.HouseholdRole[] | ListEnumHouseholdRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.HouseholdRole[] | ListEnumHouseholdRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumHouseholdRoleFilter<$PrismaModel> | $Enums.HouseholdRole
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type HouseholdRelationFilter = {
    is?: HouseholdWhereInput
    isNot?: HouseholdWhereInput
  }

  export type HouseholdMemberUserIdHouseholdIdCompoundUniqueInput = {
    userId: string
    householdId: string
  }

  export type HouseholdMemberCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    householdId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
    leftAt?: SortOrder
    isInvited?: SortOrder
    isAccepted?: SortOrder
    isRejected?: SortOrder
    isSelected?: SortOrder
    lastAssignedChoreAt?: SortOrder
  }

  export type HouseholdMemberMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    householdId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
    leftAt?: SortOrder
    isInvited?: SortOrder
    isAccepted?: SortOrder
    isRejected?: SortOrder
    isSelected?: SortOrder
    lastAssignedChoreAt?: SortOrder
  }

  export type HouseholdMemberMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    householdId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
    leftAt?: SortOrder
    isInvited?: SortOrder
    isAccepted?: SortOrder
    isRejected?: SortOrder
    isSelected?: SortOrder
    lastAssignedChoreAt?: SortOrder
  }

  export type EnumHouseholdRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.HouseholdRole | EnumHouseholdRoleFieldRefInput<$PrismaModel>
    in?: $Enums.HouseholdRole[] | ListEnumHouseholdRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.HouseholdRole[] | ListEnumHouseholdRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumHouseholdRoleWithAggregatesFilter<$PrismaModel> | $Enums.HouseholdRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumHouseholdRoleFilter<$PrismaModel>
    _max?: NestedEnumHouseholdRoleFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumRecurrenceFrequencyFilter<$PrismaModel = never> = {
    equals?: $Enums.RecurrenceFrequency | EnumRecurrenceFrequencyFieldRefInput<$PrismaModel>
    in?: $Enums.RecurrenceFrequency[] | ListEnumRecurrenceFrequencyFieldRefInput<$PrismaModel>
    notIn?: $Enums.RecurrenceFrequency[] | ListEnumRecurrenceFrequencyFieldRefInput<$PrismaModel>
    not?: NestedEnumRecurrenceFrequencyFilter<$PrismaModel> | $Enums.RecurrenceFrequency
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type EnumDaysOfWeekNullableListFilter<$PrismaModel = never> = {
    equals?: $Enums.DaysOfWeek[] | ListEnumDaysOfWeekFieldRefInput<$PrismaModel> | null
    has?: $Enums.DaysOfWeek | EnumDaysOfWeekFieldRefInput<$PrismaModel> | null
    hasEvery?: $Enums.DaysOfWeek[] | ListEnumDaysOfWeekFieldRefInput<$PrismaModel>
    hasSome?: $Enums.DaysOfWeek[] | ListEnumDaysOfWeekFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type IntNullableListFilter<$PrismaModel = never> = {
    equals?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    has?: number | IntFieldRefInput<$PrismaModel> | null
    hasEvery?: number[] | ListIntFieldRefInput<$PrismaModel>
    hasSome?: number[] | ListIntFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type RecurrenceRuleCountOrderByAggregateInput = {
    id?: SortOrder
    frequency?: SortOrder
    interval?: SortOrder
    byWeekDay?: SortOrder
    byMonthDay?: SortOrder
    bySetPos?: SortOrder
    count?: SortOrder
    until?: SortOrder
    customRuleString?: SortOrder
  }

  export type RecurrenceRuleAvgOrderByAggregateInput = {
    interval?: SortOrder
    byMonthDay?: SortOrder
    bySetPos?: SortOrder
    count?: SortOrder
  }

  export type RecurrenceRuleMaxOrderByAggregateInput = {
    id?: SortOrder
    frequency?: SortOrder
    interval?: SortOrder
    bySetPos?: SortOrder
    count?: SortOrder
    until?: SortOrder
    customRuleString?: SortOrder
  }

  export type RecurrenceRuleMinOrderByAggregateInput = {
    id?: SortOrder
    frequency?: SortOrder
    interval?: SortOrder
    bySetPos?: SortOrder
    count?: SortOrder
    until?: SortOrder
    customRuleString?: SortOrder
  }

  export type RecurrenceRuleSumOrderByAggregateInput = {
    interval?: SortOrder
    byMonthDay?: SortOrder
    bySetPos?: SortOrder
    count?: SortOrder
  }

  export type EnumRecurrenceFrequencyWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RecurrenceFrequency | EnumRecurrenceFrequencyFieldRefInput<$PrismaModel>
    in?: $Enums.RecurrenceFrequency[] | ListEnumRecurrenceFrequencyFieldRefInput<$PrismaModel>
    notIn?: $Enums.RecurrenceFrequency[] | ListEnumRecurrenceFrequencyFieldRefInput<$PrismaModel>
    not?: NestedEnumRecurrenceFrequencyWithAggregatesFilter<$PrismaModel> | $Enums.RecurrenceFrequency
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRecurrenceFrequencyFilter<$PrismaModel>
    _max?: NestedEnumRecurrenceFrequencyFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type ThreadCountOrderByAggregateInput = {
    id?: SortOrder
    householdId?: SortOrder
    authorId?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ThreadMaxOrderByAggregateInput = {
    id?: SortOrder
    householdId?: SortOrder
    authorId?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ThreadMinOrderByAggregateInput = {
    id?: SortOrder
    householdId?: SortOrder
    authorId?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ThreadRelationFilter = {
    is?: ThreadWhereInput
    isNot?: ThreadWhereInput
  }

  export type AttachmentListRelationFilter = {
    every?: AttachmentWhereInput
    some?: AttachmentWhereInput
    none?: AttachmentWhereInput
  }

  export type AttachmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessageCountOrderByAggregateInput = {
    id?: SortOrder
    threadId?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type MessageMaxOrderByAggregateInput = {
    id?: SortOrder
    threadId?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type MessageMinOrderByAggregateInput = {
    id?: SortOrder
    threadId?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type EnumReactionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ReactionType | EnumReactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReactionType[] | ListEnumReactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReactionType[] | ListEnumReactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReactionTypeFilter<$PrismaModel> | $Enums.ReactionType
  }

  export type MessageRelationFilter = {
    is?: MessageWhereInput
    isNot?: MessageWhereInput
  }

  export type ReactionCountOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    userId?: SortOrder
    emoji?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
  }

  export type ReactionMaxOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    userId?: SortOrder
    emoji?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
  }

  export type ReactionMinOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    userId?: SortOrder
    emoji?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumReactionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReactionType | EnumReactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReactionType[] | ListEnumReactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReactionType[] | ListEnumReactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReactionTypeWithAggregatesFilter<$PrismaModel> | $Enums.ReactionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReactionTypeFilter<$PrismaModel>
    _max?: NestedEnumReactionTypeFilter<$PrismaModel>
  }

  export type MentionCountOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    userId?: SortOrder
    mentionedAt?: SortOrder
  }

  export type MentionMaxOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    userId?: SortOrder
    mentionedAt?: SortOrder
  }

  export type MentionMinOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    userId?: SortOrder
    mentionedAt?: SortOrder
  }

  export type AttachmentCountOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    url?: SortOrder
    fileType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type AttachmentMaxOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    url?: SortOrder
    fileType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type AttachmentMinOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    url?: SortOrder
    fileType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type MessageReadCountOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    userId?: SortOrder
    readAt?: SortOrder
  }

  export type MessageReadMaxOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    userId?: SortOrder
    readAt?: SortOrder
  }

  export type MessageReadMinOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    userId?: SortOrder
    readAt?: SortOrder
  }

  export type EnumChoreStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ChoreStatus | EnumChoreStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ChoreStatus[] | ListEnumChoreStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChoreStatus[] | ListEnumChoreStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumChoreStatusFilter<$PrismaModel> | $Enums.ChoreStatus
  }

  export type SubtaskListRelationFilter = {
    every?: SubtaskWhereInput
    some?: SubtaskWhereInput
    none?: SubtaskWhereInput
  }

  export type EventNullableRelationFilter = {
    is?: EventWhereInput | null
    isNot?: EventWhereInput | null
  }

  export type RecurrenceRuleNullableRelationFilter = {
    is?: RecurrenceRuleWhereInput | null
    isNot?: RecurrenceRuleWhereInput | null
  }

  export type SubtaskOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChoreCountOrderByAggregateInput = {
    id?: SortOrder
    householdId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    eventId?: SortOrder
    recurrenceRuleId?: SortOrder
    deletedAt?: SortOrder
  }

  export type ChoreAvgOrderByAggregateInput = {
    priority?: SortOrder
  }

  export type ChoreMaxOrderByAggregateInput = {
    id?: SortOrder
    householdId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    eventId?: SortOrder
    recurrenceRuleId?: SortOrder
    deletedAt?: SortOrder
  }

  export type ChoreMinOrderByAggregateInput = {
    id?: SortOrder
    householdId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    eventId?: SortOrder
    recurrenceRuleId?: SortOrder
    deletedAt?: SortOrder
  }

  export type ChoreSumOrderByAggregateInput = {
    priority?: SortOrder
  }

  export type EnumChoreStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ChoreStatus | EnumChoreStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ChoreStatus[] | ListEnumChoreStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChoreStatus[] | ListEnumChoreStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumChoreStatusWithAggregatesFilter<$PrismaModel> | $Enums.ChoreStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumChoreStatusFilter<$PrismaModel>
    _max?: NestedEnumChoreStatusFilter<$PrismaModel>
  }

  export type EnumSubtaskStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SubtaskStatus | EnumSubtaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubtaskStatus[] | ListEnumSubtaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubtaskStatus[] | ListEnumSubtaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubtaskStatusFilter<$PrismaModel> | $Enums.SubtaskStatus
  }

  export type ChoreRelationFilter = {
    is?: ChoreWhereInput
    isNot?: ChoreWhereInput
  }

  export type SubtaskCountOrderByAggregateInput = {
    id?: SortOrder
    choreId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
  }

  export type SubtaskMaxOrderByAggregateInput = {
    id?: SortOrder
    choreId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
  }

  export type SubtaskMinOrderByAggregateInput = {
    id?: SortOrder
    choreId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
  }

  export type EnumSubtaskStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubtaskStatus | EnumSubtaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubtaskStatus[] | ListEnumSubtaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubtaskStatus[] | ListEnumSubtaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubtaskStatusWithAggregatesFilter<$PrismaModel> | $Enums.SubtaskStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubtaskStatusFilter<$PrismaModel>
    _max?: NestedEnumSubtaskStatusFilter<$PrismaModel>
  }

  export type ChoreAssignmentChoreIdUserIdCompoundUniqueInput = {
    choreId: string
    userId: string
  }

  export type ChoreAssignmentCountOrderByAggregateInput = {
    id?: SortOrder
    choreId?: SortOrder
    userId?: SortOrder
    assignedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type ChoreAssignmentMaxOrderByAggregateInput = {
    id?: SortOrder
    choreId?: SortOrder
    userId?: SortOrder
    assignedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type ChoreAssignmentMinOrderByAggregateInput = {
    id?: SortOrder
    choreId?: SortOrder
    userId?: SortOrder
    assignedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type EnumChoreSwapRequestStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ChoreSwapRequestStatus | EnumChoreSwapRequestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ChoreSwapRequestStatus[] | ListEnumChoreSwapRequestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChoreSwapRequestStatus[] | ListEnumChoreSwapRequestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumChoreSwapRequestStatusFilter<$PrismaModel> | $Enums.ChoreSwapRequestStatus
  }

  export type ChoreSwapRequestCountOrderByAggregateInput = {
    id?: SortOrder
    choreId?: SortOrder
    requestingUserId?: SortOrder
    targetUserId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChoreSwapRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    choreId?: SortOrder
    requestingUserId?: SortOrder
    targetUserId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChoreSwapRequestMinOrderByAggregateInput = {
    id?: SortOrder
    choreId?: SortOrder
    requestingUserId?: SortOrder
    targetUserId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumChoreSwapRequestStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ChoreSwapRequestStatus | EnumChoreSwapRequestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ChoreSwapRequestStatus[] | ListEnumChoreSwapRequestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChoreSwapRequestStatus[] | ListEnumChoreSwapRequestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumChoreSwapRequestStatusWithAggregatesFilter<$PrismaModel> | $Enums.ChoreSwapRequestStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumChoreSwapRequestStatusFilter<$PrismaModel>
    _max?: NestedEnumChoreSwapRequestStatusFilter<$PrismaModel>
  }

  export type SubtaskTemplateListRelationFilter = {
    every?: SubtaskTemplateWhereInput
    some?: SubtaskTemplateWhereInput
    none?: SubtaskTemplateWhereInput
  }

  export type SubtaskTemplateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChoreTemplateCountOrderByAggregateInput = {
    id?: SortOrder
    householdId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChoreTemplateMaxOrderByAggregateInput = {
    id?: SortOrder
    householdId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChoreTemplateMinOrderByAggregateInput = {
    id?: SortOrder
    householdId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChoreTemplateRelationFilter = {
    is?: ChoreTemplateWhereInput
    isNot?: ChoreTemplateWhereInput
  }

  export type SubtaskTemplateCountOrderByAggregateInput = {
    id?: SortOrder
    choreTemplateId?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubtaskTemplateMaxOrderByAggregateInput = {
    id?: SortOrder
    choreTemplateId?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubtaskTemplateMinOrderByAggregateInput = {
    id?: SortOrder
    choreTemplateId?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumChoreActionFilter<$PrismaModel = never> = {
    equals?: $Enums.ChoreAction | EnumChoreActionFieldRefInput<$PrismaModel>
    in?: $Enums.ChoreAction[] | ListEnumChoreActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChoreAction[] | ListEnumChoreActionFieldRefInput<$PrismaModel>
    not?: NestedEnumChoreActionFilter<$PrismaModel> | $Enums.ChoreAction
  }

  export type ChoreHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    choreId?: SortOrder
    action?: SortOrder
    changedById?: SortOrder
    changedAt?: SortOrder
  }

  export type ChoreHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    choreId?: SortOrder
    action?: SortOrder
    changedById?: SortOrder
    changedAt?: SortOrder
  }

  export type ChoreHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    choreId?: SortOrder
    action?: SortOrder
    changedById?: SortOrder
    changedAt?: SortOrder
  }

  export type EnumChoreActionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ChoreAction | EnumChoreActionFieldRefInput<$PrismaModel>
    in?: $Enums.ChoreAction[] | ListEnumChoreActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChoreAction[] | ListEnumChoreActionFieldRefInput<$PrismaModel>
    not?: NestedEnumChoreActionWithAggregatesFilter<$PrismaModel> | $Enums.ChoreAction
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumChoreActionFilter<$PrismaModel>
    _max?: NestedEnumChoreActionFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type EnumExpenseCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.ExpenseCategory | EnumExpenseCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ExpenseCategory[] | ListEnumExpenseCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExpenseCategory[] | ListEnumExpenseCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumExpenseCategoryFilter<$PrismaModel> | $Enums.ExpenseCategory
  }

  export type ReceiptListRelationFilter = {
    every?: ReceiptWhereInput
    some?: ReceiptWhereInput
    none?: ReceiptWhereInput
  }

  export type ReceiptOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExpenseCountOrderByAggregateInput = {
    id?: SortOrder
    householdId?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    paidById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    dueDate?: SortOrder
    deletedAt?: SortOrder
    category?: SortOrder
  }

  export type ExpenseAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type ExpenseMaxOrderByAggregateInput = {
    id?: SortOrder
    householdId?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    paidById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    dueDate?: SortOrder
    deletedAt?: SortOrder
    category?: SortOrder
  }

  export type ExpenseMinOrderByAggregateInput = {
    id?: SortOrder
    householdId?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    paidById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    dueDate?: SortOrder
    deletedAt?: SortOrder
    category?: SortOrder
  }

  export type ExpenseSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type EnumExpenseCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ExpenseCategory | EnumExpenseCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ExpenseCategory[] | ListEnumExpenseCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExpenseCategory[] | ListEnumExpenseCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumExpenseCategoryWithAggregatesFilter<$PrismaModel> | $Enums.ExpenseCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumExpenseCategoryFilter<$PrismaModel>
    _max?: NestedEnumExpenseCategoryFilter<$PrismaModel>
  }

  export type ExpenseRelationFilter = {
    is?: ExpenseWhereInput
    isNot?: ExpenseWhereInput
  }

  export type ExpenseSplitExpenseIdUserIdCompoundUniqueInput = {
    expenseId: string
    userId: string
  }

  export type ExpenseSplitCountOrderByAggregateInput = {
    id?: SortOrder
    expenseId?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
  }

  export type ExpenseSplitAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type ExpenseSplitMaxOrderByAggregateInput = {
    id?: SortOrder
    expenseId?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
  }

  export type ExpenseSplitMinOrderByAggregateInput = {
    id?: SortOrder
    expenseId?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
  }

  export type ExpenseSplitSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumTransactionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionStatus | EnumTransactionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionStatusFilter<$PrismaModel> | $Enums.TransactionStatus
  }

  export type TransactionCountOrderByAggregateInput = {
    id?: SortOrder
    expenseId?: SortOrder
    fromUserId?: SortOrder
    toUserId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type TransactionAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type TransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    expenseId?: SortOrder
    fromUserId?: SortOrder
    toUserId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type TransactionMinOrderByAggregateInput = {
    id?: SortOrder
    expenseId?: SortOrder
    fromUserId?: SortOrder
    toUserId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type TransactionSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumTransactionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionStatus | EnumTransactionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionStatusWithAggregatesFilter<$PrismaModel> | $Enums.TransactionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionStatusFilter<$PrismaModel>
    _max?: NestedEnumTransactionStatusFilter<$PrismaModel>
  }

  export type ReceiptCountOrderByAggregateInput = {
    id?: SortOrder
    expenseId?: SortOrder
    url?: SortOrder
    fileType?: SortOrder
    createdAt?: SortOrder
  }

  export type ReceiptMaxOrderByAggregateInput = {
    id?: SortOrder
    expenseId?: SortOrder
    url?: SortOrder
    fileType?: SortOrder
    createdAt?: SortOrder
  }

  export type ReceiptMinOrderByAggregateInput = {
    id?: SortOrder
    expenseId?: SortOrder
    url?: SortOrder
    fileType?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumExpenseActionFilter<$PrismaModel = never> = {
    equals?: $Enums.ExpenseAction | EnumExpenseActionFieldRefInput<$PrismaModel>
    in?: $Enums.ExpenseAction[] | ListEnumExpenseActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExpenseAction[] | ListEnumExpenseActionFieldRefInput<$PrismaModel>
    not?: NestedEnumExpenseActionFilter<$PrismaModel> | $Enums.ExpenseAction
  }

  export type ExpenseHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    expenseId?: SortOrder
    action?: SortOrder
    changedById?: SortOrder
    changedAt?: SortOrder
  }

  export type ExpenseHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    expenseId?: SortOrder
    action?: SortOrder
    changedById?: SortOrder
    changedAt?: SortOrder
  }

  export type ExpenseHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    expenseId?: SortOrder
    action?: SortOrder
    changedById?: SortOrder
    changedAt?: SortOrder
  }

  export type EnumExpenseActionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ExpenseAction | EnumExpenseActionFieldRefInput<$PrismaModel>
    in?: $Enums.ExpenseAction[] | ListEnumExpenseActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExpenseAction[] | ListEnumExpenseActionFieldRefInput<$PrismaModel>
    not?: NestedEnumExpenseActionWithAggregatesFilter<$PrismaModel> | $Enums.ExpenseAction
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumExpenseActionFilter<$PrismaModel>
    _max?: NestedEnumExpenseActionFilter<$PrismaModel>
  }

  export type EnumEventCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.EventCategory | EnumEventCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.EventCategory[] | ListEnumEventCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.EventCategory[] | ListEnumEventCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumEventCategoryFilter<$PrismaModel> | $Enums.EventCategory
  }

  export type EnumEventStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.EventStatus | EnumEventStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EventStatus[] | ListEnumEventStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EventStatus[] | ListEnumEventStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEventStatusFilter<$PrismaModel> | $Enums.EventStatus
  }

  export type EventReminderListRelationFilter = {
    every?: EventReminderWhereInput
    some?: EventReminderWhereInput
    none?: EventReminderWhereInput
  }

  export type ChoreNullableRelationFilter = {
    is?: ChoreWhereInput | null
    isNot?: ChoreWhereInput | null
  }

  export type EventReminderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EventCountOrderByAggregateInput = {
    id?: SortOrder
    householdId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    choreId?: SortOrder
    recurrenceRuleId?: SortOrder
    category?: SortOrder
    isAllDay?: SortOrder
    location?: SortOrder
    isPrivate?: SortOrder
    status?: SortOrder
    deletedAt?: SortOrder
  }

  export type EventMaxOrderByAggregateInput = {
    id?: SortOrder
    householdId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    choreId?: SortOrder
    recurrenceRuleId?: SortOrder
    category?: SortOrder
    isAllDay?: SortOrder
    location?: SortOrder
    isPrivate?: SortOrder
    status?: SortOrder
    deletedAt?: SortOrder
  }

  export type EventMinOrderByAggregateInput = {
    id?: SortOrder
    householdId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    choreId?: SortOrder
    recurrenceRuleId?: SortOrder
    category?: SortOrder
    isAllDay?: SortOrder
    location?: SortOrder
    isPrivate?: SortOrder
    status?: SortOrder
    deletedAt?: SortOrder
  }

  export type EnumEventCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EventCategory | EnumEventCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.EventCategory[] | ListEnumEventCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.EventCategory[] | ListEnumEventCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumEventCategoryWithAggregatesFilter<$PrismaModel> | $Enums.EventCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEventCategoryFilter<$PrismaModel>
    _max?: NestedEnumEventCategoryFilter<$PrismaModel>
  }

  export type EnumEventStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EventStatus | EnumEventStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EventStatus[] | ListEnumEventStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EventStatus[] | ListEnumEventStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEventStatusWithAggregatesFilter<$PrismaModel> | $Enums.EventStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEventStatusFilter<$PrismaModel>
    _max?: NestedEnumEventStatusFilter<$PrismaModel>
  }

  export type EnumEventReminderTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.EventReminderType | EnumEventReminderTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EventReminderType[] | ListEnumEventReminderTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EventReminderType[] | ListEnumEventReminderTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEventReminderTypeFilter<$PrismaModel> | $Enums.EventReminderType
  }

  export type EventRelationFilter = {
    is?: EventWhereInput
    isNot?: EventWhereInput
  }

  export type EventReminderCountOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    time?: SortOrder
    type?: SortOrder
  }

  export type EventReminderMaxOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    time?: SortOrder
    type?: SortOrder
  }

  export type EventReminderMinOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    time?: SortOrder
    type?: SortOrder
  }

  export type EnumEventReminderTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EventReminderType | EnumEventReminderTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EventReminderType[] | ListEnumEventReminderTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EventReminderType[] | ListEnumEventReminderTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEventReminderTypeWithAggregatesFilter<$PrismaModel> | $Enums.EventReminderType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEventReminderTypeFilter<$PrismaModel>
    _max?: NestedEnumEventReminderTypeFilter<$PrismaModel>
  }

  export type EnumCalendarEventActionFilter<$PrismaModel = never> = {
    equals?: $Enums.CalendarEventAction | EnumCalendarEventActionFieldRefInput<$PrismaModel>
    in?: $Enums.CalendarEventAction[] | ListEnumCalendarEventActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.CalendarEventAction[] | ListEnumCalendarEventActionFieldRefInput<$PrismaModel>
    not?: NestedEnumCalendarEventActionFilter<$PrismaModel> | $Enums.CalendarEventAction
  }

  export type CalendarEventHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    action?: SortOrder
    changedById?: SortOrder
    changedAt?: SortOrder
  }

  export type CalendarEventHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    action?: SortOrder
    changedById?: SortOrder
    changedAt?: SortOrder
  }

  export type CalendarEventHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    action?: SortOrder
    changedById?: SortOrder
    changedAt?: SortOrder
  }

  export type EnumCalendarEventActionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CalendarEventAction | EnumCalendarEventActionFieldRefInput<$PrismaModel>
    in?: $Enums.CalendarEventAction[] | ListEnumCalendarEventActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.CalendarEventAction[] | ListEnumCalendarEventActionFieldRefInput<$PrismaModel>
    not?: NestedEnumCalendarEventActionWithAggregatesFilter<$PrismaModel> | $Enums.CalendarEventAction
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCalendarEventActionFilter<$PrismaModel>
    _max?: NestedEnumCalendarEventActionFilter<$PrismaModel>
  }

  export type EnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type HouseholdNullableRelationFilter = {
    is?: HouseholdWhereInput | null
    isNot?: HouseholdWhereInput | null
  }

  export type NotificationSettingsCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    householdId?: SortOrder
    messageNotif?: SortOrder
    mentionsNotif?: SortOrder
    reactionsNotif?: SortOrder
    choreNotif?: SortOrder
    financeNotif?: SortOrder
    calendarNotif?: SortOrder
    remindersNotif?: SortOrder
  }

  export type NotificationSettingsMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    householdId?: SortOrder
    messageNotif?: SortOrder
    mentionsNotif?: SortOrder
    reactionsNotif?: SortOrder
    choreNotif?: SortOrder
    financeNotif?: SortOrder
    calendarNotif?: SortOrder
    remindersNotif?: SortOrder
  }

  export type NotificationSettingsMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    householdId?: SortOrder
    messageNotif?: SortOrder
    mentionsNotif?: SortOrder
    reactionsNotif?: SortOrder
    choreNotif?: SortOrder
    financeNotif?: SortOrder
    calendarNotif?: SortOrder
    remindersNotif?: SortOrder
  }

  export type EnumProviderFilter<$PrismaModel = never> = {
    equals?: $Enums.Provider | EnumProviderFieldRefInput<$PrismaModel>
    in?: $Enums.Provider[] | ListEnumProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Provider[] | ListEnumProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumProviderFilter<$PrismaModel> | $Enums.Provider
  }

  export type OAuthIntegrationUserIdProviderCompoundUniqueInput = {
    userId: string
    provider: $Enums.Provider
  }

  export type OAuthIntegrationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    expiresAt?: SortOrder
  }

  export type OAuthIntegrationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    expiresAt?: SortOrder
  }

  export type OAuthIntegrationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    expiresAt?: SortOrder
  }

  export type EnumProviderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Provider | EnumProviderFieldRefInput<$PrismaModel>
    in?: $Enums.Provider[] | ListEnumProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Provider[] | ListEnumProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumProviderWithAggregatesFilter<$PrismaModel> | $Enums.Provider
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProviderFilter<$PrismaModel>
    _max?: NestedEnumProviderFilter<$PrismaModel>
  }

  export type UserCreatedeviceTokensInput = {
    set: string[]
  }

  export type HouseholdMemberCreateNestedManyWithoutUserInput = {
    create?: XOR<HouseholdMemberCreateWithoutUserInput, HouseholdMemberUncheckedCreateWithoutUserInput> | HouseholdMemberCreateWithoutUserInput[] | HouseholdMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: HouseholdMemberCreateOrConnectWithoutUserInput | HouseholdMemberCreateOrConnectWithoutUserInput[]
    createMany?: HouseholdMemberCreateManyUserInputEnvelope
    connect?: HouseholdMemberWhereUniqueInput | HouseholdMemberWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutAuthorInput = {
    create?: XOR<MessageCreateWithoutAuthorInput, MessageUncheckedCreateWithoutAuthorInput> | MessageCreateWithoutAuthorInput[] | MessageUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutAuthorInput | MessageCreateOrConnectWithoutAuthorInput[]
    createMany?: MessageCreateManyAuthorInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type ThreadCreateNestedManyWithoutAuthorInput = {
    create?: XOR<ThreadCreateWithoutAuthorInput, ThreadUncheckedCreateWithoutAuthorInput> | ThreadCreateWithoutAuthorInput[] | ThreadUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: ThreadCreateOrConnectWithoutAuthorInput | ThreadCreateOrConnectWithoutAuthorInput[]
    createMany?: ThreadCreateManyAuthorInputEnvelope
    connect?: ThreadWhereUniqueInput | ThreadWhereUniqueInput[]
  }

  export type ChoreAssignmentCreateNestedManyWithoutUserInput = {
    create?: XOR<ChoreAssignmentCreateWithoutUserInput, ChoreAssignmentUncheckedCreateWithoutUserInput> | ChoreAssignmentCreateWithoutUserInput[] | ChoreAssignmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChoreAssignmentCreateOrConnectWithoutUserInput | ChoreAssignmentCreateOrConnectWithoutUserInput[]
    createMany?: ChoreAssignmentCreateManyUserInputEnvelope
    connect?: ChoreAssignmentWhereUniqueInput | ChoreAssignmentWhereUniqueInput[]
  }

  export type ExpenseCreateNestedManyWithoutPaidByInput = {
    create?: XOR<ExpenseCreateWithoutPaidByInput, ExpenseUncheckedCreateWithoutPaidByInput> | ExpenseCreateWithoutPaidByInput[] | ExpenseUncheckedCreateWithoutPaidByInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutPaidByInput | ExpenseCreateOrConnectWithoutPaidByInput[]
    createMany?: ExpenseCreateManyPaidByInputEnvelope
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
  }

  export type ExpenseSplitCreateNestedManyWithoutUserInput = {
    create?: XOR<ExpenseSplitCreateWithoutUserInput, ExpenseSplitUncheckedCreateWithoutUserInput> | ExpenseSplitCreateWithoutUserInput[] | ExpenseSplitUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ExpenseSplitCreateOrConnectWithoutUserInput | ExpenseSplitCreateOrConnectWithoutUserInput[]
    createMany?: ExpenseSplitCreateManyUserInputEnvelope
    connect?: ExpenseSplitWhereUniqueInput | ExpenseSplitWhereUniqueInput[]
  }

  export type TransactionCreateNestedManyWithoutFromUserInput = {
    create?: XOR<TransactionCreateWithoutFromUserInput, TransactionUncheckedCreateWithoutFromUserInput> | TransactionCreateWithoutFromUserInput[] | TransactionUncheckedCreateWithoutFromUserInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutFromUserInput | TransactionCreateOrConnectWithoutFromUserInput[]
    createMany?: TransactionCreateManyFromUserInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type TransactionCreateNestedManyWithoutToUserInput = {
    create?: XOR<TransactionCreateWithoutToUserInput, TransactionUncheckedCreateWithoutToUserInput> | TransactionCreateWithoutToUserInput[] | TransactionUncheckedCreateWithoutToUserInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutToUserInput | TransactionCreateOrConnectWithoutToUserInput[]
    createMany?: TransactionCreateManyToUserInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type OAuthIntegrationCreateNestedManyWithoutUserInput = {
    create?: XOR<OAuthIntegrationCreateWithoutUserInput, OAuthIntegrationUncheckedCreateWithoutUserInput> | OAuthIntegrationCreateWithoutUserInput[] | OAuthIntegrationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OAuthIntegrationCreateOrConnectWithoutUserInput | OAuthIntegrationCreateOrConnectWithoutUserInput[]
    createMany?: OAuthIntegrationCreateManyUserInputEnvelope
    connect?: OAuthIntegrationWhereUniqueInput | OAuthIntegrationWhereUniqueInput[]
  }

  export type EventCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<EventCreateWithoutCreatedByInput, EventUncheckedCreateWithoutCreatedByInput> | EventCreateWithoutCreatedByInput[] | EventUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: EventCreateOrConnectWithoutCreatedByInput | EventCreateOrConnectWithoutCreatedByInput[]
    createMany?: EventCreateManyCreatedByInputEnvelope
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
  }

  export type ChoreSwapRequestCreateNestedManyWithoutRequestingUserInput = {
    create?: XOR<ChoreSwapRequestCreateWithoutRequestingUserInput, ChoreSwapRequestUncheckedCreateWithoutRequestingUserInput> | ChoreSwapRequestCreateWithoutRequestingUserInput[] | ChoreSwapRequestUncheckedCreateWithoutRequestingUserInput[]
    connectOrCreate?: ChoreSwapRequestCreateOrConnectWithoutRequestingUserInput | ChoreSwapRequestCreateOrConnectWithoutRequestingUserInput[]
    createMany?: ChoreSwapRequestCreateManyRequestingUserInputEnvelope
    connect?: ChoreSwapRequestWhereUniqueInput | ChoreSwapRequestWhereUniqueInput[]
  }

  export type ChoreSwapRequestCreateNestedManyWithoutTargetUserInput = {
    create?: XOR<ChoreSwapRequestCreateWithoutTargetUserInput, ChoreSwapRequestUncheckedCreateWithoutTargetUserInput> | ChoreSwapRequestCreateWithoutTargetUserInput[] | ChoreSwapRequestUncheckedCreateWithoutTargetUserInput[]
    connectOrCreate?: ChoreSwapRequestCreateOrConnectWithoutTargetUserInput | ChoreSwapRequestCreateOrConnectWithoutTargetUserInput[]
    createMany?: ChoreSwapRequestCreateManyTargetUserInputEnvelope
    connect?: ChoreSwapRequestWhereUniqueInput | ChoreSwapRequestWhereUniqueInput[]
  }

  export type ReactionCreateNestedManyWithoutUserInput = {
    create?: XOR<ReactionCreateWithoutUserInput, ReactionUncheckedCreateWithoutUserInput> | ReactionCreateWithoutUserInput[] | ReactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReactionCreateOrConnectWithoutUserInput | ReactionCreateOrConnectWithoutUserInput[]
    createMany?: ReactionCreateManyUserInputEnvelope
    connect?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
  }

  export type MentionCreateNestedManyWithoutUserInput = {
    create?: XOR<MentionCreateWithoutUserInput, MentionUncheckedCreateWithoutUserInput> | MentionCreateWithoutUserInput[] | MentionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MentionCreateOrConnectWithoutUserInput | MentionCreateOrConnectWithoutUserInput[]
    createMany?: MentionCreateManyUserInputEnvelope
    connect?: MentionWhereUniqueInput | MentionWhereUniqueInput[]
  }

  export type ChoreHistoryCreateNestedManyWithoutUserInput = {
    create?: XOR<ChoreHistoryCreateWithoutUserInput, ChoreHistoryUncheckedCreateWithoutUserInput> | ChoreHistoryCreateWithoutUserInput[] | ChoreHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChoreHistoryCreateOrConnectWithoutUserInput | ChoreHistoryCreateOrConnectWithoutUserInput[]
    createMany?: ChoreHistoryCreateManyUserInputEnvelope
    connect?: ChoreHistoryWhereUniqueInput | ChoreHistoryWhereUniqueInput[]
  }

  export type NotificationSettingsCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationSettingsCreateWithoutUserInput, NotificationSettingsUncheckedCreateWithoutUserInput> | NotificationSettingsCreateWithoutUserInput[] | NotificationSettingsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationSettingsCreateOrConnectWithoutUserInput | NotificationSettingsCreateOrConnectWithoutUserInput[]
    createMany?: NotificationSettingsCreateManyUserInputEnvelope
    connect?: NotificationSettingsWhereUniqueInput | NotificationSettingsWhereUniqueInput[]
  }

  export type CalendarEventHistoryCreateNestedManyWithoutUserInput = {
    create?: XOR<CalendarEventHistoryCreateWithoutUserInput, CalendarEventHistoryUncheckedCreateWithoutUserInput> | CalendarEventHistoryCreateWithoutUserInput[] | CalendarEventHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CalendarEventHistoryCreateOrConnectWithoutUserInput | CalendarEventHistoryCreateOrConnectWithoutUserInput[]
    createMany?: CalendarEventHistoryCreateManyUserInputEnvelope
    connect?: CalendarEventHistoryWhereUniqueInput | CalendarEventHistoryWhereUniqueInput[]
  }

  export type ExpenseHistoryCreateNestedManyWithoutUserInput = {
    create?: XOR<ExpenseHistoryCreateWithoutUserInput, ExpenseHistoryUncheckedCreateWithoutUserInput> | ExpenseHistoryCreateWithoutUserInput[] | ExpenseHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ExpenseHistoryCreateOrConnectWithoutUserInput | ExpenseHistoryCreateOrConnectWithoutUserInput[]
    createMany?: ExpenseHistoryCreateManyUserInputEnvelope
    connect?: ExpenseHistoryWhereUniqueInput | ExpenseHistoryWhereUniqueInput[]
  }

  export type MessageReadCreateNestedManyWithoutUserInput = {
    create?: XOR<MessageReadCreateWithoutUserInput, MessageReadUncheckedCreateWithoutUserInput> | MessageReadCreateWithoutUserInput[] | MessageReadUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MessageReadCreateOrConnectWithoutUserInput | MessageReadCreateOrConnectWithoutUserInput[]
    createMany?: MessageReadCreateManyUserInputEnvelope
    connect?: MessageReadWhereUniqueInput | MessageReadWhereUniqueInput[]
  }

  export type HouseholdMemberUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<HouseholdMemberCreateWithoutUserInput, HouseholdMemberUncheckedCreateWithoutUserInput> | HouseholdMemberCreateWithoutUserInput[] | HouseholdMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: HouseholdMemberCreateOrConnectWithoutUserInput | HouseholdMemberCreateOrConnectWithoutUserInput[]
    createMany?: HouseholdMemberCreateManyUserInputEnvelope
    connect?: HouseholdMemberWhereUniqueInput | HouseholdMemberWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<MessageCreateWithoutAuthorInput, MessageUncheckedCreateWithoutAuthorInput> | MessageCreateWithoutAuthorInput[] | MessageUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutAuthorInput | MessageCreateOrConnectWithoutAuthorInput[]
    createMany?: MessageCreateManyAuthorInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type ThreadUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<ThreadCreateWithoutAuthorInput, ThreadUncheckedCreateWithoutAuthorInput> | ThreadCreateWithoutAuthorInput[] | ThreadUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: ThreadCreateOrConnectWithoutAuthorInput | ThreadCreateOrConnectWithoutAuthorInput[]
    createMany?: ThreadCreateManyAuthorInputEnvelope
    connect?: ThreadWhereUniqueInput | ThreadWhereUniqueInput[]
  }

  export type ChoreAssignmentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ChoreAssignmentCreateWithoutUserInput, ChoreAssignmentUncheckedCreateWithoutUserInput> | ChoreAssignmentCreateWithoutUserInput[] | ChoreAssignmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChoreAssignmentCreateOrConnectWithoutUserInput | ChoreAssignmentCreateOrConnectWithoutUserInput[]
    createMany?: ChoreAssignmentCreateManyUserInputEnvelope
    connect?: ChoreAssignmentWhereUniqueInput | ChoreAssignmentWhereUniqueInput[]
  }

  export type ExpenseUncheckedCreateNestedManyWithoutPaidByInput = {
    create?: XOR<ExpenseCreateWithoutPaidByInput, ExpenseUncheckedCreateWithoutPaidByInput> | ExpenseCreateWithoutPaidByInput[] | ExpenseUncheckedCreateWithoutPaidByInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutPaidByInput | ExpenseCreateOrConnectWithoutPaidByInput[]
    createMany?: ExpenseCreateManyPaidByInputEnvelope
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
  }

  export type ExpenseSplitUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ExpenseSplitCreateWithoutUserInput, ExpenseSplitUncheckedCreateWithoutUserInput> | ExpenseSplitCreateWithoutUserInput[] | ExpenseSplitUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ExpenseSplitCreateOrConnectWithoutUserInput | ExpenseSplitCreateOrConnectWithoutUserInput[]
    createMany?: ExpenseSplitCreateManyUserInputEnvelope
    connect?: ExpenseSplitWhereUniqueInput | ExpenseSplitWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutFromUserInput = {
    create?: XOR<TransactionCreateWithoutFromUserInput, TransactionUncheckedCreateWithoutFromUserInput> | TransactionCreateWithoutFromUserInput[] | TransactionUncheckedCreateWithoutFromUserInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutFromUserInput | TransactionCreateOrConnectWithoutFromUserInput[]
    createMany?: TransactionCreateManyFromUserInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutToUserInput = {
    create?: XOR<TransactionCreateWithoutToUserInput, TransactionUncheckedCreateWithoutToUserInput> | TransactionCreateWithoutToUserInput[] | TransactionUncheckedCreateWithoutToUserInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutToUserInput | TransactionCreateOrConnectWithoutToUserInput[]
    createMany?: TransactionCreateManyToUserInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type OAuthIntegrationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<OAuthIntegrationCreateWithoutUserInput, OAuthIntegrationUncheckedCreateWithoutUserInput> | OAuthIntegrationCreateWithoutUserInput[] | OAuthIntegrationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OAuthIntegrationCreateOrConnectWithoutUserInput | OAuthIntegrationCreateOrConnectWithoutUserInput[]
    createMany?: OAuthIntegrationCreateManyUserInputEnvelope
    connect?: OAuthIntegrationWhereUniqueInput | OAuthIntegrationWhereUniqueInput[]
  }

  export type EventUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<EventCreateWithoutCreatedByInput, EventUncheckedCreateWithoutCreatedByInput> | EventCreateWithoutCreatedByInput[] | EventUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: EventCreateOrConnectWithoutCreatedByInput | EventCreateOrConnectWithoutCreatedByInput[]
    createMany?: EventCreateManyCreatedByInputEnvelope
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
  }

  export type ChoreSwapRequestUncheckedCreateNestedManyWithoutRequestingUserInput = {
    create?: XOR<ChoreSwapRequestCreateWithoutRequestingUserInput, ChoreSwapRequestUncheckedCreateWithoutRequestingUserInput> | ChoreSwapRequestCreateWithoutRequestingUserInput[] | ChoreSwapRequestUncheckedCreateWithoutRequestingUserInput[]
    connectOrCreate?: ChoreSwapRequestCreateOrConnectWithoutRequestingUserInput | ChoreSwapRequestCreateOrConnectWithoutRequestingUserInput[]
    createMany?: ChoreSwapRequestCreateManyRequestingUserInputEnvelope
    connect?: ChoreSwapRequestWhereUniqueInput | ChoreSwapRequestWhereUniqueInput[]
  }

  export type ChoreSwapRequestUncheckedCreateNestedManyWithoutTargetUserInput = {
    create?: XOR<ChoreSwapRequestCreateWithoutTargetUserInput, ChoreSwapRequestUncheckedCreateWithoutTargetUserInput> | ChoreSwapRequestCreateWithoutTargetUserInput[] | ChoreSwapRequestUncheckedCreateWithoutTargetUserInput[]
    connectOrCreate?: ChoreSwapRequestCreateOrConnectWithoutTargetUserInput | ChoreSwapRequestCreateOrConnectWithoutTargetUserInput[]
    createMany?: ChoreSwapRequestCreateManyTargetUserInputEnvelope
    connect?: ChoreSwapRequestWhereUniqueInput | ChoreSwapRequestWhereUniqueInput[]
  }

  export type ReactionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ReactionCreateWithoutUserInput, ReactionUncheckedCreateWithoutUserInput> | ReactionCreateWithoutUserInput[] | ReactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReactionCreateOrConnectWithoutUserInput | ReactionCreateOrConnectWithoutUserInput[]
    createMany?: ReactionCreateManyUserInputEnvelope
    connect?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
  }

  export type MentionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MentionCreateWithoutUserInput, MentionUncheckedCreateWithoutUserInput> | MentionCreateWithoutUserInput[] | MentionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MentionCreateOrConnectWithoutUserInput | MentionCreateOrConnectWithoutUserInput[]
    createMany?: MentionCreateManyUserInputEnvelope
    connect?: MentionWhereUniqueInput | MentionWhereUniqueInput[]
  }

  export type ChoreHistoryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ChoreHistoryCreateWithoutUserInput, ChoreHistoryUncheckedCreateWithoutUserInput> | ChoreHistoryCreateWithoutUserInput[] | ChoreHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChoreHistoryCreateOrConnectWithoutUserInput | ChoreHistoryCreateOrConnectWithoutUserInput[]
    createMany?: ChoreHistoryCreateManyUserInputEnvelope
    connect?: ChoreHistoryWhereUniqueInput | ChoreHistoryWhereUniqueInput[]
  }

  export type NotificationSettingsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationSettingsCreateWithoutUserInput, NotificationSettingsUncheckedCreateWithoutUserInput> | NotificationSettingsCreateWithoutUserInput[] | NotificationSettingsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationSettingsCreateOrConnectWithoutUserInput | NotificationSettingsCreateOrConnectWithoutUserInput[]
    createMany?: NotificationSettingsCreateManyUserInputEnvelope
    connect?: NotificationSettingsWhereUniqueInput | NotificationSettingsWhereUniqueInput[]
  }

  export type CalendarEventHistoryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CalendarEventHistoryCreateWithoutUserInput, CalendarEventHistoryUncheckedCreateWithoutUserInput> | CalendarEventHistoryCreateWithoutUserInput[] | CalendarEventHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CalendarEventHistoryCreateOrConnectWithoutUserInput | CalendarEventHistoryCreateOrConnectWithoutUserInput[]
    createMany?: CalendarEventHistoryCreateManyUserInputEnvelope
    connect?: CalendarEventHistoryWhereUniqueInput | CalendarEventHistoryWhereUniqueInput[]
  }

  export type ExpenseHistoryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ExpenseHistoryCreateWithoutUserInput, ExpenseHistoryUncheckedCreateWithoutUserInput> | ExpenseHistoryCreateWithoutUserInput[] | ExpenseHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ExpenseHistoryCreateOrConnectWithoutUserInput | ExpenseHistoryCreateOrConnectWithoutUserInput[]
    createMany?: ExpenseHistoryCreateManyUserInputEnvelope
    connect?: ExpenseHistoryWhereUniqueInput | ExpenseHistoryWhereUniqueInput[]
  }

  export type MessageReadUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MessageReadCreateWithoutUserInput, MessageReadUncheckedCreateWithoutUserInput> | MessageReadCreateWithoutUserInput[] | MessageReadUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MessageReadCreateOrConnectWithoutUserInput | MessageReadCreateOrConnectWithoutUserInput[]
    createMany?: MessageReadCreateManyUserInputEnvelope
    connect?: MessageReadWhereUniqueInput | MessageReadWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserUpdatedeviceTokensInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type HouseholdMemberUpdateManyWithoutUserNestedInput = {
    create?: XOR<HouseholdMemberCreateWithoutUserInput, HouseholdMemberUncheckedCreateWithoutUserInput> | HouseholdMemberCreateWithoutUserInput[] | HouseholdMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: HouseholdMemberCreateOrConnectWithoutUserInput | HouseholdMemberCreateOrConnectWithoutUserInput[]
    upsert?: HouseholdMemberUpsertWithWhereUniqueWithoutUserInput | HouseholdMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: HouseholdMemberCreateManyUserInputEnvelope
    set?: HouseholdMemberWhereUniqueInput | HouseholdMemberWhereUniqueInput[]
    disconnect?: HouseholdMemberWhereUniqueInput | HouseholdMemberWhereUniqueInput[]
    delete?: HouseholdMemberWhereUniqueInput | HouseholdMemberWhereUniqueInput[]
    connect?: HouseholdMemberWhereUniqueInput | HouseholdMemberWhereUniqueInput[]
    update?: HouseholdMemberUpdateWithWhereUniqueWithoutUserInput | HouseholdMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: HouseholdMemberUpdateManyWithWhereWithoutUserInput | HouseholdMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: HouseholdMemberScalarWhereInput | HouseholdMemberScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<MessageCreateWithoutAuthorInput, MessageUncheckedCreateWithoutAuthorInput> | MessageCreateWithoutAuthorInput[] | MessageUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutAuthorInput | MessageCreateOrConnectWithoutAuthorInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutAuthorInput | MessageUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: MessageCreateManyAuthorInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutAuthorInput | MessageUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutAuthorInput | MessageUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type ThreadUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<ThreadCreateWithoutAuthorInput, ThreadUncheckedCreateWithoutAuthorInput> | ThreadCreateWithoutAuthorInput[] | ThreadUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: ThreadCreateOrConnectWithoutAuthorInput | ThreadCreateOrConnectWithoutAuthorInput[]
    upsert?: ThreadUpsertWithWhereUniqueWithoutAuthorInput | ThreadUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: ThreadCreateManyAuthorInputEnvelope
    set?: ThreadWhereUniqueInput | ThreadWhereUniqueInput[]
    disconnect?: ThreadWhereUniqueInput | ThreadWhereUniqueInput[]
    delete?: ThreadWhereUniqueInput | ThreadWhereUniqueInput[]
    connect?: ThreadWhereUniqueInput | ThreadWhereUniqueInput[]
    update?: ThreadUpdateWithWhereUniqueWithoutAuthorInput | ThreadUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: ThreadUpdateManyWithWhereWithoutAuthorInput | ThreadUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: ThreadScalarWhereInput | ThreadScalarWhereInput[]
  }

  export type ChoreAssignmentUpdateManyWithoutUserNestedInput = {
    create?: XOR<ChoreAssignmentCreateWithoutUserInput, ChoreAssignmentUncheckedCreateWithoutUserInput> | ChoreAssignmentCreateWithoutUserInput[] | ChoreAssignmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChoreAssignmentCreateOrConnectWithoutUserInput | ChoreAssignmentCreateOrConnectWithoutUserInput[]
    upsert?: ChoreAssignmentUpsertWithWhereUniqueWithoutUserInput | ChoreAssignmentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ChoreAssignmentCreateManyUserInputEnvelope
    set?: ChoreAssignmentWhereUniqueInput | ChoreAssignmentWhereUniqueInput[]
    disconnect?: ChoreAssignmentWhereUniqueInput | ChoreAssignmentWhereUniqueInput[]
    delete?: ChoreAssignmentWhereUniqueInput | ChoreAssignmentWhereUniqueInput[]
    connect?: ChoreAssignmentWhereUniqueInput | ChoreAssignmentWhereUniqueInput[]
    update?: ChoreAssignmentUpdateWithWhereUniqueWithoutUserInput | ChoreAssignmentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ChoreAssignmentUpdateManyWithWhereWithoutUserInput | ChoreAssignmentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ChoreAssignmentScalarWhereInput | ChoreAssignmentScalarWhereInput[]
  }

  export type ExpenseUpdateManyWithoutPaidByNestedInput = {
    create?: XOR<ExpenseCreateWithoutPaidByInput, ExpenseUncheckedCreateWithoutPaidByInput> | ExpenseCreateWithoutPaidByInput[] | ExpenseUncheckedCreateWithoutPaidByInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutPaidByInput | ExpenseCreateOrConnectWithoutPaidByInput[]
    upsert?: ExpenseUpsertWithWhereUniqueWithoutPaidByInput | ExpenseUpsertWithWhereUniqueWithoutPaidByInput[]
    createMany?: ExpenseCreateManyPaidByInputEnvelope
    set?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    disconnect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    delete?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    update?: ExpenseUpdateWithWhereUniqueWithoutPaidByInput | ExpenseUpdateWithWhereUniqueWithoutPaidByInput[]
    updateMany?: ExpenseUpdateManyWithWhereWithoutPaidByInput | ExpenseUpdateManyWithWhereWithoutPaidByInput[]
    deleteMany?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
  }

  export type ExpenseSplitUpdateManyWithoutUserNestedInput = {
    create?: XOR<ExpenseSplitCreateWithoutUserInput, ExpenseSplitUncheckedCreateWithoutUserInput> | ExpenseSplitCreateWithoutUserInput[] | ExpenseSplitUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ExpenseSplitCreateOrConnectWithoutUserInput | ExpenseSplitCreateOrConnectWithoutUserInput[]
    upsert?: ExpenseSplitUpsertWithWhereUniqueWithoutUserInput | ExpenseSplitUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ExpenseSplitCreateManyUserInputEnvelope
    set?: ExpenseSplitWhereUniqueInput | ExpenseSplitWhereUniqueInput[]
    disconnect?: ExpenseSplitWhereUniqueInput | ExpenseSplitWhereUniqueInput[]
    delete?: ExpenseSplitWhereUniqueInput | ExpenseSplitWhereUniqueInput[]
    connect?: ExpenseSplitWhereUniqueInput | ExpenseSplitWhereUniqueInput[]
    update?: ExpenseSplitUpdateWithWhereUniqueWithoutUserInput | ExpenseSplitUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ExpenseSplitUpdateManyWithWhereWithoutUserInput | ExpenseSplitUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ExpenseSplitScalarWhereInput | ExpenseSplitScalarWhereInput[]
  }

  export type TransactionUpdateManyWithoutFromUserNestedInput = {
    create?: XOR<TransactionCreateWithoutFromUserInput, TransactionUncheckedCreateWithoutFromUserInput> | TransactionCreateWithoutFromUserInput[] | TransactionUncheckedCreateWithoutFromUserInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutFromUserInput | TransactionCreateOrConnectWithoutFromUserInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutFromUserInput | TransactionUpsertWithWhereUniqueWithoutFromUserInput[]
    createMany?: TransactionCreateManyFromUserInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutFromUserInput | TransactionUpdateWithWhereUniqueWithoutFromUserInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutFromUserInput | TransactionUpdateManyWithWhereWithoutFromUserInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type TransactionUpdateManyWithoutToUserNestedInput = {
    create?: XOR<TransactionCreateWithoutToUserInput, TransactionUncheckedCreateWithoutToUserInput> | TransactionCreateWithoutToUserInput[] | TransactionUncheckedCreateWithoutToUserInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutToUserInput | TransactionCreateOrConnectWithoutToUserInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutToUserInput | TransactionUpsertWithWhereUniqueWithoutToUserInput[]
    createMany?: TransactionCreateManyToUserInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutToUserInput | TransactionUpdateWithWhereUniqueWithoutToUserInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutToUserInput | TransactionUpdateManyWithWhereWithoutToUserInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type OAuthIntegrationUpdateManyWithoutUserNestedInput = {
    create?: XOR<OAuthIntegrationCreateWithoutUserInput, OAuthIntegrationUncheckedCreateWithoutUserInput> | OAuthIntegrationCreateWithoutUserInput[] | OAuthIntegrationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OAuthIntegrationCreateOrConnectWithoutUserInput | OAuthIntegrationCreateOrConnectWithoutUserInput[]
    upsert?: OAuthIntegrationUpsertWithWhereUniqueWithoutUserInput | OAuthIntegrationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OAuthIntegrationCreateManyUserInputEnvelope
    set?: OAuthIntegrationWhereUniqueInput | OAuthIntegrationWhereUniqueInput[]
    disconnect?: OAuthIntegrationWhereUniqueInput | OAuthIntegrationWhereUniqueInput[]
    delete?: OAuthIntegrationWhereUniqueInput | OAuthIntegrationWhereUniqueInput[]
    connect?: OAuthIntegrationWhereUniqueInput | OAuthIntegrationWhereUniqueInput[]
    update?: OAuthIntegrationUpdateWithWhereUniqueWithoutUserInput | OAuthIntegrationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OAuthIntegrationUpdateManyWithWhereWithoutUserInput | OAuthIntegrationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OAuthIntegrationScalarWhereInput | OAuthIntegrationScalarWhereInput[]
  }

  export type EventUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<EventCreateWithoutCreatedByInput, EventUncheckedCreateWithoutCreatedByInput> | EventCreateWithoutCreatedByInput[] | EventUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: EventCreateOrConnectWithoutCreatedByInput | EventCreateOrConnectWithoutCreatedByInput[]
    upsert?: EventUpsertWithWhereUniqueWithoutCreatedByInput | EventUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: EventCreateManyCreatedByInputEnvelope
    set?: EventWhereUniqueInput | EventWhereUniqueInput[]
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    update?: EventUpdateWithWhereUniqueWithoutCreatedByInput | EventUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: EventUpdateManyWithWhereWithoutCreatedByInput | EventUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[]
  }

  export type ChoreSwapRequestUpdateManyWithoutRequestingUserNestedInput = {
    create?: XOR<ChoreSwapRequestCreateWithoutRequestingUserInput, ChoreSwapRequestUncheckedCreateWithoutRequestingUserInput> | ChoreSwapRequestCreateWithoutRequestingUserInput[] | ChoreSwapRequestUncheckedCreateWithoutRequestingUserInput[]
    connectOrCreate?: ChoreSwapRequestCreateOrConnectWithoutRequestingUserInput | ChoreSwapRequestCreateOrConnectWithoutRequestingUserInput[]
    upsert?: ChoreSwapRequestUpsertWithWhereUniqueWithoutRequestingUserInput | ChoreSwapRequestUpsertWithWhereUniqueWithoutRequestingUserInput[]
    createMany?: ChoreSwapRequestCreateManyRequestingUserInputEnvelope
    set?: ChoreSwapRequestWhereUniqueInput | ChoreSwapRequestWhereUniqueInput[]
    disconnect?: ChoreSwapRequestWhereUniqueInput | ChoreSwapRequestWhereUniqueInput[]
    delete?: ChoreSwapRequestWhereUniqueInput | ChoreSwapRequestWhereUniqueInput[]
    connect?: ChoreSwapRequestWhereUniqueInput | ChoreSwapRequestWhereUniqueInput[]
    update?: ChoreSwapRequestUpdateWithWhereUniqueWithoutRequestingUserInput | ChoreSwapRequestUpdateWithWhereUniqueWithoutRequestingUserInput[]
    updateMany?: ChoreSwapRequestUpdateManyWithWhereWithoutRequestingUserInput | ChoreSwapRequestUpdateManyWithWhereWithoutRequestingUserInput[]
    deleteMany?: ChoreSwapRequestScalarWhereInput | ChoreSwapRequestScalarWhereInput[]
  }

  export type ChoreSwapRequestUpdateManyWithoutTargetUserNestedInput = {
    create?: XOR<ChoreSwapRequestCreateWithoutTargetUserInput, ChoreSwapRequestUncheckedCreateWithoutTargetUserInput> | ChoreSwapRequestCreateWithoutTargetUserInput[] | ChoreSwapRequestUncheckedCreateWithoutTargetUserInput[]
    connectOrCreate?: ChoreSwapRequestCreateOrConnectWithoutTargetUserInput | ChoreSwapRequestCreateOrConnectWithoutTargetUserInput[]
    upsert?: ChoreSwapRequestUpsertWithWhereUniqueWithoutTargetUserInput | ChoreSwapRequestUpsertWithWhereUniqueWithoutTargetUserInput[]
    createMany?: ChoreSwapRequestCreateManyTargetUserInputEnvelope
    set?: ChoreSwapRequestWhereUniqueInput | ChoreSwapRequestWhereUniqueInput[]
    disconnect?: ChoreSwapRequestWhereUniqueInput | ChoreSwapRequestWhereUniqueInput[]
    delete?: ChoreSwapRequestWhereUniqueInput | ChoreSwapRequestWhereUniqueInput[]
    connect?: ChoreSwapRequestWhereUniqueInput | ChoreSwapRequestWhereUniqueInput[]
    update?: ChoreSwapRequestUpdateWithWhereUniqueWithoutTargetUserInput | ChoreSwapRequestUpdateWithWhereUniqueWithoutTargetUserInput[]
    updateMany?: ChoreSwapRequestUpdateManyWithWhereWithoutTargetUserInput | ChoreSwapRequestUpdateManyWithWhereWithoutTargetUserInput[]
    deleteMany?: ChoreSwapRequestScalarWhereInput | ChoreSwapRequestScalarWhereInput[]
  }

  export type ReactionUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReactionCreateWithoutUserInput, ReactionUncheckedCreateWithoutUserInput> | ReactionCreateWithoutUserInput[] | ReactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReactionCreateOrConnectWithoutUserInput | ReactionCreateOrConnectWithoutUserInput[]
    upsert?: ReactionUpsertWithWhereUniqueWithoutUserInput | ReactionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReactionCreateManyUserInputEnvelope
    set?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
    disconnect?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
    delete?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
    connect?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
    update?: ReactionUpdateWithWhereUniqueWithoutUserInput | ReactionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReactionUpdateManyWithWhereWithoutUserInput | ReactionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReactionScalarWhereInput | ReactionScalarWhereInput[]
  }

  export type MentionUpdateManyWithoutUserNestedInput = {
    create?: XOR<MentionCreateWithoutUserInput, MentionUncheckedCreateWithoutUserInput> | MentionCreateWithoutUserInput[] | MentionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MentionCreateOrConnectWithoutUserInput | MentionCreateOrConnectWithoutUserInput[]
    upsert?: MentionUpsertWithWhereUniqueWithoutUserInput | MentionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MentionCreateManyUserInputEnvelope
    set?: MentionWhereUniqueInput | MentionWhereUniqueInput[]
    disconnect?: MentionWhereUniqueInput | MentionWhereUniqueInput[]
    delete?: MentionWhereUniqueInput | MentionWhereUniqueInput[]
    connect?: MentionWhereUniqueInput | MentionWhereUniqueInput[]
    update?: MentionUpdateWithWhereUniqueWithoutUserInput | MentionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MentionUpdateManyWithWhereWithoutUserInput | MentionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MentionScalarWhereInput | MentionScalarWhereInput[]
  }

  export type ChoreHistoryUpdateManyWithoutUserNestedInput = {
    create?: XOR<ChoreHistoryCreateWithoutUserInput, ChoreHistoryUncheckedCreateWithoutUserInput> | ChoreHistoryCreateWithoutUserInput[] | ChoreHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChoreHistoryCreateOrConnectWithoutUserInput | ChoreHistoryCreateOrConnectWithoutUserInput[]
    upsert?: ChoreHistoryUpsertWithWhereUniqueWithoutUserInput | ChoreHistoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ChoreHistoryCreateManyUserInputEnvelope
    set?: ChoreHistoryWhereUniqueInput | ChoreHistoryWhereUniqueInput[]
    disconnect?: ChoreHistoryWhereUniqueInput | ChoreHistoryWhereUniqueInput[]
    delete?: ChoreHistoryWhereUniqueInput | ChoreHistoryWhereUniqueInput[]
    connect?: ChoreHistoryWhereUniqueInput | ChoreHistoryWhereUniqueInput[]
    update?: ChoreHistoryUpdateWithWhereUniqueWithoutUserInput | ChoreHistoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ChoreHistoryUpdateManyWithWhereWithoutUserInput | ChoreHistoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ChoreHistoryScalarWhereInput | ChoreHistoryScalarWhereInput[]
  }

  export type NotificationSettingsUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationSettingsCreateWithoutUserInput, NotificationSettingsUncheckedCreateWithoutUserInput> | NotificationSettingsCreateWithoutUserInput[] | NotificationSettingsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationSettingsCreateOrConnectWithoutUserInput | NotificationSettingsCreateOrConnectWithoutUserInput[]
    upsert?: NotificationSettingsUpsertWithWhereUniqueWithoutUserInput | NotificationSettingsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationSettingsCreateManyUserInputEnvelope
    set?: NotificationSettingsWhereUniqueInput | NotificationSettingsWhereUniqueInput[]
    disconnect?: NotificationSettingsWhereUniqueInput | NotificationSettingsWhereUniqueInput[]
    delete?: NotificationSettingsWhereUniqueInput | NotificationSettingsWhereUniqueInput[]
    connect?: NotificationSettingsWhereUniqueInput | NotificationSettingsWhereUniqueInput[]
    update?: NotificationSettingsUpdateWithWhereUniqueWithoutUserInput | NotificationSettingsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationSettingsUpdateManyWithWhereWithoutUserInput | NotificationSettingsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationSettingsScalarWhereInput | NotificationSettingsScalarWhereInput[]
  }

  export type CalendarEventHistoryUpdateManyWithoutUserNestedInput = {
    create?: XOR<CalendarEventHistoryCreateWithoutUserInput, CalendarEventHistoryUncheckedCreateWithoutUserInput> | CalendarEventHistoryCreateWithoutUserInput[] | CalendarEventHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CalendarEventHistoryCreateOrConnectWithoutUserInput | CalendarEventHistoryCreateOrConnectWithoutUserInput[]
    upsert?: CalendarEventHistoryUpsertWithWhereUniqueWithoutUserInput | CalendarEventHistoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CalendarEventHistoryCreateManyUserInputEnvelope
    set?: CalendarEventHistoryWhereUniqueInput | CalendarEventHistoryWhereUniqueInput[]
    disconnect?: CalendarEventHistoryWhereUniqueInput | CalendarEventHistoryWhereUniqueInput[]
    delete?: CalendarEventHistoryWhereUniqueInput | CalendarEventHistoryWhereUniqueInput[]
    connect?: CalendarEventHistoryWhereUniqueInput | CalendarEventHistoryWhereUniqueInput[]
    update?: CalendarEventHistoryUpdateWithWhereUniqueWithoutUserInput | CalendarEventHistoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CalendarEventHistoryUpdateManyWithWhereWithoutUserInput | CalendarEventHistoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CalendarEventHistoryScalarWhereInput | CalendarEventHistoryScalarWhereInput[]
  }

  export type ExpenseHistoryUpdateManyWithoutUserNestedInput = {
    create?: XOR<ExpenseHistoryCreateWithoutUserInput, ExpenseHistoryUncheckedCreateWithoutUserInput> | ExpenseHistoryCreateWithoutUserInput[] | ExpenseHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ExpenseHistoryCreateOrConnectWithoutUserInput | ExpenseHistoryCreateOrConnectWithoutUserInput[]
    upsert?: ExpenseHistoryUpsertWithWhereUniqueWithoutUserInput | ExpenseHistoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ExpenseHistoryCreateManyUserInputEnvelope
    set?: ExpenseHistoryWhereUniqueInput | ExpenseHistoryWhereUniqueInput[]
    disconnect?: ExpenseHistoryWhereUniqueInput | ExpenseHistoryWhereUniqueInput[]
    delete?: ExpenseHistoryWhereUniqueInput | ExpenseHistoryWhereUniqueInput[]
    connect?: ExpenseHistoryWhereUniqueInput | ExpenseHistoryWhereUniqueInput[]
    update?: ExpenseHistoryUpdateWithWhereUniqueWithoutUserInput | ExpenseHistoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ExpenseHistoryUpdateManyWithWhereWithoutUserInput | ExpenseHistoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ExpenseHistoryScalarWhereInput | ExpenseHistoryScalarWhereInput[]
  }

  export type MessageReadUpdateManyWithoutUserNestedInput = {
    create?: XOR<MessageReadCreateWithoutUserInput, MessageReadUncheckedCreateWithoutUserInput> | MessageReadCreateWithoutUserInput[] | MessageReadUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MessageReadCreateOrConnectWithoutUserInput | MessageReadCreateOrConnectWithoutUserInput[]
    upsert?: MessageReadUpsertWithWhereUniqueWithoutUserInput | MessageReadUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MessageReadCreateManyUserInputEnvelope
    set?: MessageReadWhereUniqueInput | MessageReadWhereUniqueInput[]
    disconnect?: MessageReadWhereUniqueInput | MessageReadWhereUniqueInput[]
    delete?: MessageReadWhereUniqueInput | MessageReadWhereUniqueInput[]
    connect?: MessageReadWhereUniqueInput | MessageReadWhereUniqueInput[]
    update?: MessageReadUpdateWithWhereUniqueWithoutUserInput | MessageReadUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MessageReadUpdateManyWithWhereWithoutUserInput | MessageReadUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MessageReadScalarWhereInput | MessageReadScalarWhereInput[]
  }

  export type HouseholdMemberUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<HouseholdMemberCreateWithoutUserInput, HouseholdMemberUncheckedCreateWithoutUserInput> | HouseholdMemberCreateWithoutUserInput[] | HouseholdMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: HouseholdMemberCreateOrConnectWithoutUserInput | HouseholdMemberCreateOrConnectWithoutUserInput[]
    upsert?: HouseholdMemberUpsertWithWhereUniqueWithoutUserInput | HouseholdMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: HouseholdMemberCreateManyUserInputEnvelope
    set?: HouseholdMemberWhereUniqueInput | HouseholdMemberWhereUniqueInput[]
    disconnect?: HouseholdMemberWhereUniqueInput | HouseholdMemberWhereUniqueInput[]
    delete?: HouseholdMemberWhereUniqueInput | HouseholdMemberWhereUniqueInput[]
    connect?: HouseholdMemberWhereUniqueInput | HouseholdMemberWhereUniqueInput[]
    update?: HouseholdMemberUpdateWithWhereUniqueWithoutUserInput | HouseholdMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: HouseholdMemberUpdateManyWithWhereWithoutUserInput | HouseholdMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: HouseholdMemberScalarWhereInput | HouseholdMemberScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<MessageCreateWithoutAuthorInput, MessageUncheckedCreateWithoutAuthorInput> | MessageCreateWithoutAuthorInput[] | MessageUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutAuthorInput | MessageCreateOrConnectWithoutAuthorInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutAuthorInput | MessageUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: MessageCreateManyAuthorInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutAuthorInput | MessageUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutAuthorInput | MessageUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type ThreadUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<ThreadCreateWithoutAuthorInput, ThreadUncheckedCreateWithoutAuthorInput> | ThreadCreateWithoutAuthorInput[] | ThreadUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: ThreadCreateOrConnectWithoutAuthorInput | ThreadCreateOrConnectWithoutAuthorInput[]
    upsert?: ThreadUpsertWithWhereUniqueWithoutAuthorInput | ThreadUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: ThreadCreateManyAuthorInputEnvelope
    set?: ThreadWhereUniqueInput | ThreadWhereUniqueInput[]
    disconnect?: ThreadWhereUniqueInput | ThreadWhereUniqueInput[]
    delete?: ThreadWhereUniqueInput | ThreadWhereUniqueInput[]
    connect?: ThreadWhereUniqueInput | ThreadWhereUniqueInput[]
    update?: ThreadUpdateWithWhereUniqueWithoutAuthorInput | ThreadUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: ThreadUpdateManyWithWhereWithoutAuthorInput | ThreadUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: ThreadScalarWhereInput | ThreadScalarWhereInput[]
  }

  export type ChoreAssignmentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ChoreAssignmentCreateWithoutUserInput, ChoreAssignmentUncheckedCreateWithoutUserInput> | ChoreAssignmentCreateWithoutUserInput[] | ChoreAssignmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChoreAssignmentCreateOrConnectWithoutUserInput | ChoreAssignmentCreateOrConnectWithoutUserInput[]
    upsert?: ChoreAssignmentUpsertWithWhereUniqueWithoutUserInput | ChoreAssignmentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ChoreAssignmentCreateManyUserInputEnvelope
    set?: ChoreAssignmentWhereUniqueInput | ChoreAssignmentWhereUniqueInput[]
    disconnect?: ChoreAssignmentWhereUniqueInput | ChoreAssignmentWhereUniqueInput[]
    delete?: ChoreAssignmentWhereUniqueInput | ChoreAssignmentWhereUniqueInput[]
    connect?: ChoreAssignmentWhereUniqueInput | ChoreAssignmentWhereUniqueInput[]
    update?: ChoreAssignmentUpdateWithWhereUniqueWithoutUserInput | ChoreAssignmentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ChoreAssignmentUpdateManyWithWhereWithoutUserInput | ChoreAssignmentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ChoreAssignmentScalarWhereInput | ChoreAssignmentScalarWhereInput[]
  }

  export type ExpenseUncheckedUpdateManyWithoutPaidByNestedInput = {
    create?: XOR<ExpenseCreateWithoutPaidByInput, ExpenseUncheckedCreateWithoutPaidByInput> | ExpenseCreateWithoutPaidByInput[] | ExpenseUncheckedCreateWithoutPaidByInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutPaidByInput | ExpenseCreateOrConnectWithoutPaidByInput[]
    upsert?: ExpenseUpsertWithWhereUniqueWithoutPaidByInput | ExpenseUpsertWithWhereUniqueWithoutPaidByInput[]
    createMany?: ExpenseCreateManyPaidByInputEnvelope
    set?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    disconnect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    delete?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    update?: ExpenseUpdateWithWhereUniqueWithoutPaidByInput | ExpenseUpdateWithWhereUniqueWithoutPaidByInput[]
    updateMany?: ExpenseUpdateManyWithWhereWithoutPaidByInput | ExpenseUpdateManyWithWhereWithoutPaidByInput[]
    deleteMany?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
  }

  export type ExpenseSplitUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ExpenseSplitCreateWithoutUserInput, ExpenseSplitUncheckedCreateWithoutUserInput> | ExpenseSplitCreateWithoutUserInput[] | ExpenseSplitUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ExpenseSplitCreateOrConnectWithoutUserInput | ExpenseSplitCreateOrConnectWithoutUserInput[]
    upsert?: ExpenseSplitUpsertWithWhereUniqueWithoutUserInput | ExpenseSplitUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ExpenseSplitCreateManyUserInputEnvelope
    set?: ExpenseSplitWhereUniqueInput | ExpenseSplitWhereUniqueInput[]
    disconnect?: ExpenseSplitWhereUniqueInput | ExpenseSplitWhereUniqueInput[]
    delete?: ExpenseSplitWhereUniqueInput | ExpenseSplitWhereUniqueInput[]
    connect?: ExpenseSplitWhereUniqueInput | ExpenseSplitWhereUniqueInput[]
    update?: ExpenseSplitUpdateWithWhereUniqueWithoutUserInput | ExpenseSplitUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ExpenseSplitUpdateManyWithWhereWithoutUserInput | ExpenseSplitUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ExpenseSplitScalarWhereInput | ExpenseSplitScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutFromUserNestedInput = {
    create?: XOR<TransactionCreateWithoutFromUserInput, TransactionUncheckedCreateWithoutFromUserInput> | TransactionCreateWithoutFromUserInput[] | TransactionUncheckedCreateWithoutFromUserInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutFromUserInput | TransactionCreateOrConnectWithoutFromUserInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutFromUserInput | TransactionUpsertWithWhereUniqueWithoutFromUserInput[]
    createMany?: TransactionCreateManyFromUserInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutFromUserInput | TransactionUpdateWithWhereUniqueWithoutFromUserInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutFromUserInput | TransactionUpdateManyWithWhereWithoutFromUserInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutToUserNestedInput = {
    create?: XOR<TransactionCreateWithoutToUserInput, TransactionUncheckedCreateWithoutToUserInput> | TransactionCreateWithoutToUserInput[] | TransactionUncheckedCreateWithoutToUserInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutToUserInput | TransactionCreateOrConnectWithoutToUserInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutToUserInput | TransactionUpsertWithWhereUniqueWithoutToUserInput[]
    createMany?: TransactionCreateManyToUserInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutToUserInput | TransactionUpdateWithWhereUniqueWithoutToUserInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutToUserInput | TransactionUpdateManyWithWhereWithoutToUserInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type OAuthIntegrationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<OAuthIntegrationCreateWithoutUserInput, OAuthIntegrationUncheckedCreateWithoutUserInput> | OAuthIntegrationCreateWithoutUserInput[] | OAuthIntegrationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OAuthIntegrationCreateOrConnectWithoutUserInput | OAuthIntegrationCreateOrConnectWithoutUserInput[]
    upsert?: OAuthIntegrationUpsertWithWhereUniqueWithoutUserInput | OAuthIntegrationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OAuthIntegrationCreateManyUserInputEnvelope
    set?: OAuthIntegrationWhereUniqueInput | OAuthIntegrationWhereUniqueInput[]
    disconnect?: OAuthIntegrationWhereUniqueInput | OAuthIntegrationWhereUniqueInput[]
    delete?: OAuthIntegrationWhereUniqueInput | OAuthIntegrationWhereUniqueInput[]
    connect?: OAuthIntegrationWhereUniqueInput | OAuthIntegrationWhereUniqueInput[]
    update?: OAuthIntegrationUpdateWithWhereUniqueWithoutUserInput | OAuthIntegrationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OAuthIntegrationUpdateManyWithWhereWithoutUserInput | OAuthIntegrationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OAuthIntegrationScalarWhereInput | OAuthIntegrationScalarWhereInput[]
  }

  export type EventUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<EventCreateWithoutCreatedByInput, EventUncheckedCreateWithoutCreatedByInput> | EventCreateWithoutCreatedByInput[] | EventUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: EventCreateOrConnectWithoutCreatedByInput | EventCreateOrConnectWithoutCreatedByInput[]
    upsert?: EventUpsertWithWhereUniqueWithoutCreatedByInput | EventUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: EventCreateManyCreatedByInputEnvelope
    set?: EventWhereUniqueInput | EventWhereUniqueInput[]
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    update?: EventUpdateWithWhereUniqueWithoutCreatedByInput | EventUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: EventUpdateManyWithWhereWithoutCreatedByInput | EventUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[]
  }

  export type ChoreSwapRequestUncheckedUpdateManyWithoutRequestingUserNestedInput = {
    create?: XOR<ChoreSwapRequestCreateWithoutRequestingUserInput, ChoreSwapRequestUncheckedCreateWithoutRequestingUserInput> | ChoreSwapRequestCreateWithoutRequestingUserInput[] | ChoreSwapRequestUncheckedCreateWithoutRequestingUserInput[]
    connectOrCreate?: ChoreSwapRequestCreateOrConnectWithoutRequestingUserInput | ChoreSwapRequestCreateOrConnectWithoutRequestingUserInput[]
    upsert?: ChoreSwapRequestUpsertWithWhereUniqueWithoutRequestingUserInput | ChoreSwapRequestUpsertWithWhereUniqueWithoutRequestingUserInput[]
    createMany?: ChoreSwapRequestCreateManyRequestingUserInputEnvelope
    set?: ChoreSwapRequestWhereUniqueInput | ChoreSwapRequestWhereUniqueInput[]
    disconnect?: ChoreSwapRequestWhereUniqueInput | ChoreSwapRequestWhereUniqueInput[]
    delete?: ChoreSwapRequestWhereUniqueInput | ChoreSwapRequestWhereUniqueInput[]
    connect?: ChoreSwapRequestWhereUniqueInput | ChoreSwapRequestWhereUniqueInput[]
    update?: ChoreSwapRequestUpdateWithWhereUniqueWithoutRequestingUserInput | ChoreSwapRequestUpdateWithWhereUniqueWithoutRequestingUserInput[]
    updateMany?: ChoreSwapRequestUpdateManyWithWhereWithoutRequestingUserInput | ChoreSwapRequestUpdateManyWithWhereWithoutRequestingUserInput[]
    deleteMany?: ChoreSwapRequestScalarWhereInput | ChoreSwapRequestScalarWhereInput[]
  }

  export type ChoreSwapRequestUncheckedUpdateManyWithoutTargetUserNestedInput = {
    create?: XOR<ChoreSwapRequestCreateWithoutTargetUserInput, ChoreSwapRequestUncheckedCreateWithoutTargetUserInput> | ChoreSwapRequestCreateWithoutTargetUserInput[] | ChoreSwapRequestUncheckedCreateWithoutTargetUserInput[]
    connectOrCreate?: ChoreSwapRequestCreateOrConnectWithoutTargetUserInput | ChoreSwapRequestCreateOrConnectWithoutTargetUserInput[]
    upsert?: ChoreSwapRequestUpsertWithWhereUniqueWithoutTargetUserInput | ChoreSwapRequestUpsertWithWhereUniqueWithoutTargetUserInput[]
    createMany?: ChoreSwapRequestCreateManyTargetUserInputEnvelope
    set?: ChoreSwapRequestWhereUniqueInput | ChoreSwapRequestWhereUniqueInput[]
    disconnect?: ChoreSwapRequestWhereUniqueInput | ChoreSwapRequestWhereUniqueInput[]
    delete?: ChoreSwapRequestWhereUniqueInput | ChoreSwapRequestWhereUniqueInput[]
    connect?: ChoreSwapRequestWhereUniqueInput | ChoreSwapRequestWhereUniqueInput[]
    update?: ChoreSwapRequestUpdateWithWhereUniqueWithoutTargetUserInput | ChoreSwapRequestUpdateWithWhereUniqueWithoutTargetUserInput[]
    updateMany?: ChoreSwapRequestUpdateManyWithWhereWithoutTargetUserInput | ChoreSwapRequestUpdateManyWithWhereWithoutTargetUserInput[]
    deleteMany?: ChoreSwapRequestScalarWhereInput | ChoreSwapRequestScalarWhereInput[]
  }

  export type ReactionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReactionCreateWithoutUserInput, ReactionUncheckedCreateWithoutUserInput> | ReactionCreateWithoutUserInput[] | ReactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReactionCreateOrConnectWithoutUserInput | ReactionCreateOrConnectWithoutUserInput[]
    upsert?: ReactionUpsertWithWhereUniqueWithoutUserInput | ReactionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReactionCreateManyUserInputEnvelope
    set?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
    disconnect?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
    delete?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
    connect?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
    update?: ReactionUpdateWithWhereUniqueWithoutUserInput | ReactionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReactionUpdateManyWithWhereWithoutUserInput | ReactionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReactionScalarWhereInput | ReactionScalarWhereInput[]
  }

  export type MentionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MentionCreateWithoutUserInput, MentionUncheckedCreateWithoutUserInput> | MentionCreateWithoutUserInput[] | MentionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MentionCreateOrConnectWithoutUserInput | MentionCreateOrConnectWithoutUserInput[]
    upsert?: MentionUpsertWithWhereUniqueWithoutUserInput | MentionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MentionCreateManyUserInputEnvelope
    set?: MentionWhereUniqueInput | MentionWhereUniqueInput[]
    disconnect?: MentionWhereUniqueInput | MentionWhereUniqueInput[]
    delete?: MentionWhereUniqueInput | MentionWhereUniqueInput[]
    connect?: MentionWhereUniqueInput | MentionWhereUniqueInput[]
    update?: MentionUpdateWithWhereUniqueWithoutUserInput | MentionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MentionUpdateManyWithWhereWithoutUserInput | MentionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MentionScalarWhereInput | MentionScalarWhereInput[]
  }

  export type ChoreHistoryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ChoreHistoryCreateWithoutUserInput, ChoreHistoryUncheckedCreateWithoutUserInput> | ChoreHistoryCreateWithoutUserInput[] | ChoreHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChoreHistoryCreateOrConnectWithoutUserInput | ChoreHistoryCreateOrConnectWithoutUserInput[]
    upsert?: ChoreHistoryUpsertWithWhereUniqueWithoutUserInput | ChoreHistoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ChoreHistoryCreateManyUserInputEnvelope
    set?: ChoreHistoryWhereUniqueInput | ChoreHistoryWhereUniqueInput[]
    disconnect?: ChoreHistoryWhereUniqueInput | ChoreHistoryWhereUniqueInput[]
    delete?: ChoreHistoryWhereUniqueInput | ChoreHistoryWhereUniqueInput[]
    connect?: ChoreHistoryWhereUniqueInput | ChoreHistoryWhereUniqueInput[]
    update?: ChoreHistoryUpdateWithWhereUniqueWithoutUserInput | ChoreHistoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ChoreHistoryUpdateManyWithWhereWithoutUserInput | ChoreHistoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ChoreHistoryScalarWhereInput | ChoreHistoryScalarWhereInput[]
  }

  export type NotificationSettingsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationSettingsCreateWithoutUserInput, NotificationSettingsUncheckedCreateWithoutUserInput> | NotificationSettingsCreateWithoutUserInput[] | NotificationSettingsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationSettingsCreateOrConnectWithoutUserInput | NotificationSettingsCreateOrConnectWithoutUserInput[]
    upsert?: NotificationSettingsUpsertWithWhereUniqueWithoutUserInput | NotificationSettingsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationSettingsCreateManyUserInputEnvelope
    set?: NotificationSettingsWhereUniqueInput | NotificationSettingsWhereUniqueInput[]
    disconnect?: NotificationSettingsWhereUniqueInput | NotificationSettingsWhereUniqueInput[]
    delete?: NotificationSettingsWhereUniqueInput | NotificationSettingsWhereUniqueInput[]
    connect?: NotificationSettingsWhereUniqueInput | NotificationSettingsWhereUniqueInput[]
    update?: NotificationSettingsUpdateWithWhereUniqueWithoutUserInput | NotificationSettingsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationSettingsUpdateManyWithWhereWithoutUserInput | NotificationSettingsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationSettingsScalarWhereInput | NotificationSettingsScalarWhereInput[]
  }

  export type CalendarEventHistoryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CalendarEventHistoryCreateWithoutUserInput, CalendarEventHistoryUncheckedCreateWithoutUserInput> | CalendarEventHistoryCreateWithoutUserInput[] | CalendarEventHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CalendarEventHistoryCreateOrConnectWithoutUserInput | CalendarEventHistoryCreateOrConnectWithoutUserInput[]
    upsert?: CalendarEventHistoryUpsertWithWhereUniqueWithoutUserInput | CalendarEventHistoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CalendarEventHistoryCreateManyUserInputEnvelope
    set?: CalendarEventHistoryWhereUniqueInput | CalendarEventHistoryWhereUniqueInput[]
    disconnect?: CalendarEventHistoryWhereUniqueInput | CalendarEventHistoryWhereUniqueInput[]
    delete?: CalendarEventHistoryWhereUniqueInput | CalendarEventHistoryWhereUniqueInput[]
    connect?: CalendarEventHistoryWhereUniqueInput | CalendarEventHistoryWhereUniqueInput[]
    update?: CalendarEventHistoryUpdateWithWhereUniqueWithoutUserInput | CalendarEventHistoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CalendarEventHistoryUpdateManyWithWhereWithoutUserInput | CalendarEventHistoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CalendarEventHistoryScalarWhereInput | CalendarEventHistoryScalarWhereInput[]
  }

  export type ExpenseHistoryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ExpenseHistoryCreateWithoutUserInput, ExpenseHistoryUncheckedCreateWithoutUserInput> | ExpenseHistoryCreateWithoutUserInput[] | ExpenseHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ExpenseHistoryCreateOrConnectWithoutUserInput | ExpenseHistoryCreateOrConnectWithoutUserInput[]
    upsert?: ExpenseHistoryUpsertWithWhereUniqueWithoutUserInput | ExpenseHistoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ExpenseHistoryCreateManyUserInputEnvelope
    set?: ExpenseHistoryWhereUniqueInput | ExpenseHistoryWhereUniqueInput[]
    disconnect?: ExpenseHistoryWhereUniqueInput | ExpenseHistoryWhereUniqueInput[]
    delete?: ExpenseHistoryWhereUniqueInput | ExpenseHistoryWhereUniqueInput[]
    connect?: ExpenseHistoryWhereUniqueInput | ExpenseHistoryWhereUniqueInput[]
    update?: ExpenseHistoryUpdateWithWhereUniqueWithoutUserInput | ExpenseHistoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ExpenseHistoryUpdateManyWithWhereWithoutUserInput | ExpenseHistoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ExpenseHistoryScalarWhereInput | ExpenseHistoryScalarWhereInput[]
  }

  export type MessageReadUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MessageReadCreateWithoutUserInput, MessageReadUncheckedCreateWithoutUserInput> | MessageReadCreateWithoutUserInput[] | MessageReadUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MessageReadCreateOrConnectWithoutUserInput | MessageReadCreateOrConnectWithoutUserInput[]
    upsert?: MessageReadUpsertWithWhereUniqueWithoutUserInput | MessageReadUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MessageReadCreateManyUserInputEnvelope
    set?: MessageReadWhereUniqueInput | MessageReadWhereUniqueInput[]
    disconnect?: MessageReadWhereUniqueInput | MessageReadWhereUniqueInput[]
    delete?: MessageReadWhereUniqueInput | MessageReadWhereUniqueInput[]
    connect?: MessageReadWhereUniqueInput | MessageReadWhereUniqueInput[]
    update?: MessageReadUpdateWithWhereUniqueWithoutUserInput | MessageReadUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MessageReadUpdateManyWithWhereWithoutUserInput | MessageReadUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MessageReadScalarWhereInput | MessageReadScalarWhereInput[]
  }

  export type HouseholdMemberCreateNestedManyWithoutHouseholdInput = {
    create?: XOR<HouseholdMemberCreateWithoutHouseholdInput, HouseholdMemberUncheckedCreateWithoutHouseholdInput> | HouseholdMemberCreateWithoutHouseholdInput[] | HouseholdMemberUncheckedCreateWithoutHouseholdInput[]
    connectOrCreate?: HouseholdMemberCreateOrConnectWithoutHouseholdInput | HouseholdMemberCreateOrConnectWithoutHouseholdInput[]
    createMany?: HouseholdMemberCreateManyHouseholdInputEnvelope
    connect?: HouseholdMemberWhereUniqueInput | HouseholdMemberWhereUniqueInput[]
  }

  export type ThreadCreateNestedManyWithoutHouseholdInput = {
    create?: XOR<ThreadCreateWithoutHouseholdInput, ThreadUncheckedCreateWithoutHouseholdInput> | ThreadCreateWithoutHouseholdInput[] | ThreadUncheckedCreateWithoutHouseholdInput[]
    connectOrCreate?: ThreadCreateOrConnectWithoutHouseholdInput | ThreadCreateOrConnectWithoutHouseholdInput[]
    createMany?: ThreadCreateManyHouseholdInputEnvelope
    connect?: ThreadWhereUniqueInput | ThreadWhereUniqueInput[]
  }

  export type ChoreCreateNestedManyWithoutHouseholdInput = {
    create?: XOR<ChoreCreateWithoutHouseholdInput, ChoreUncheckedCreateWithoutHouseholdInput> | ChoreCreateWithoutHouseholdInput[] | ChoreUncheckedCreateWithoutHouseholdInput[]
    connectOrCreate?: ChoreCreateOrConnectWithoutHouseholdInput | ChoreCreateOrConnectWithoutHouseholdInput[]
    createMany?: ChoreCreateManyHouseholdInputEnvelope
    connect?: ChoreWhereUniqueInput | ChoreWhereUniqueInput[]
  }

  export type ExpenseCreateNestedManyWithoutHouseholdInput = {
    create?: XOR<ExpenseCreateWithoutHouseholdInput, ExpenseUncheckedCreateWithoutHouseholdInput> | ExpenseCreateWithoutHouseholdInput[] | ExpenseUncheckedCreateWithoutHouseholdInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutHouseholdInput | ExpenseCreateOrConnectWithoutHouseholdInput[]
    createMany?: ExpenseCreateManyHouseholdInputEnvelope
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
  }

  export type EventCreateNestedManyWithoutHouseholdInput = {
    create?: XOR<EventCreateWithoutHouseholdInput, EventUncheckedCreateWithoutHouseholdInput> | EventCreateWithoutHouseholdInput[] | EventUncheckedCreateWithoutHouseholdInput[]
    connectOrCreate?: EventCreateOrConnectWithoutHouseholdInput | EventCreateOrConnectWithoutHouseholdInput[]
    createMany?: EventCreateManyHouseholdInputEnvelope
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
  }

  export type ChoreTemplateCreateNestedManyWithoutHouseholdInput = {
    create?: XOR<ChoreTemplateCreateWithoutHouseholdInput, ChoreTemplateUncheckedCreateWithoutHouseholdInput> | ChoreTemplateCreateWithoutHouseholdInput[] | ChoreTemplateUncheckedCreateWithoutHouseholdInput[]
    connectOrCreate?: ChoreTemplateCreateOrConnectWithoutHouseholdInput | ChoreTemplateCreateOrConnectWithoutHouseholdInput[]
    createMany?: ChoreTemplateCreateManyHouseholdInputEnvelope
    connect?: ChoreTemplateWhereUniqueInput | ChoreTemplateWhereUniqueInput[]
  }

  export type NotificationSettingsCreateNestedManyWithoutHouseholdInput = {
    create?: XOR<NotificationSettingsCreateWithoutHouseholdInput, NotificationSettingsUncheckedCreateWithoutHouseholdInput> | NotificationSettingsCreateWithoutHouseholdInput[] | NotificationSettingsUncheckedCreateWithoutHouseholdInput[]
    connectOrCreate?: NotificationSettingsCreateOrConnectWithoutHouseholdInput | NotificationSettingsCreateOrConnectWithoutHouseholdInput[]
    createMany?: NotificationSettingsCreateManyHouseholdInputEnvelope
    connect?: NotificationSettingsWhereUniqueInput | NotificationSettingsWhereUniqueInput[]
  }

  export type HouseholdMemberUncheckedCreateNestedManyWithoutHouseholdInput = {
    create?: XOR<HouseholdMemberCreateWithoutHouseholdInput, HouseholdMemberUncheckedCreateWithoutHouseholdInput> | HouseholdMemberCreateWithoutHouseholdInput[] | HouseholdMemberUncheckedCreateWithoutHouseholdInput[]
    connectOrCreate?: HouseholdMemberCreateOrConnectWithoutHouseholdInput | HouseholdMemberCreateOrConnectWithoutHouseholdInput[]
    createMany?: HouseholdMemberCreateManyHouseholdInputEnvelope
    connect?: HouseholdMemberWhereUniqueInput | HouseholdMemberWhereUniqueInput[]
  }

  export type ThreadUncheckedCreateNestedManyWithoutHouseholdInput = {
    create?: XOR<ThreadCreateWithoutHouseholdInput, ThreadUncheckedCreateWithoutHouseholdInput> | ThreadCreateWithoutHouseholdInput[] | ThreadUncheckedCreateWithoutHouseholdInput[]
    connectOrCreate?: ThreadCreateOrConnectWithoutHouseholdInput | ThreadCreateOrConnectWithoutHouseholdInput[]
    createMany?: ThreadCreateManyHouseholdInputEnvelope
    connect?: ThreadWhereUniqueInput | ThreadWhereUniqueInput[]
  }

  export type ChoreUncheckedCreateNestedManyWithoutHouseholdInput = {
    create?: XOR<ChoreCreateWithoutHouseholdInput, ChoreUncheckedCreateWithoutHouseholdInput> | ChoreCreateWithoutHouseholdInput[] | ChoreUncheckedCreateWithoutHouseholdInput[]
    connectOrCreate?: ChoreCreateOrConnectWithoutHouseholdInput | ChoreCreateOrConnectWithoutHouseholdInput[]
    createMany?: ChoreCreateManyHouseholdInputEnvelope
    connect?: ChoreWhereUniqueInput | ChoreWhereUniqueInput[]
  }

  export type ExpenseUncheckedCreateNestedManyWithoutHouseholdInput = {
    create?: XOR<ExpenseCreateWithoutHouseholdInput, ExpenseUncheckedCreateWithoutHouseholdInput> | ExpenseCreateWithoutHouseholdInput[] | ExpenseUncheckedCreateWithoutHouseholdInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutHouseholdInput | ExpenseCreateOrConnectWithoutHouseholdInput[]
    createMany?: ExpenseCreateManyHouseholdInputEnvelope
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
  }

  export type EventUncheckedCreateNestedManyWithoutHouseholdInput = {
    create?: XOR<EventCreateWithoutHouseholdInput, EventUncheckedCreateWithoutHouseholdInput> | EventCreateWithoutHouseholdInput[] | EventUncheckedCreateWithoutHouseholdInput[]
    connectOrCreate?: EventCreateOrConnectWithoutHouseholdInput | EventCreateOrConnectWithoutHouseholdInput[]
    createMany?: EventCreateManyHouseholdInputEnvelope
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
  }

  export type ChoreTemplateUncheckedCreateNestedManyWithoutHouseholdInput = {
    create?: XOR<ChoreTemplateCreateWithoutHouseholdInput, ChoreTemplateUncheckedCreateWithoutHouseholdInput> | ChoreTemplateCreateWithoutHouseholdInput[] | ChoreTemplateUncheckedCreateWithoutHouseholdInput[]
    connectOrCreate?: ChoreTemplateCreateOrConnectWithoutHouseholdInput | ChoreTemplateCreateOrConnectWithoutHouseholdInput[]
    createMany?: ChoreTemplateCreateManyHouseholdInputEnvelope
    connect?: ChoreTemplateWhereUniqueInput | ChoreTemplateWhereUniqueInput[]
  }

  export type NotificationSettingsUncheckedCreateNestedManyWithoutHouseholdInput = {
    create?: XOR<NotificationSettingsCreateWithoutHouseholdInput, NotificationSettingsUncheckedCreateWithoutHouseholdInput> | NotificationSettingsCreateWithoutHouseholdInput[] | NotificationSettingsUncheckedCreateWithoutHouseholdInput[]
    connectOrCreate?: NotificationSettingsCreateOrConnectWithoutHouseholdInput | NotificationSettingsCreateOrConnectWithoutHouseholdInput[]
    createMany?: NotificationSettingsCreateManyHouseholdInputEnvelope
    connect?: NotificationSettingsWhereUniqueInput | NotificationSettingsWhereUniqueInput[]
  }

  export type HouseholdMemberUpdateManyWithoutHouseholdNestedInput = {
    create?: XOR<HouseholdMemberCreateWithoutHouseholdInput, HouseholdMemberUncheckedCreateWithoutHouseholdInput> | HouseholdMemberCreateWithoutHouseholdInput[] | HouseholdMemberUncheckedCreateWithoutHouseholdInput[]
    connectOrCreate?: HouseholdMemberCreateOrConnectWithoutHouseholdInput | HouseholdMemberCreateOrConnectWithoutHouseholdInput[]
    upsert?: HouseholdMemberUpsertWithWhereUniqueWithoutHouseholdInput | HouseholdMemberUpsertWithWhereUniqueWithoutHouseholdInput[]
    createMany?: HouseholdMemberCreateManyHouseholdInputEnvelope
    set?: HouseholdMemberWhereUniqueInput | HouseholdMemberWhereUniqueInput[]
    disconnect?: HouseholdMemberWhereUniqueInput | HouseholdMemberWhereUniqueInput[]
    delete?: HouseholdMemberWhereUniqueInput | HouseholdMemberWhereUniqueInput[]
    connect?: HouseholdMemberWhereUniqueInput | HouseholdMemberWhereUniqueInput[]
    update?: HouseholdMemberUpdateWithWhereUniqueWithoutHouseholdInput | HouseholdMemberUpdateWithWhereUniqueWithoutHouseholdInput[]
    updateMany?: HouseholdMemberUpdateManyWithWhereWithoutHouseholdInput | HouseholdMemberUpdateManyWithWhereWithoutHouseholdInput[]
    deleteMany?: HouseholdMemberScalarWhereInput | HouseholdMemberScalarWhereInput[]
  }

  export type ThreadUpdateManyWithoutHouseholdNestedInput = {
    create?: XOR<ThreadCreateWithoutHouseholdInput, ThreadUncheckedCreateWithoutHouseholdInput> | ThreadCreateWithoutHouseholdInput[] | ThreadUncheckedCreateWithoutHouseholdInput[]
    connectOrCreate?: ThreadCreateOrConnectWithoutHouseholdInput | ThreadCreateOrConnectWithoutHouseholdInput[]
    upsert?: ThreadUpsertWithWhereUniqueWithoutHouseholdInput | ThreadUpsertWithWhereUniqueWithoutHouseholdInput[]
    createMany?: ThreadCreateManyHouseholdInputEnvelope
    set?: ThreadWhereUniqueInput | ThreadWhereUniqueInput[]
    disconnect?: ThreadWhereUniqueInput | ThreadWhereUniqueInput[]
    delete?: ThreadWhereUniqueInput | ThreadWhereUniqueInput[]
    connect?: ThreadWhereUniqueInput | ThreadWhereUniqueInput[]
    update?: ThreadUpdateWithWhereUniqueWithoutHouseholdInput | ThreadUpdateWithWhereUniqueWithoutHouseholdInput[]
    updateMany?: ThreadUpdateManyWithWhereWithoutHouseholdInput | ThreadUpdateManyWithWhereWithoutHouseholdInput[]
    deleteMany?: ThreadScalarWhereInput | ThreadScalarWhereInput[]
  }

  export type ChoreUpdateManyWithoutHouseholdNestedInput = {
    create?: XOR<ChoreCreateWithoutHouseholdInput, ChoreUncheckedCreateWithoutHouseholdInput> | ChoreCreateWithoutHouseholdInput[] | ChoreUncheckedCreateWithoutHouseholdInput[]
    connectOrCreate?: ChoreCreateOrConnectWithoutHouseholdInput | ChoreCreateOrConnectWithoutHouseholdInput[]
    upsert?: ChoreUpsertWithWhereUniqueWithoutHouseholdInput | ChoreUpsertWithWhereUniqueWithoutHouseholdInput[]
    createMany?: ChoreCreateManyHouseholdInputEnvelope
    set?: ChoreWhereUniqueInput | ChoreWhereUniqueInput[]
    disconnect?: ChoreWhereUniqueInput | ChoreWhereUniqueInput[]
    delete?: ChoreWhereUniqueInput | ChoreWhereUniqueInput[]
    connect?: ChoreWhereUniqueInput | ChoreWhereUniqueInput[]
    update?: ChoreUpdateWithWhereUniqueWithoutHouseholdInput | ChoreUpdateWithWhereUniqueWithoutHouseholdInput[]
    updateMany?: ChoreUpdateManyWithWhereWithoutHouseholdInput | ChoreUpdateManyWithWhereWithoutHouseholdInput[]
    deleteMany?: ChoreScalarWhereInput | ChoreScalarWhereInput[]
  }

  export type ExpenseUpdateManyWithoutHouseholdNestedInput = {
    create?: XOR<ExpenseCreateWithoutHouseholdInput, ExpenseUncheckedCreateWithoutHouseholdInput> | ExpenseCreateWithoutHouseholdInput[] | ExpenseUncheckedCreateWithoutHouseholdInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutHouseholdInput | ExpenseCreateOrConnectWithoutHouseholdInput[]
    upsert?: ExpenseUpsertWithWhereUniqueWithoutHouseholdInput | ExpenseUpsertWithWhereUniqueWithoutHouseholdInput[]
    createMany?: ExpenseCreateManyHouseholdInputEnvelope
    set?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    disconnect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    delete?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    update?: ExpenseUpdateWithWhereUniqueWithoutHouseholdInput | ExpenseUpdateWithWhereUniqueWithoutHouseholdInput[]
    updateMany?: ExpenseUpdateManyWithWhereWithoutHouseholdInput | ExpenseUpdateManyWithWhereWithoutHouseholdInput[]
    deleteMany?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
  }

  export type EventUpdateManyWithoutHouseholdNestedInput = {
    create?: XOR<EventCreateWithoutHouseholdInput, EventUncheckedCreateWithoutHouseholdInput> | EventCreateWithoutHouseholdInput[] | EventUncheckedCreateWithoutHouseholdInput[]
    connectOrCreate?: EventCreateOrConnectWithoutHouseholdInput | EventCreateOrConnectWithoutHouseholdInput[]
    upsert?: EventUpsertWithWhereUniqueWithoutHouseholdInput | EventUpsertWithWhereUniqueWithoutHouseholdInput[]
    createMany?: EventCreateManyHouseholdInputEnvelope
    set?: EventWhereUniqueInput | EventWhereUniqueInput[]
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    update?: EventUpdateWithWhereUniqueWithoutHouseholdInput | EventUpdateWithWhereUniqueWithoutHouseholdInput[]
    updateMany?: EventUpdateManyWithWhereWithoutHouseholdInput | EventUpdateManyWithWhereWithoutHouseholdInput[]
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[]
  }

  export type ChoreTemplateUpdateManyWithoutHouseholdNestedInput = {
    create?: XOR<ChoreTemplateCreateWithoutHouseholdInput, ChoreTemplateUncheckedCreateWithoutHouseholdInput> | ChoreTemplateCreateWithoutHouseholdInput[] | ChoreTemplateUncheckedCreateWithoutHouseholdInput[]
    connectOrCreate?: ChoreTemplateCreateOrConnectWithoutHouseholdInput | ChoreTemplateCreateOrConnectWithoutHouseholdInput[]
    upsert?: ChoreTemplateUpsertWithWhereUniqueWithoutHouseholdInput | ChoreTemplateUpsertWithWhereUniqueWithoutHouseholdInput[]
    createMany?: ChoreTemplateCreateManyHouseholdInputEnvelope
    set?: ChoreTemplateWhereUniqueInput | ChoreTemplateWhereUniqueInput[]
    disconnect?: ChoreTemplateWhereUniqueInput | ChoreTemplateWhereUniqueInput[]
    delete?: ChoreTemplateWhereUniqueInput | ChoreTemplateWhereUniqueInput[]
    connect?: ChoreTemplateWhereUniqueInput | ChoreTemplateWhereUniqueInput[]
    update?: ChoreTemplateUpdateWithWhereUniqueWithoutHouseholdInput | ChoreTemplateUpdateWithWhereUniqueWithoutHouseholdInput[]
    updateMany?: ChoreTemplateUpdateManyWithWhereWithoutHouseholdInput | ChoreTemplateUpdateManyWithWhereWithoutHouseholdInput[]
    deleteMany?: ChoreTemplateScalarWhereInput | ChoreTemplateScalarWhereInput[]
  }

  export type NotificationSettingsUpdateManyWithoutHouseholdNestedInput = {
    create?: XOR<NotificationSettingsCreateWithoutHouseholdInput, NotificationSettingsUncheckedCreateWithoutHouseholdInput> | NotificationSettingsCreateWithoutHouseholdInput[] | NotificationSettingsUncheckedCreateWithoutHouseholdInput[]
    connectOrCreate?: NotificationSettingsCreateOrConnectWithoutHouseholdInput | NotificationSettingsCreateOrConnectWithoutHouseholdInput[]
    upsert?: NotificationSettingsUpsertWithWhereUniqueWithoutHouseholdInput | NotificationSettingsUpsertWithWhereUniqueWithoutHouseholdInput[]
    createMany?: NotificationSettingsCreateManyHouseholdInputEnvelope
    set?: NotificationSettingsWhereUniqueInput | NotificationSettingsWhereUniqueInput[]
    disconnect?: NotificationSettingsWhereUniqueInput | NotificationSettingsWhereUniqueInput[]
    delete?: NotificationSettingsWhereUniqueInput | NotificationSettingsWhereUniqueInput[]
    connect?: NotificationSettingsWhereUniqueInput | NotificationSettingsWhereUniqueInput[]
    update?: NotificationSettingsUpdateWithWhereUniqueWithoutHouseholdInput | NotificationSettingsUpdateWithWhereUniqueWithoutHouseholdInput[]
    updateMany?: NotificationSettingsUpdateManyWithWhereWithoutHouseholdInput | NotificationSettingsUpdateManyWithWhereWithoutHouseholdInput[]
    deleteMany?: NotificationSettingsScalarWhereInput | NotificationSettingsScalarWhereInput[]
  }

  export type HouseholdMemberUncheckedUpdateManyWithoutHouseholdNestedInput = {
    create?: XOR<HouseholdMemberCreateWithoutHouseholdInput, HouseholdMemberUncheckedCreateWithoutHouseholdInput> | HouseholdMemberCreateWithoutHouseholdInput[] | HouseholdMemberUncheckedCreateWithoutHouseholdInput[]
    connectOrCreate?: HouseholdMemberCreateOrConnectWithoutHouseholdInput | HouseholdMemberCreateOrConnectWithoutHouseholdInput[]
    upsert?: HouseholdMemberUpsertWithWhereUniqueWithoutHouseholdInput | HouseholdMemberUpsertWithWhereUniqueWithoutHouseholdInput[]
    createMany?: HouseholdMemberCreateManyHouseholdInputEnvelope
    set?: HouseholdMemberWhereUniqueInput | HouseholdMemberWhereUniqueInput[]
    disconnect?: HouseholdMemberWhereUniqueInput | HouseholdMemberWhereUniqueInput[]
    delete?: HouseholdMemberWhereUniqueInput | HouseholdMemberWhereUniqueInput[]
    connect?: HouseholdMemberWhereUniqueInput | HouseholdMemberWhereUniqueInput[]
    update?: HouseholdMemberUpdateWithWhereUniqueWithoutHouseholdInput | HouseholdMemberUpdateWithWhereUniqueWithoutHouseholdInput[]
    updateMany?: HouseholdMemberUpdateManyWithWhereWithoutHouseholdInput | HouseholdMemberUpdateManyWithWhereWithoutHouseholdInput[]
    deleteMany?: HouseholdMemberScalarWhereInput | HouseholdMemberScalarWhereInput[]
  }

  export type ThreadUncheckedUpdateManyWithoutHouseholdNestedInput = {
    create?: XOR<ThreadCreateWithoutHouseholdInput, ThreadUncheckedCreateWithoutHouseholdInput> | ThreadCreateWithoutHouseholdInput[] | ThreadUncheckedCreateWithoutHouseholdInput[]
    connectOrCreate?: ThreadCreateOrConnectWithoutHouseholdInput | ThreadCreateOrConnectWithoutHouseholdInput[]
    upsert?: ThreadUpsertWithWhereUniqueWithoutHouseholdInput | ThreadUpsertWithWhereUniqueWithoutHouseholdInput[]
    createMany?: ThreadCreateManyHouseholdInputEnvelope
    set?: ThreadWhereUniqueInput | ThreadWhereUniqueInput[]
    disconnect?: ThreadWhereUniqueInput | ThreadWhereUniqueInput[]
    delete?: ThreadWhereUniqueInput | ThreadWhereUniqueInput[]
    connect?: ThreadWhereUniqueInput | ThreadWhereUniqueInput[]
    update?: ThreadUpdateWithWhereUniqueWithoutHouseholdInput | ThreadUpdateWithWhereUniqueWithoutHouseholdInput[]
    updateMany?: ThreadUpdateManyWithWhereWithoutHouseholdInput | ThreadUpdateManyWithWhereWithoutHouseholdInput[]
    deleteMany?: ThreadScalarWhereInput | ThreadScalarWhereInput[]
  }

  export type ChoreUncheckedUpdateManyWithoutHouseholdNestedInput = {
    create?: XOR<ChoreCreateWithoutHouseholdInput, ChoreUncheckedCreateWithoutHouseholdInput> | ChoreCreateWithoutHouseholdInput[] | ChoreUncheckedCreateWithoutHouseholdInput[]
    connectOrCreate?: ChoreCreateOrConnectWithoutHouseholdInput | ChoreCreateOrConnectWithoutHouseholdInput[]
    upsert?: ChoreUpsertWithWhereUniqueWithoutHouseholdInput | ChoreUpsertWithWhereUniqueWithoutHouseholdInput[]
    createMany?: ChoreCreateManyHouseholdInputEnvelope
    set?: ChoreWhereUniqueInput | ChoreWhereUniqueInput[]
    disconnect?: ChoreWhereUniqueInput | ChoreWhereUniqueInput[]
    delete?: ChoreWhereUniqueInput | ChoreWhereUniqueInput[]
    connect?: ChoreWhereUniqueInput | ChoreWhereUniqueInput[]
    update?: ChoreUpdateWithWhereUniqueWithoutHouseholdInput | ChoreUpdateWithWhereUniqueWithoutHouseholdInput[]
    updateMany?: ChoreUpdateManyWithWhereWithoutHouseholdInput | ChoreUpdateManyWithWhereWithoutHouseholdInput[]
    deleteMany?: ChoreScalarWhereInput | ChoreScalarWhereInput[]
  }

  export type ExpenseUncheckedUpdateManyWithoutHouseholdNestedInput = {
    create?: XOR<ExpenseCreateWithoutHouseholdInput, ExpenseUncheckedCreateWithoutHouseholdInput> | ExpenseCreateWithoutHouseholdInput[] | ExpenseUncheckedCreateWithoutHouseholdInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutHouseholdInput | ExpenseCreateOrConnectWithoutHouseholdInput[]
    upsert?: ExpenseUpsertWithWhereUniqueWithoutHouseholdInput | ExpenseUpsertWithWhereUniqueWithoutHouseholdInput[]
    createMany?: ExpenseCreateManyHouseholdInputEnvelope
    set?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    disconnect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    delete?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    update?: ExpenseUpdateWithWhereUniqueWithoutHouseholdInput | ExpenseUpdateWithWhereUniqueWithoutHouseholdInput[]
    updateMany?: ExpenseUpdateManyWithWhereWithoutHouseholdInput | ExpenseUpdateManyWithWhereWithoutHouseholdInput[]
    deleteMany?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
  }

  export type EventUncheckedUpdateManyWithoutHouseholdNestedInput = {
    create?: XOR<EventCreateWithoutHouseholdInput, EventUncheckedCreateWithoutHouseholdInput> | EventCreateWithoutHouseholdInput[] | EventUncheckedCreateWithoutHouseholdInput[]
    connectOrCreate?: EventCreateOrConnectWithoutHouseholdInput | EventCreateOrConnectWithoutHouseholdInput[]
    upsert?: EventUpsertWithWhereUniqueWithoutHouseholdInput | EventUpsertWithWhereUniqueWithoutHouseholdInput[]
    createMany?: EventCreateManyHouseholdInputEnvelope
    set?: EventWhereUniqueInput | EventWhereUniqueInput[]
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    update?: EventUpdateWithWhereUniqueWithoutHouseholdInput | EventUpdateWithWhereUniqueWithoutHouseholdInput[]
    updateMany?: EventUpdateManyWithWhereWithoutHouseholdInput | EventUpdateManyWithWhereWithoutHouseholdInput[]
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[]
  }

  export type ChoreTemplateUncheckedUpdateManyWithoutHouseholdNestedInput = {
    create?: XOR<ChoreTemplateCreateWithoutHouseholdInput, ChoreTemplateUncheckedCreateWithoutHouseholdInput> | ChoreTemplateCreateWithoutHouseholdInput[] | ChoreTemplateUncheckedCreateWithoutHouseholdInput[]
    connectOrCreate?: ChoreTemplateCreateOrConnectWithoutHouseholdInput | ChoreTemplateCreateOrConnectWithoutHouseholdInput[]
    upsert?: ChoreTemplateUpsertWithWhereUniqueWithoutHouseholdInput | ChoreTemplateUpsertWithWhereUniqueWithoutHouseholdInput[]
    createMany?: ChoreTemplateCreateManyHouseholdInputEnvelope
    set?: ChoreTemplateWhereUniqueInput | ChoreTemplateWhereUniqueInput[]
    disconnect?: ChoreTemplateWhereUniqueInput | ChoreTemplateWhereUniqueInput[]
    delete?: ChoreTemplateWhereUniqueInput | ChoreTemplateWhereUniqueInput[]
    connect?: ChoreTemplateWhereUniqueInput | ChoreTemplateWhereUniqueInput[]
    update?: ChoreTemplateUpdateWithWhereUniqueWithoutHouseholdInput | ChoreTemplateUpdateWithWhereUniqueWithoutHouseholdInput[]
    updateMany?: ChoreTemplateUpdateManyWithWhereWithoutHouseholdInput | ChoreTemplateUpdateManyWithWhereWithoutHouseholdInput[]
    deleteMany?: ChoreTemplateScalarWhereInput | ChoreTemplateScalarWhereInput[]
  }

  export type NotificationSettingsUncheckedUpdateManyWithoutHouseholdNestedInput = {
    create?: XOR<NotificationSettingsCreateWithoutHouseholdInput, NotificationSettingsUncheckedCreateWithoutHouseholdInput> | NotificationSettingsCreateWithoutHouseholdInput[] | NotificationSettingsUncheckedCreateWithoutHouseholdInput[]
    connectOrCreate?: NotificationSettingsCreateOrConnectWithoutHouseholdInput | NotificationSettingsCreateOrConnectWithoutHouseholdInput[]
    upsert?: NotificationSettingsUpsertWithWhereUniqueWithoutHouseholdInput | NotificationSettingsUpsertWithWhereUniqueWithoutHouseholdInput[]
    createMany?: NotificationSettingsCreateManyHouseholdInputEnvelope
    set?: NotificationSettingsWhereUniqueInput | NotificationSettingsWhereUniqueInput[]
    disconnect?: NotificationSettingsWhereUniqueInput | NotificationSettingsWhereUniqueInput[]
    delete?: NotificationSettingsWhereUniqueInput | NotificationSettingsWhereUniqueInput[]
    connect?: NotificationSettingsWhereUniqueInput | NotificationSettingsWhereUniqueInput[]
    update?: NotificationSettingsUpdateWithWhereUniqueWithoutHouseholdInput | NotificationSettingsUpdateWithWhereUniqueWithoutHouseholdInput[]
    updateMany?: NotificationSettingsUpdateManyWithWhereWithoutHouseholdInput | NotificationSettingsUpdateManyWithWhereWithoutHouseholdInput[]
    deleteMany?: NotificationSettingsScalarWhereInput | NotificationSettingsScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutHouseholdsInput = {
    create?: XOR<UserCreateWithoutHouseholdsInput, UserUncheckedCreateWithoutHouseholdsInput>
    connectOrCreate?: UserCreateOrConnectWithoutHouseholdsInput
    connect?: UserWhereUniqueInput
  }

  export type HouseholdCreateNestedOneWithoutMembersInput = {
    create?: XOR<HouseholdCreateWithoutMembersInput, HouseholdUncheckedCreateWithoutMembersInput>
    connectOrCreate?: HouseholdCreateOrConnectWithoutMembersInput
    connect?: HouseholdWhereUniqueInput
  }

  export type ThreadCreateNestedManyWithoutParticipantsInput = {
    create?: XOR<ThreadCreateWithoutParticipantsInput, ThreadUncheckedCreateWithoutParticipantsInput> | ThreadCreateWithoutParticipantsInput[] | ThreadUncheckedCreateWithoutParticipantsInput[]
    connectOrCreate?: ThreadCreateOrConnectWithoutParticipantsInput | ThreadCreateOrConnectWithoutParticipantsInput[]
    connect?: ThreadWhereUniqueInput | ThreadWhereUniqueInput[]
  }

  export type ThreadUncheckedCreateNestedManyWithoutParticipantsInput = {
    create?: XOR<ThreadCreateWithoutParticipantsInput, ThreadUncheckedCreateWithoutParticipantsInput> | ThreadCreateWithoutParticipantsInput[] | ThreadUncheckedCreateWithoutParticipantsInput[]
    connectOrCreate?: ThreadCreateOrConnectWithoutParticipantsInput | ThreadCreateOrConnectWithoutParticipantsInput[]
    connect?: ThreadWhereUniqueInput | ThreadWhereUniqueInput[]
  }

  export type EnumHouseholdRoleFieldUpdateOperationsInput = {
    set?: $Enums.HouseholdRole
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type UserUpdateOneRequiredWithoutHouseholdsNestedInput = {
    create?: XOR<UserCreateWithoutHouseholdsInput, UserUncheckedCreateWithoutHouseholdsInput>
    connectOrCreate?: UserCreateOrConnectWithoutHouseholdsInput
    upsert?: UserUpsertWithoutHouseholdsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutHouseholdsInput, UserUpdateWithoutHouseholdsInput>, UserUncheckedUpdateWithoutHouseholdsInput>
  }

  export type HouseholdUpdateOneRequiredWithoutMembersNestedInput = {
    create?: XOR<HouseholdCreateWithoutMembersInput, HouseholdUncheckedCreateWithoutMembersInput>
    connectOrCreate?: HouseholdCreateOrConnectWithoutMembersInput
    upsert?: HouseholdUpsertWithoutMembersInput
    connect?: HouseholdWhereUniqueInput
    update?: XOR<XOR<HouseholdUpdateToOneWithWhereWithoutMembersInput, HouseholdUpdateWithoutMembersInput>, HouseholdUncheckedUpdateWithoutMembersInput>
  }

  export type ThreadUpdateManyWithoutParticipantsNestedInput = {
    create?: XOR<ThreadCreateWithoutParticipantsInput, ThreadUncheckedCreateWithoutParticipantsInput> | ThreadCreateWithoutParticipantsInput[] | ThreadUncheckedCreateWithoutParticipantsInput[]
    connectOrCreate?: ThreadCreateOrConnectWithoutParticipantsInput | ThreadCreateOrConnectWithoutParticipantsInput[]
    upsert?: ThreadUpsertWithWhereUniqueWithoutParticipantsInput | ThreadUpsertWithWhereUniqueWithoutParticipantsInput[]
    set?: ThreadWhereUniqueInput | ThreadWhereUniqueInput[]
    disconnect?: ThreadWhereUniqueInput | ThreadWhereUniqueInput[]
    delete?: ThreadWhereUniqueInput | ThreadWhereUniqueInput[]
    connect?: ThreadWhereUniqueInput | ThreadWhereUniqueInput[]
    update?: ThreadUpdateWithWhereUniqueWithoutParticipantsInput | ThreadUpdateWithWhereUniqueWithoutParticipantsInput[]
    updateMany?: ThreadUpdateManyWithWhereWithoutParticipantsInput | ThreadUpdateManyWithWhereWithoutParticipantsInput[]
    deleteMany?: ThreadScalarWhereInput | ThreadScalarWhereInput[]
  }

  export type ThreadUncheckedUpdateManyWithoutParticipantsNestedInput = {
    create?: XOR<ThreadCreateWithoutParticipantsInput, ThreadUncheckedCreateWithoutParticipantsInput> | ThreadCreateWithoutParticipantsInput[] | ThreadUncheckedCreateWithoutParticipantsInput[]
    connectOrCreate?: ThreadCreateOrConnectWithoutParticipantsInput | ThreadCreateOrConnectWithoutParticipantsInput[]
    upsert?: ThreadUpsertWithWhereUniqueWithoutParticipantsInput | ThreadUpsertWithWhereUniqueWithoutParticipantsInput[]
    set?: ThreadWhereUniqueInput | ThreadWhereUniqueInput[]
    disconnect?: ThreadWhereUniqueInput | ThreadWhereUniqueInput[]
    delete?: ThreadWhereUniqueInput | ThreadWhereUniqueInput[]
    connect?: ThreadWhereUniqueInput | ThreadWhereUniqueInput[]
    update?: ThreadUpdateWithWhereUniqueWithoutParticipantsInput | ThreadUpdateWithWhereUniqueWithoutParticipantsInput[]
    updateMany?: ThreadUpdateManyWithWhereWithoutParticipantsInput | ThreadUpdateManyWithWhereWithoutParticipantsInput[]
    deleteMany?: ThreadScalarWhereInput | ThreadScalarWhereInput[]
  }

  export type RecurrenceRuleCreatebyWeekDayInput = {
    set: $Enums.DaysOfWeek[]
  }

  export type RecurrenceRuleCreatebyMonthDayInput = {
    set: number[]
  }

  export type ChoreCreateNestedManyWithoutRecurrenceRuleInput = {
    create?: XOR<ChoreCreateWithoutRecurrenceRuleInput, ChoreUncheckedCreateWithoutRecurrenceRuleInput> | ChoreCreateWithoutRecurrenceRuleInput[] | ChoreUncheckedCreateWithoutRecurrenceRuleInput[]
    connectOrCreate?: ChoreCreateOrConnectWithoutRecurrenceRuleInput | ChoreCreateOrConnectWithoutRecurrenceRuleInput[]
    createMany?: ChoreCreateManyRecurrenceRuleInputEnvelope
    connect?: ChoreWhereUniqueInput | ChoreWhereUniqueInput[]
  }

  export type EventCreateNestedManyWithoutRecurrenceRuleInput = {
    create?: XOR<EventCreateWithoutRecurrenceRuleInput, EventUncheckedCreateWithoutRecurrenceRuleInput> | EventCreateWithoutRecurrenceRuleInput[] | EventUncheckedCreateWithoutRecurrenceRuleInput[]
    connectOrCreate?: EventCreateOrConnectWithoutRecurrenceRuleInput | EventCreateOrConnectWithoutRecurrenceRuleInput[]
    createMany?: EventCreateManyRecurrenceRuleInputEnvelope
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
  }

  export type ChoreUncheckedCreateNestedManyWithoutRecurrenceRuleInput = {
    create?: XOR<ChoreCreateWithoutRecurrenceRuleInput, ChoreUncheckedCreateWithoutRecurrenceRuleInput> | ChoreCreateWithoutRecurrenceRuleInput[] | ChoreUncheckedCreateWithoutRecurrenceRuleInput[]
    connectOrCreate?: ChoreCreateOrConnectWithoutRecurrenceRuleInput | ChoreCreateOrConnectWithoutRecurrenceRuleInput[]
    createMany?: ChoreCreateManyRecurrenceRuleInputEnvelope
    connect?: ChoreWhereUniqueInput | ChoreWhereUniqueInput[]
  }

  export type EventUncheckedCreateNestedManyWithoutRecurrenceRuleInput = {
    create?: XOR<EventCreateWithoutRecurrenceRuleInput, EventUncheckedCreateWithoutRecurrenceRuleInput> | EventCreateWithoutRecurrenceRuleInput[] | EventUncheckedCreateWithoutRecurrenceRuleInput[]
    connectOrCreate?: EventCreateOrConnectWithoutRecurrenceRuleInput | EventCreateOrConnectWithoutRecurrenceRuleInput[]
    createMany?: EventCreateManyRecurrenceRuleInputEnvelope
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
  }

  export type EnumRecurrenceFrequencyFieldUpdateOperationsInput = {
    set?: $Enums.RecurrenceFrequency
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type RecurrenceRuleUpdatebyWeekDayInput = {
    set?: $Enums.DaysOfWeek[]
    push?: $Enums.DaysOfWeek | $Enums.DaysOfWeek[]
  }

  export type RecurrenceRuleUpdatebyMonthDayInput = {
    set?: number[]
    push?: number | number[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ChoreUpdateManyWithoutRecurrenceRuleNestedInput = {
    create?: XOR<ChoreCreateWithoutRecurrenceRuleInput, ChoreUncheckedCreateWithoutRecurrenceRuleInput> | ChoreCreateWithoutRecurrenceRuleInput[] | ChoreUncheckedCreateWithoutRecurrenceRuleInput[]
    connectOrCreate?: ChoreCreateOrConnectWithoutRecurrenceRuleInput | ChoreCreateOrConnectWithoutRecurrenceRuleInput[]
    upsert?: ChoreUpsertWithWhereUniqueWithoutRecurrenceRuleInput | ChoreUpsertWithWhereUniqueWithoutRecurrenceRuleInput[]
    createMany?: ChoreCreateManyRecurrenceRuleInputEnvelope
    set?: ChoreWhereUniqueInput | ChoreWhereUniqueInput[]
    disconnect?: ChoreWhereUniqueInput | ChoreWhereUniqueInput[]
    delete?: ChoreWhereUniqueInput | ChoreWhereUniqueInput[]
    connect?: ChoreWhereUniqueInput | ChoreWhereUniqueInput[]
    update?: ChoreUpdateWithWhereUniqueWithoutRecurrenceRuleInput | ChoreUpdateWithWhereUniqueWithoutRecurrenceRuleInput[]
    updateMany?: ChoreUpdateManyWithWhereWithoutRecurrenceRuleInput | ChoreUpdateManyWithWhereWithoutRecurrenceRuleInput[]
    deleteMany?: ChoreScalarWhereInput | ChoreScalarWhereInput[]
  }

  export type EventUpdateManyWithoutRecurrenceRuleNestedInput = {
    create?: XOR<EventCreateWithoutRecurrenceRuleInput, EventUncheckedCreateWithoutRecurrenceRuleInput> | EventCreateWithoutRecurrenceRuleInput[] | EventUncheckedCreateWithoutRecurrenceRuleInput[]
    connectOrCreate?: EventCreateOrConnectWithoutRecurrenceRuleInput | EventCreateOrConnectWithoutRecurrenceRuleInput[]
    upsert?: EventUpsertWithWhereUniqueWithoutRecurrenceRuleInput | EventUpsertWithWhereUniqueWithoutRecurrenceRuleInput[]
    createMany?: EventCreateManyRecurrenceRuleInputEnvelope
    set?: EventWhereUniqueInput | EventWhereUniqueInput[]
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    update?: EventUpdateWithWhereUniqueWithoutRecurrenceRuleInput | EventUpdateWithWhereUniqueWithoutRecurrenceRuleInput[]
    updateMany?: EventUpdateManyWithWhereWithoutRecurrenceRuleInput | EventUpdateManyWithWhereWithoutRecurrenceRuleInput[]
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[]
  }

  export type ChoreUncheckedUpdateManyWithoutRecurrenceRuleNestedInput = {
    create?: XOR<ChoreCreateWithoutRecurrenceRuleInput, ChoreUncheckedCreateWithoutRecurrenceRuleInput> | ChoreCreateWithoutRecurrenceRuleInput[] | ChoreUncheckedCreateWithoutRecurrenceRuleInput[]
    connectOrCreate?: ChoreCreateOrConnectWithoutRecurrenceRuleInput | ChoreCreateOrConnectWithoutRecurrenceRuleInput[]
    upsert?: ChoreUpsertWithWhereUniqueWithoutRecurrenceRuleInput | ChoreUpsertWithWhereUniqueWithoutRecurrenceRuleInput[]
    createMany?: ChoreCreateManyRecurrenceRuleInputEnvelope
    set?: ChoreWhereUniqueInput | ChoreWhereUniqueInput[]
    disconnect?: ChoreWhereUniqueInput | ChoreWhereUniqueInput[]
    delete?: ChoreWhereUniqueInput | ChoreWhereUniqueInput[]
    connect?: ChoreWhereUniqueInput | ChoreWhereUniqueInput[]
    update?: ChoreUpdateWithWhereUniqueWithoutRecurrenceRuleInput | ChoreUpdateWithWhereUniqueWithoutRecurrenceRuleInput[]
    updateMany?: ChoreUpdateManyWithWhereWithoutRecurrenceRuleInput | ChoreUpdateManyWithWhereWithoutRecurrenceRuleInput[]
    deleteMany?: ChoreScalarWhereInput | ChoreScalarWhereInput[]
  }

  export type EventUncheckedUpdateManyWithoutRecurrenceRuleNestedInput = {
    create?: XOR<EventCreateWithoutRecurrenceRuleInput, EventUncheckedCreateWithoutRecurrenceRuleInput> | EventCreateWithoutRecurrenceRuleInput[] | EventUncheckedCreateWithoutRecurrenceRuleInput[]
    connectOrCreate?: EventCreateOrConnectWithoutRecurrenceRuleInput | EventCreateOrConnectWithoutRecurrenceRuleInput[]
    upsert?: EventUpsertWithWhereUniqueWithoutRecurrenceRuleInput | EventUpsertWithWhereUniqueWithoutRecurrenceRuleInput[]
    createMany?: EventCreateManyRecurrenceRuleInputEnvelope
    set?: EventWhereUniqueInput | EventWhereUniqueInput[]
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    update?: EventUpdateWithWhereUniqueWithoutRecurrenceRuleInput | EventUpdateWithWhereUniqueWithoutRecurrenceRuleInput[]
    updateMany?: EventUpdateManyWithWhereWithoutRecurrenceRuleInput | EventUpdateManyWithWhereWithoutRecurrenceRuleInput[]
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[]
  }

  export type HouseholdCreateNestedOneWithoutThreadsInput = {
    create?: XOR<HouseholdCreateWithoutThreadsInput, HouseholdUncheckedCreateWithoutThreadsInput>
    connectOrCreate?: HouseholdCreateOrConnectWithoutThreadsInput
    connect?: HouseholdWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutThreadsInput = {
    create?: XOR<UserCreateWithoutThreadsInput, UserUncheckedCreateWithoutThreadsInput>
    connectOrCreate?: UserCreateOrConnectWithoutThreadsInput
    connect?: UserWhereUniqueInput
  }

  export type MessageCreateNestedManyWithoutThreadInput = {
    create?: XOR<MessageCreateWithoutThreadInput, MessageUncheckedCreateWithoutThreadInput> | MessageCreateWithoutThreadInput[] | MessageUncheckedCreateWithoutThreadInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutThreadInput | MessageCreateOrConnectWithoutThreadInput[]
    createMany?: MessageCreateManyThreadInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type HouseholdMemberCreateNestedManyWithoutThreadsInput = {
    create?: XOR<HouseholdMemberCreateWithoutThreadsInput, HouseholdMemberUncheckedCreateWithoutThreadsInput> | HouseholdMemberCreateWithoutThreadsInput[] | HouseholdMemberUncheckedCreateWithoutThreadsInput[]
    connectOrCreate?: HouseholdMemberCreateOrConnectWithoutThreadsInput | HouseholdMemberCreateOrConnectWithoutThreadsInput[]
    connect?: HouseholdMemberWhereUniqueInput | HouseholdMemberWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutThreadInput = {
    create?: XOR<MessageCreateWithoutThreadInput, MessageUncheckedCreateWithoutThreadInput> | MessageCreateWithoutThreadInput[] | MessageUncheckedCreateWithoutThreadInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutThreadInput | MessageCreateOrConnectWithoutThreadInput[]
    createMany?: MessageCreateManyThreadInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type HouseholdMemberUncheckedCreateNestedManyWithoutThreadsInput = {
    create?: XOR<HouseholdMemberCreateWithoutThreadsInput, HouseholdMemberUncheckedCreateWithoutThreadsInput> | HouseholdMemberCreateWithoutThreadsInput[] | HouseholdMemberUncheckedCreateWithoutThreadsInput[]
    connectOrCreate?: HouseholdMemberCreateOrConnectWithoutThreadsInput | HouseholdMemberCreateOrConnectWithoutThreadsInput[]
    connect?: HouseholdMemberWhereUniqueInput | HouseholdMemberWhereUniqueInput[]
  }

  export type HouseholdUpdateOneRequiredWithoutThreadsNestedInput = {
    create?: XOR<HouseholdCreateWithoutThreadsInput, HouseholdUncheckedCreateWithoutThreadsInput>
    connectOrCreate?: HouseholdCreateOrConnectWithoutThreadsInput
    upsert?: HouseholdUpsertWithoutThreadsInput
    connect?: HouseholdWhereUniqueInput
    update?: XOR<XOR<HouseholdUpdateToOneWithWhereWithoutThreadsInput, HouseholdUpdateWithoutThreadsInput>, HouseholdUncheckedUpdateWithoutThreadsInput>
  }

  export type UserUpdateOneRequiredWithoutThreadsNestedInput = {
    create?: XOR<UserCreateWithoutThreadsInput, UserUncheckedCreateWithoutThreadsInput>
    connectOrCreate?: UserCreateOrConnectWithoutThreadsInput
    upsert?: UserUpsertWithoutThreadsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutThreadsInput, UserUpdateWithoutThreadsInput>, UserUncheckedUpdateWithoutThreadsInput>
  }

  export type MessageUpdateManyWithoutThreadNestedInput = {
    create?: XOR<MessageCreateWithoutThreadInput, MessageUncheckedCreateWithoutThreadInput> | MessageCreateWithoutThreadInput[] | MessageUncheckedCreateWithoutThreadInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutThreadInput | MessageCreateOrConnectWithoutThreadInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutThreadInput | MessageUpsertWithWhereUniqueWithoutThreadInput[]
    createMany?: MessageCreateManyThreadInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutThreadInput | MessageUpdateWithWhereUniqueWithoutThreadInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutThreadInput | MessageUpdateManyWithWhereWithoutThreadInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type HouseholdMemberUpdateManyWithoutThreadsNestedInput = {
    create?: XOR<HouseholdMemberCreateWithoutThreadsInput, HouseholdMemberUncheckedCreateWithoutThreadsInput> | HouseholdMemberCreateWithoutThreadsInput[] | HouseholdMemberUncheckedCreateWithoutThreadsInput[]
    connectOrCreate?: HouseholdMemberCreateOrConnectWithoutThreadsInput | HouseholdMemberCreateOrConnectWithoutThreadsInput[]
    upsert?: HouseholdMemberUpsertWithWhereUniqueWithoutThreadsInput | HouseholdMemberUpsertWithWhereUniqueWithoutThreadsInput[]
    set?: HouseholdMemberWhereUniqueInput | HouseholdMemberWhereUniqueInput[]
    disconnect?: HouseholdMemberWhereUniqueInput | HouseholdMemberWhereUniqueInput[]
    delete?: HouseholdMemberWhereUniqueInput | HouseholdMemberWhereUniqueInput[]
    connect?: HouseholdMemberWhereUniqueInput | HouseholdMemberWhereUniqueInput[]
    update?: HouseholdMemberUpdateWithWhereUniqueWithoutThreadsInput | HouseholdMemberUpdateWithWhereUniqueWithoutThreadsInput[]
    updateMany?: HouseholdMemberUpdateManyWithWhereWithoutThreadsInput | HouseholdMemberUpdateManyWithWhereWithoutThreadsInput[]
    deleteMany?: HouseholdMemberScalarWhereInput | HouseholdMemberScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutThreadNestedInput = {
    create?: XOR<MessageCreateWithoutThreadInput, MessageUncheckedCreateWithoutThreadInput> | MessageCreateWithoutThreadInput[] | MessageUncheckedCreateWithoutThreadInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutThreadInput | MessageCreateOrConnectWithoutThreadInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutThreadInput | MessageUpsertWithWhereUniqueWithoutThreadInput[]
    createMany?: MessageCreateManyThreadInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutThreadInput | MessageUpdateWithWhereUniqueWithoutThreadInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutThreadInput | MessageUpdateManyWithWhereWithoutThreadInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type HouseholdMemberUncheckedUpdateManyWithoutThreadsNestedInput = {
    create?: XOR<HouseholdMemberCreateWithoutThreadsInput, HouseholdMemberUncheckedCreateWithoutThreadsInput> | HouseholdMemberCreateWithoutThreadsInput[] | HouseholdMemberUncheckedCreateWithoutThreadsInput[]
    connectOrCreate?: HouseholdMemberCreateOrConnectWithoutThreadsInput | HouseholdMemberCreateOrConnectWithoutThreadsInput[]
    upsert?: HouseholdMemberUpsertWithWhereUniqueWithoutThreadsInput | HouseholdMemberUpsertWithWhereUniqueWithoutThreadsInput[]
    set?: HouseholdMemberWhereUniqueInput | HouseholdMemberWhereUniqueInput[]
    disconnect?: HouseholdMemberWhereUniqueInput | HouseholdMemberWhereUniqueInput[]
    delete?: HouseholdMemberWhereUniqueInput | HouseholdMemberWhereUniqueInput[]
    connect?: HouseholdMemberWhereUniqueInput | HouseholdMemberWhereUniqueInput[]
    update?: HouseholdMemberUpdateWithWhereUniqueWithoutThreadsInput | HouseholdMemberUpdateWithWhereUniqueWithoutThreadsInput[]
    updateMany?: HouseholdMemberUpdateManyWithWhereWithoutThreadsInput | HouseholdMemberUpdateManyWithWhereWithoutThreadsInput[]
    deleteMany?: HouseholdMemberScalarWhereInput | HouseholdMemberScalarWhereInput[]
  }

  export type ThreadCreateNestedOneWithoutMessagesInput = {
    create?: XOR<ThreadCreateWithoutMessagesInput, ThreadUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ThreadCreateOrConnectWithoutMessagesInput
    connect?: ThreadWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutMessagesInput = {
    create?: XOR<UserCreateWithoutMessagesInput, UserUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessagesInput
    connect?: UserWhereUniqueInput
  }

  export type AttachmentCreateNestedManyWithoutMessageInput = {
    create?: XOR<AttachmentCreateWithoutMessageInput, AttachmentUncheckedCreateWithoutMessageInput> | AttachmentCreateWithoutMessageInput[] | AttachmentUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutMessageInput | AttachmentCreateOrConnectWithoutMessageInput[]
    createMany?: AttachmentCreateManyMessageInputEnvelope
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
  }

  export type ReactionCreateNestedManyWithoutMessageInput = {
    create?: XOR<ReactionCreateWithoutMessageInput, ReactionUncheckedCreateWithoutMessageInput> | ReactionCreateWithoutMessageInput[] | ReactionUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: ReactionCreateOrConnectWithoutMessageInput | ReactionCreateOrConnectWithoutMessageInput[]
    createMany?: ReactionCreateManyMessageInputEnvelope
    connect?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
  }

  export type MentionCreateNestedManyWithoutMessageInput = {
    create?: XOR<MentionCreateWithoutMessageInput, MentionUncheckedCreateWithoutMessageInput> | MentionCreateWithoutMessageInput[] | MentionUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: MentionCreateOrConnectWithoutMessageInput | MentionCreateOrConnectWithoutMessageInput[]
    createMany?: MentionCreateManyMessageInputEnvelope
    connect?: MentionWhereUniqueInput | MentionWhereUniqueInput[]
  }

  export type MessageReadCreateNestedManyWithoutMessageInput = {
    create?: XOR<MessageReadCreateWithoutMessageInput, MessageReadUncheckedCreateWithoutMessageInput> | MessageReadCreateWithoutMessageInput[] | MessageReadUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: MessageReadCreateOrConnectWithoutMessageInput | MessageReadCreateOrConnectWithoutMessageInput[]
    createMany?: MessageReadCreateManyMessageInputEnvelope
    connect?: MessageReadWhereUniqueInput | MessageReadWhereUniqueInput[]
  }

  export type AttachmentUncheckedCreateNestedManyWithoutMessageInput = {
    create?: XOR<AttachmentCreateWithoutMessageInput, AttachmentUncheckedCreateWithoutMessageInput> | AttachmentCreateWithoutMessageInput[] | AttachmentUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutMessageInput | AttachmentCreateOrConnectWithoutMessageInput[]
    createMany?: AttachmentCreateManyMessageInputEnvelope
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
  }

  export type ReactionUncheckedCreateNestedManyWithoutMessageInput = {
    create?: XOR<ReactionCreateWithoutMessageInput, ReactionUncheckedCreateWithoutMessageInput> | ReactionCreateWithoutMessageInput[] | ReactionUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: ReactionCreateOrConnectWithoutMessageInput | ReactionCreateOrConnectWithoutMessageInput[]
    createMany?: ReactionCreateManyMessageInputEnvelope
    connect?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
  }

  export type MentionUncheckedCreateNestedManyWithoutMessageInput = {
    create?: XOR<MentionCreateWithoutMessageInput, MentionUncheckedCreateWithoutMessageInput> | MentionCreateWithoutMessageInput[] | MentionUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: MentionCreateOrConnectWithoutMessageInput | MentionCreateOrConnectWithoutMessageInput[]
    createMany?: MentionCreateManyMessageInputEnvelope
    connect?: MentionWhereUniqueInput | MentionWhereUniqueInput[]
  }

  export type MessageReadUncheckedCreateNestedManyWithoutMessageInput = {
    create?: XOR<MessageReadCreateWithoutMessageInput, MessageReadUncheckedCreateWithoutMessageInput> | MessageReadCreateWithoutMessageInput[] | MessageReadUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: MessageReadCreateOrConnectWithoutMessageInput | MessageReadCreateOrConnectWithoutMessageInput[]
    createMany?: MessageReadCreateManyMessageInputEnvelope
    connect?: MessageReadWhereUniqueInput | MessageReadWhereUniqueInput[]
  }

  export type ThreadUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<ThreadCreateWithoutMessagesInput, ThreadUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ThreadCreateOrConnectWithoutMessagesInput
    upsert?: ThreadUpsertWithoutMessagesInput
    connect?: ThreadWhereUniqueInput
    update?: XOR<XOR<ThreadUpdateToOneWithWhereWithoutMessagesInput, ThreadUpdateWithoutMessagesInput>, ThreadUncheckedUpdateWithoutMessagesInput>
  }

  export type UserUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<UserCreateWithoutMessagesInput, UserUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessagesInput
    upsert?: UserUpsertWithoutMessagesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMessagesInput, UserUpdateWithoutMessagesInput>, UserUncheckedUpdateWithoutMessagesInput>
  }

  export type AttachmentUpdateManyWithoutMessageNestedInput = {
    create?: XOR<AttachmentCreateWithoutMessageInput, AttachmentUncheckedCreateWithoutMessageInput> | AttachmentCreateWithoutMessageInput[] | AttachmentUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutMessageInput | AttachmentCreateOrConnectWithoutMessageInput[]
    upsert?: AttachmentUpsertWithWhereUniqueWithoutMessageInput | AttachmentUpsertWithWhereUniqueWithoutMessageInput[]
    createMany?: AttachmentCreateManyMessageInputEnvelope
    set?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    disconnect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    delete?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    update?: AttachmentUpdateWithWhereUniqueWithoutMessageInput | AttachmentUpdateWithWhereUniqueWithoutMessageInput[]
    updateMany?: AttachmentUpdateManyWithWhereWithoutMessageInput | AttachmentUpdateManyWithWhereWithoutMessageInput[]
    deleteMany?: AttachmentScalarWhereInput | AttachmentScalarWhereInput[]
  }

  export type ReactionUpdateManyWithoutMessageNestedInput = {
    create?: XOR<ReactionCreateWithoutMessageInput, ReactionUncheckedCreateWithoutMessageInput> | ReactionCreateWithoutMessageInput[] | ReactionUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: ReactionCreateOrConnectWithoutMessageInput | ReactionCreateOrConnectWithoutMessageInput[]
    upsert?: ReactionUpsertWithWhereUniqueWithoutMessageInput | ReactionUpsertWithWhereUniqueWithoutMessageInput[]
    createMany?: ReactionCreateManyMessageInputEnvelope
    set?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
    disconnect?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
    delete?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
    connect?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
    update?: ReactionUpdateWithWhereUniqueWithoutMessageInput | ReactionUpdateWithWhereUniqueWithoutMessageInput[]
    updateMany?: ReactionUpdateManyWithWhereWithoutMessageInput | ReactionUpdateManyWithWhereWithoutMessageInput[]
    deleteMany?: ReactionScalarWhereInput | ReactionScalarWhereInput[]
  }

  export type MentionUpdateManyWithoutMessageNestedInput = {
    create?: XOR<MentionCreateWithoutMessageInput, MentionUncheckedCreateWithoutMessageInput> | MentionCreateWithoutMessageInput[] | MentionUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: MentionCreateOrConnectWithoutMessageInput | MentionCreateOrConnectWithoutMessageInput[]
    upsert?: MentionUpsertWithWhereUniqueWithoutMessageInput | MentionUpsertWithWhereUniqueWithoutMessageInput[]
    createMany?: MentionCreateManyMessageInputEnvelope
    set?: MentionWhereUniqueInput | MentionWhereUniqueInput[]
    disconnect?: MentionWhereUniqueInput | MentionWhereUniqueInput[]
    delete?: MentionWhereUniqueInput | MentionWhereUniqueInput[]
    connect?: MentionWhereUniqueInput | MentionWhereUniqueInput[]
    update?: MentionUpdateWithWhereUniqueWithoutMessageInput | MentionUpdateWithWhereUniqueWithoutMessageInput[]
    updateMany?: MentionUpdateManyWithWhereWithoutMessageInput | MentionUpdateManyWithWhereWithoutMessageInput[]
    deleteMany?: MentionScalarWhereInput | MentionScalarWhereInput[]
  }

  export type MessageReadUpdateManyWithoutMessageNestedInput = {
    create?: XOR<MessageReadCreateWithoutMessageInput, MessageReadUncheckedCreateWithoutMessageInput> | MessageReadCreateWithoutMessageInput[] | MessageReadUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: MessageReadCreateOrConnectWithoutMessageInput | MessageReadCreateOrConnectWithoutMessageInput[]
    upsert?: MessageReadUpsertWithWhereUniqueWithoutMessageInput | MessageReadUpsertWithWhereUniqueWithoutMessageInput[]
    createMany?: MessageReadCreateManyMessageInputEnvelope
    set?: MessageReadWhereUniqueInput | MessageReadWhereUniqueInput[]
    disconnect?: MessageReadWhereUniqueInput | MessageReadWhereUniqueInput[]
    delete?: MessageReadWhereUniqueInput | MessageReadWhereUniqueInput[]
    connect?: MessageReadWhereUniqueInput | MessageReadWhereUniqueInput[]
    update?: MessageReadUpdateWithWhereUniqueWithoutMessageInput | MessageReadUpdateWithWhereUniqueWithoutMessageInput[]
    updateMany?: MessageReadUpdateManyWithWhereWithoutMessageInput | MessageReadUpdateManyWithWhereWithoutMessageInput[]
    deleteMany?: MessageReadScalarWhereInput | MessageReadScalarWhereInput[]
  }

  export type AttachmentUncheckedUpdateManyWithoutMessageNestedInput = {
    create?: XOR<AttachmentCreateWithoutMessageInput, AttachmentUncheckedCreateWithoutMessageInput> | AttachmentCreateWithoutMessageInput[] | AttachmentUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutMessageInput | AttachmentCreateOrConnectWithoutMessageInput[]
    upsert?: AttachmentUpsertWithWhereUniqueWithoutMessageInput | AttachmentUpsertWithWhereUniqueWithoutMessageInput[]
    createMany?: AttachmentCreateManyMessageInputEnvelope
    set?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    disconnect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    delete?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    update?: AttachmentUpdateWithWhereUniqueWithoutMessageInput | AttachmentUpdateWithWhereUniqueWithoutMessageInput[]
    updateMany?: AttachmentUpdateManyWithWhereWithoutMessageInput | AttachmentUpdateManyWithWhereWithoutMessageInput[]
    deleteMany?: AttachmentScalarWhereInput | AttachmentScalarWhereInput[]
  }

  export type ReactionUncheckedUpdateManyWithoutMessageNestedInput = {
    create?: XOR<ReactionCreateWithoutMessageInput, ReactionUncheckedCreateWithoutMessageInput> | ReactionCreateWithoutMessageInput[] | ReactionUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: ReactionCreateOrConnectWithoutMessageInput | ReactionCreateOrConnectWithoutMessageInput[]
    upsert?: ReactionUpsertWithWhereUniqueWithoutMessageInput | ReactionUpsertWithWhereUniqueWithoutMessageInput[]
    createMany?: ReactionCreateManyMessageInputEnvelope
    set?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
    disconnect?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
    delete?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
    connect?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
    update?: ReactionUpdateWithWhereUniqueWithoutMessageInput | ReactionUpdateWithWhereUniqueWithoutMessageInput[]
    updateMany?: ReactionUpdateManyWithWhereWithoutMessageInput | ReactionUpdateManyWithWhereWithoutMessageInput[]
    deleteMany?: ReactionScalarWhereInput | ReactionScalarWhereInput[]
  }

  export type MentionUncheckedUpdateManyWithoutMessageNestedInput = {
    create?: XOR<MentionCreateWithoutMessageInput, MentionUncheckedCreateWithoutMessageInput> | MentionCreateWithoutMessageInput[] | MentionUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: MentionCreateOrConnectWithoutMessageInput | MentionCreateOrConnectWithoutMessageInput[]
    upsert?: MentionUpsertWithWhereUniqueWithoutMessageInput | MentionUpsertWithWhereUniqueWithoutMessageInput[]
    createMany?: MentionCreateManyMessageInputEnvelope
    set?: MentionWhereUniqueInput | MentionWhereUniqueInput[]
    disconnect?: MentionWhereUniqueInput | MentionWhereUniqueInput[]
    delete?: MentionWhereUniqueInput | MentionWhereUniqueInput[]
    connect?: MentionWhereUniqueInput | MentionWhereUniqueInput[]
    update?: MentionUpdateWithWhereUniqueWithoutMessageInput | MentionUpdateWithWhereUniqueWithoutMessageInput[]
    updateMany?: MentionUpdateManyWithWhereWithoutMessageInput | MentionUpdateManyWithWhereWithoutMessageInput[]
    deleteMany?: MentionScalarWhereInput | MentionScalarWhereInput[]
  }

  export type MessageReadUncheckedUpdateManyWithoutMessageNestedInput = {
    create?: XOR<MessageReadCreateWithoutMessageInput, MessageReadUncheckedCreateWithoutMessageInput> | MessageReadCreateWithoutMessageInput[] | MessageReadUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: MessageReadCreateOrConnectWithoutMessageInput | MessageReadCreateOrConnectWithoutMessageInput[]
    upsert?: MessageReadUpsertWithWhereUniqueWithoutMessageInput | MessageReadUpsertWithWhereUniqueWithoutMessageInput[]
    createMany?: MessageReadCreateManyMessageInputEnvelope
    set?: MessageReadWhereUniqueInput | MessageReadWhereUniqueInput[]
    disconnect?: MessageReadWhereUniqueInput | MessageReadWhereUniqueInput[]
    delete?: MessageReadWhereUniqueInput | MessageReadWhereUniqueInput[]
    connect?: MessageReadWhereUniqueInput | MessageReadWhereUniqueInput[]
    update?: MessageReadUpdateWithWhereUniqueWithoutMessageInput | MessageReadUpdateWithWhereUniqueWithoutMessageInput[]
    updateMany?: MessageReadUpdateManyWithWhereWithoutMessageInput | MessageReadUpdateManyWithWhereWithoutMessageInput[]
    deleteMany?: MessageReadScalarWhereInput | MessageReadScalarWhereInput[]
  }

  export type MessageCreateNestedOneWithoutReactionsInput = {
    create?: XOR<MessageCreateWithoutReactionsInput, MessageUncheckedCreateWithoutReactionsInput>
    connectOrCreate?: MessageCreateOrConnectWithoutReactionsInput
    connect?: MessageWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReactionsInput = {
    create?: XOR<UserCreateWithoutReactionsInput, UserUncheckedCreateWithoutReactionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReactionsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumReactionTypeFieldUpdateOperationsInput = {
    set?: $Enums.ReactionType
  }

  export type MessageUpdateOneRequiredWithoutReactionsNestedInput = {
    create?: XOR<MessageCreateWithoutReactionsInput, MessageUncheckedCreateWithoutReactionsInput>
    connectOrCreate?: MessageCreateOrConnectWithoutReactionsInput
    upsert?: MessageUpsertWithoutReactionsInput
    connect?: MessageWhereUniqueInput
    update?: XOR<XOR<MessageUpdateToOneWithWhereWithoutReactionsInput, MessageUpdateWithoutReactionsInput>, MessageUncheckedUpdateWithoutReactionsInput>
  }

  export type UserUpdateOneRequiredWithoutReactionsNestedInput = {
    create?: XOR<UserCreateWithoutReactionsInput, UserUncheckedCreateWithoutReactionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReactionsInput
    upsert?: UserUpsertWithoutReactionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReactionsInput, UserUpdateWithoutReactionsInput>, UserUncheckedUpdateWithoutReactionsInput>
  }

  export type MessageCreateNestedOneWithoutMentionsInput = {
    create?: XOR<MessageCreateWithoutMentionsInput, MessageUncheckedCreateWithoutMentionsInput>
    connectOrCreate?: MessageCreateOrConnectWithoutMentionsInput
    connect?: MessageWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutMentionsInput = {
    create?: XOR<UserCreateWithoutMentionsInput, UserUncheckedCreateWithoutMentionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMentionsInput
    connect?: UserWhereUniqueInput
  }

  export type MessageUpdateOneRequiredWithoutMentionsNestedInput = {
    create?: XOR<MessageCreateWithoutMentionsInput, MessageUncheckedCreateWithoutMentionsInput>
    connectOrCreate?: MessageCreateOrConnectWithoutMentionsInput
    upsert?: MessageUpsertWithoutMentionsInput
    connect?: MessageWhereUniqueInput
    update?: XOR<XOR<MessageUpdateToOneWithWhereWithoutMentionsInput, MessageUpdateWithoutMentionsInput>, MessageUncheckedUpdateWithoutMentionsInput>
  }

  export type UserUpdateOneRequiredWithoutMentionsNestedInput = {
    create?: XOR<UserCreateWithoutMentionsInput, UserUncheckedCreateWithoutMentionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMentionsInput
    upsert?: UserUpsertWithoutMentionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMentionsInput, UserUpdateWithoutMentionsInput>, UserUncheckedUpdateWithoutMentionsInput>
  }

  export type MessageCreateNestedOneWithoutAttachmentsInput = {
    create?: XOR<MessageCreateWithoutAttachmentsInput, MessageUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: MessageCreateOrConnectWithoutAttachmentsInput
    connect?: MessageWhereUniqueInput
  }

  export type MessageUpdateOneRequiredWithoutAttachmentsNestedInput = {
    create?: XOR<MessageCreateWithoutAttachmentsInput, MessageUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: MessageCreateOrConnectWithoutAttachmentsInput
    upsert?: MessageUpsertWithoutAttachmentsInput
    connect?: MessageWhereUniqueInput
    update?: XOR<XOR<MessageUpdateToOneWithWhereWithoutAttachmentsInput, MessageUpdateWithoutAttachmentsInput>, MessageUncheckedUpdateWithoutAttachmentsInput>
  }

  export type MessageCreateNestedOneWithoutReadsInput = {
    create?: XOR<MessageCreateWithoutReadsInput, MessageUncheckedCreateWithoutReadsInput>
    connectOrCreate?: MessageCreateOrConnectWithoutReadsInput
    connect?: MessageWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutMessageReadsInput = {
    create?: XOR<UserCreateWithoutMessageReadsInput, UserUncheckedCreateWithoutMessageReadsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessageReadsInput
    connect?: UserWhereUniqueInput
  }

  export type MessageUpdateOneRequiredWithoutReadsNestedInput = {
    create?: XOR<MessageCreateWithoutReadsInput, MessageUncheckedCreateWithoutReadsInput>
    connectOrCreate?: MessageCreateOrConnectWithoutReadsInput
    upsert?: MessageUpsertWithoutReadsInput
    connect?: MessageWhereUniqueInput
    update?: XOR<XOR<MessageUpdateToOneWithWhereWithoutReadsInput, MessageUpdateWithoutReadsInput>, MessageUncheckedUpdateWithoutReadsInput>
  }

  export type UserUpdateOneRequiredWithoutMessageReadsNestedInput = {
    create?: XOR<UserCreateWithoutMessageReadsInput, UserUncheckedCreateWithoutMessageReadsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessageReadsInput
    upsert?: UserUpsertWithoutMessageReadsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMessageReadsInput, UserUpdateWithoutMessageReadsInput>, UserUncheckedUpdateWithoutMessageReadsInput>
  }

  export type HouseholdCreateNestedOneWithoutChoresInput = {
    create?: XOR<HouseholdCreateWithoutChoresInput, HouseholdUncheckedCreateWithoutChoresInput>
    connectOrCreate?: HouseholdCreateOrConnectWithoutChoresInput
    connect?: HouseholdWhereUniqueInput
  }

  export type SubtaskCreateNestedManyWithoutChoreInput = {
    create?: XOR<SubtaskCreateWithoutChoreInput, SubtaskUncheckedCreateWithoutChoreInput> | SubtaskCreateWithoutChoreInput[] | SubtaskUncheckedCreateWithoutChoreInput[]
    connectOrCreate?: SubtaskCreateOrConnectWithoutChoreInput | SubtaskCreateOrConnectWithoutChoreInput[]
    createMany?: SubtaskCreateManyChoreInputEnvelope
    connect?: SubtaskWhereUniqueInput | SubtaskWhereUniqueInput[]
  }

  export type ChoreAssignmentCreateNestedManyWithoutChoreInput = {
    create?: XOR<ChoreAssignmentCreateWithoutChoreInput, ChoreAssignmentUncheckedCreateWithoutChoreInput> | ChoreAssignmentCreateWithoutChoreInput[] | ChoreAssignmentUncheckedCreateWithoutChoreInput[]
    connectOrCreate?: ChoreAssignmentCreateOrConnectWithoutChoreInput | ChoreAssignmentCreateOrConnectWithoutChoreInput[]
    createMany?: ChoreAssignmentCreateManyChoreInputEnvelope
    connect?: ChoreAssignmentWhereUniqueInput | ChoreAssignmentWhereUniqueInput[]
  }

  export type EventCreateNestedOneWithoutChoreInput = {
    create?: XOR<EventCreateWithoutChoreInput, EventUncheckedCreateWithoutChoreInput>
    connectOrCreate?: EventCreateOrConnectWithoutChoreInput
    connect?: EventWhereUniqueInput
  }

  export type ChoreSwapRequestCreateNestedManyWithoutChoreInput = {
    create?: XOR<ChoreSwapRequestCreateWithoutChoreInput, ChoreSwapRequestUncheckedCreateWithoutChoreInput> | ChoreSwapRequestCreateWithoutChoreInput[] | ChoreSwapRequestUncheckedCreateWithoutChoreInput[]
    connectOrCreate?: ChoreSwapRequestCreateOrConnectWithoutChoreInput | ChoreSwapRequestCreateOrConnectWithoutChoreInput[]
    createMany?: ChoreSwapRequestCreateManyChoreInputEnvelope
    connect?: ChoreSwapRequestWhereUniqueInput | ChoreSwapRequestWhereUniqueInput[]
  }

  export type RecurrenceRuleCreateNestedOneWithoutChoresInput = {
    create?: XOR<RecurrenceRuleCreateWithoutChoresInput, RecurrenceRuleUncheckedCreateWithoutChoresInput>
    connectOrCreate?: RecurrenceRuleCreateOrConnectWithoutChoresInput
    connect?: RecurrenceRuleWhereUniqueInput
  }

  export type ChoreHistoryCreateNestedManyWithoutChoreInput = {
    create?: XOR<ChoreHistoryCreateWithoutChoreInput, ChoreHistoryUncheckedCreateWithoutChoreInput> | ChoreHistoryCreateWithoutChoreInput[] | ChoreHistoryUncheckedCreateWithoutChoreInput[]
    connectOrCreate?: ChoreHistoryCreateOrConnectWithoutChoreInput | ChoreHistoryCreateOrConnectWithoutChoreInput[]
    createMany?: ChoreHistoryCreateManyChoreInputEnvelope
    connect?: ChoreHistoryWhereUniqueInput | ChoreHistoryWhereUniqueInput[]
  }

  export type SubtaskUncheckedCreateNestedManyWithoutChoreInput = {
    create?: XOR<SubtaskCreateWithoutChoreInput, SubtaskUncheckedCreateWithoutChoreInput> | SubtaskCreateWithoutChoreInput[] | SubtaskUncheckedCreateWithoutChoreInput[]
    connectOrCreate?: SubtaskCreateOrConnectWithoutChoreInput | SubtaskCreateOrConnectWithoutChoreInput[]
    createMany?: SubtaskCreateManyChoreInputEnvelope
    connect?: SubtaskWhereUniqueInput | SubtaskWhereUniqueInput[]
  }

  export type ChoreAssignmentUncheckedCreateNestedManyWithoutChoreInput = {
    create?: XOR<ChoreAssignmentCreateWithoutChoreInput, ChoreAssignmentUncheckedCreateWithoutChoreInput> | ChoreAssignmentCreateWithoutChoreInput[] | ChoreAssignmentUncheckedCreateWithoutChoreInput[]
    connectOrCreate?: ChoreAssignmentCreateOrConnectWithoutChoreInput | ChoreAssignmentCreateOrConnectWithoutChoreInput[]
    createMany?: ChoreAssignmentCreateManyChoreInputEnvelope
    connect?: ChoreAssignmentWhereUniqueInput | ChoreAssignmentWhereUniqueInput[]
  }

  export type ChoreSwapRequestUncheckedCreateNestedManyWithoutChoreInput = {
    create?: XOR<ChoreSwapRequestCreateWithoutChoreInput, ChoreSwapRequestUncheckedCreateWithoutChoreInput> | ChoreSwapRequestCreateWithoutChoreInput[] | ChoreSwapRequestUncheckedCreateWithoutChoreInput[]
    connectOrCreate?: ChoreSwapRequestCreateOrConnectWithoutChoreInput | ChoreSwapRequestCreateOrConnectWithoutChoreInput[]
    createMany?: ChoreSwapRequestCreateManyChoreInputEnvelope
    connect?: ChoreSwapRequestWhereUniqueInput | ChoreSwapRequestWhereUniqueInput[]
  }

  export type ChoreHistoryUncheckedCreateNestedManyWithoutChoreInput = {
    create?: XOR<ChoreHistoryCreateWithoutChoreInput, ChoreHistoryUncheckedCreateWithoutChoreInput> | ChoreHistoryCreateWithoutChoreInput[] | ChoreHistoryUncheckedCreateWithoutChoreInput[]
    connectOrCreate?: ChoreHistoryCreateOrConnectWithoutChoreInput | ChoreHistoryCreateOrConnectWithoutChoreInput[]
    createMany?: ChoreHistoryCreateManyChoreInputEnvelope
    connect?: ChoreHistoryWhereUniqueInput | ChoreHistoryWhereUniqueInput[]
  }

  export type EnumChoreStatusFieldUpdateOperationsInput = {
    set?: $Enums.ChoreStatus
  }

  export type HouseholdUpdateOneRequiredWithoutChoresNestedInput = {
    create?: XOR<HouseholdCreateWithoutChoresInput, HouseholdUncheckedCreateWithoutChoresInput>
    connectOrCreate?: HouseholdCreateOrConnectWithoutChoresInput
    upsert?: HouseholdUpsertWithoutChoresInput
    connect?: HouseholdWhereUniqueInput
    update?: XOR<XOR<HouseholdUpdateToOneWithWhereWithoutChoresInput, HouseholdUpdateWithoutChoresInput>, HouseholdUncheckedUpdateWithoutChoresInput>
  }

  export type SubtaskUpdateManyWithoutChoreNestedInput = {
    create?: XOR<SubtaskCreateWithoutChoreInput, SubtaskUncheckedCreateWithoutChoreInput> | SubtaskCreateWithoutChoreInput[] | SubtaskUncheckedCreateWithoutChoreInput[]
    connectOrCreate?: SubtaskCreateOrConnectWithoutChoreInput | SubtaskCreateOrConnectWithoutChoreInput[]
    upsert?: SubtaskUpsertWithWhereUniqueWithoutChoreInput | SubtaskUpsertWithWhereUniqueWithoutChoreInput[]
    createMany?: SubtaskCreateManyChoreInputEnvelope
    set?: SubtaskWhereUniqueInput | SubtaskWhereUniqueInput[]
    disconnect?: SubtaskWhereUniqueInput | SubtaskWhereUniqueInput[]
    delete?: SubtaskWhereUniqueInput | SubtaskWhereUniqueInput[]
    connect?: SubtaskWhereUniqueInput | SubtaskWhereUniqueInput[]
    update?: SubtaskUpdateWithWhereUniqueWithoutChoreInput | SubtaskUpdateWithWhereUniqueWithoutChoreInput[]
    updateMany?: SubtaskUpdateManyWithWhereWithoutChoreInput | SubtaskUpdateManyWithWhereWithoutChoreInput[]
    deleteMany?: SubtaskScalarWhereInput | SubtaskScalarWhereInput[]
  }

  export type ChoreAssignmentUpdateManyWithoutChoreNestedInput = {
    create?: XOR<ChoreAssignmentCreateWithoutChoreInput, ChoreAssignmentUncheckedCreateWithoutChoreInput> | ChoreAssignmentCreateWithoutChoreInput[] | ChoreAssignmentUncheckedCreateWithoutChoreInput[]
    connectOrCreate?: ChoreAssignmentCreateOrConnectWithoutChoreInput | ChoreAssignmentCreateOrConnectWithoutChoreInput[]
    upsert?: ChoreAssignmentUpsertWithWhereUniqueWithoutChoreInput | ChoreAssignmentUpsertWithWhereUniqueWithoutChoreInput[]
    createMany?: ChoreAssignmentCreateManyChoreInputEnvelope
    set?: ChoreAssignmentWhereUniqueInput | ChoreAssignmentWhereUniqueInput[]
    disconnect?: ChoreAssignmentWhereUniqueInput | ChoreAssignmentWhereUniqueInput[]
    delete?: ChoreAssignmentWhereUniqueInput | ChoreAssignmentWhereUniqueInput[]
    connect?: ChoreAssignmentWhereUniqueInput | ChoreAssignmentWhereUniqueInput[]
    update?: ChoreAssignmentUpdateWithWhereUniqueWithoutChoreInput | ChoreAssignmentUpdateWithWhereUniqueWithoutChoreInput[]
    updateMany?: ChoreAssignmentUpdateManyWithWhereWithoutChoreInput | ChoreAssignmentUpdateManyWithWhereWithoutChoreInput[]
    deleteMany?: ChoreAssignmentScalarWhereInput | ChoreAssignmentScalarWhereInput[]
  }

  export type EventUpdateOneWithoutChoreNestedInput = {
    create?: XOR<EventCreateWithoutChoreInput, EventUncheckedCreateWithoutChoreInput>
    connectOrCreate?: EventCreateOrConnectWithoutChoreInput
    upsert?: EventUpsertWithoutChoreInput
    disconnect?: EventWhereInput | boolean
    delete?: EventWhereInput | boolean
    connect?: EventWhereUniqueInput
    update?: XOR<XOR<EventUpdateToOneWithWhereWithoutChoreInput, EventUpdateWithoutChoreInput>, EventUncheckedUpdateWithoutChoreInput>
  }

  export type ChoreSwapRequestUpdateManyWithoutChoreNestedInput = {
    create?: XOR<ChoreSwapRequestCreateWithoutChoreInput, ChoreSwapRequestUncheckedCreateWithoutChoreInput> | ChoreSwapRequestCreateWithoutChoreInput[] | ChoreSwapRequestUncheckedCreateWithoutChoreInput[]
    connectOrCreate?: ChoreSwapRequestCreateOrConnectWithoutChoreInput | ChoreSwapRequestCreateOrConnectWithoutChoreInput[]
    upsert?: ChoreSwapRequestUpsertWithWhereUniqueWithoutChoreInput | ChoreSwapRequestUpsertWithWhereUniqueWithoutChoreInput[]
    createMany?: ChoreSwapRequestCreateManyChoreInputEnvelope
    set?: ChoreSwapRequestWhereUniqueInput | ChoreSwapRequestWhereUniqueInput[]
    disconnect?: ChoreSwapRequestWhereUniqueInput | ChoreSwapRequestWhereUniqueInput[]
    delete?: ChoreSwapRequestWhereUniqueInput | ChoreSwapRequestWhereUniqueInput[]
    connect?: ChoreSwapRequestWhereUniqueInput | ChoreSwapRequestWhereUniqueInput[]
    update?: ChoreSwapRequestUpdateWithWhereUniqueWithoutChoreInput | ChoreSwapRequestUpdateWithWhereUniqueWithoutChoreInput[]
    updateMany?: ChoreSwapRequestUpdateManyWithWhereWithoutChoreInput | ChoreSwapRequestUpdateManyWithWhereWithoutChoreInput[]
    deleteMany?: ChoreSwapRequestScalarWhereInput | ChoreSwapRequestScalarWhereInput[]
  }

  export type RecurrenceRuleUpdateOneWithoutChoresNestedInput = {
    create?: XOR<RecurrenceRuleCreateWithoutChoresInput, RecurrenceRuleUncheckedCreateWithoutChoresInput>
    connectOrCreate?: RecurrenceRuleCreateOrConnectWithoutChoresInput
    upsert?: RecurrenceRuleUpsertWithoutChoresInput
    disconnect?: RecurrenceRuleWhereInput | boolean
    delete?: RecurrenceRuleWhereInput | boolean
    connect?: RecurrenceRuleWhereUniqueInput
    update?: XOR<XOR<RecurrenceRuleUpdateToOneWithWhereWithoutChoresInput, RecurrenceRuleUpdateWithoutChoresInput>, RecurrenceRuleUncheckedUpdateWithoutChoresInput>
  }

  export type ChoreHistoryUpdateManyWithoutChoreNestedInput = {
    create?: XOR<ChoreHistoryCreateWithoutChoreInput, ChoreHistoryUncheckedCreateWithoutChoreInput> | ChoreHistoryCreateWithoutChoreInput[] | ChoreHistoryUncheckedCreateWithoutChoreInput[]
    connectOrCreate?: ChoreHistoryCreateOrConnectWithoutChoreInput | ChoreHistoryCreateOrConnectWithoutChoreInput[]
    upsert?: ChoreHistoryUpsertWithWhereUniqueWithoutChoreInput | ChoreHistoryUpsertWithWhereUniqueWithoutChoreInput[]
    createMany?: ChoreHistoryCreateManyChoreInputEnvelope
    set?: ChoreHistoryWhereUniqueInput | ChoreHistoryWhereUniqueInput[]
    disconnect?: ChoreHistoryWhereUniqueInput | ChoreHistoryWhereUniqueInput[]
    delete?: ChoreHistoryWhereUniqueInput | ChoreHistoryWhereUniqueInput[]
    connect?: ChoreHistoryWhereUniqueInput | ChoreHistoryWhereUniqueInput[]
    update?: ChoreHistoryUpdateWithWhereUniqueWithoutChoreInput | ChoreHistoryUpdateWithWhereUniqueWithoutChoreInput[]
    updateMany?: ChoreHistoryUpdateManyWithWhereWithoutChoreInput | ChoreHistoryUpdateManyWithWhereWithoutChoreInput[]
    deleteMany?: ChoreHistoryScalarWhereInput | ChoreHistoryScalarWhereInput[]
  }

  export type SubtaskUncheckedUpdateManyWithoutChoreNestedInput = {
    create?: XOR<SubtaskCreateWithoutChoreInput, SubtaskUncheckedCreateWithoutChoreInput> | SubtaskCreateWithoutChoreInput[] | SubtaskUncheckedCreateWithoutChoreInput[]
    connectOrCreate?: SubtaskCreateOrConnectWithoutChoreInput | SubtaskCreateOrConnectWithoutChoreInput[]
    upsert?: SubtaskUpsertWithWhereUniqueWithoutChoreInput | SubtaskUpsertWithWhereUniqueWithoutChoreInput[]
    createMany?: SubtaskCreateManyChoreInputEnvelope
    set?: SubtaskWhereUniqueInput | SubtaskWhereUniqueInput[]
    disconnect?: SubtaskWhereUniqueInput | SubtaskWhereUniqueInput[]
    delete?: SubtaskWhereUniqueInput | SubtaskWhereUniqueInput[]
    connect?: SubtaskWhereUniqueInput | SubtaskWhereUniqueInput[]
    update?: SubtaskUpdateWithWhereUniqueWithoutChoreInput | SubtaskUpdateWithWhereUniqueWithoutChoreInput[]
    updateMany?: SubtaskUpdateManyWithWhereWithoutChoreInput | SubtaskUpdateManyWithWhereWithoutChoreInput[]
    deleteMany?: SubtaskScalarWhereInput | SubtaskScalarWhereInput[]
  }

  export type ChoreAssignmentUncheckedUpdateManyWithoutChoreNestedInput = {
    create?: XOR<ChoreAssignmentCreateWithoutChoreInput, ChoreAssignmentUncheckedCreateWithoutChoreInput> | ChoreAssignmentCreateWithoutChoreInput[] | ChoreAssignmentUncheckedCreateWithoutChoreInput[]
    connectOrCreate?: ChoreAssignmentCreateOrConnectWithoutChoreInput | ChoreAssignmentCreateOrConnectWithoutChoreInput[]
    upsert?: ChoreAssignmentUpsertWithWhereUniqueWithoutChoreInput | ChoreAssignmentUpsertWithWhereUniqueWithoutChoreInput[]
    createMany?: ChoreAssignmentCreateManyChoreInputEnvelope
    set?: ChoreAssignmentWhereUniqueInput | ChoreAssignmentWhereUniqueInput[]
    disconnect?: ChoreAssignmentWhereUniqueInput | ChoreAssignmentWhereUniqueInput[]
    delete?: ChoreAssignmentWhereUniqueInput | ChoreAssignmentWhereUniqueInput[]
    connect?: ChoreAssignmentWhereUniqueInput | ChoreAssignmentWhereUniqueInput[]
    update?: ChoreAssignmentUpdateWithWhereUniqueWithoutChoreInput | ChoreAssignmentUpdateWithWhereUniqueWithoutChoreInput[]
    updateMany?: ChoreAssignmentUpdateManyWithWhereWithoutChoreInput | ChoreAssignmentUpdateManyWithWhereWithoutChoreInput[]
    deleteMany?: ChoreAssignmentScalarWhereInput | ChoreAssignmentScalarWhereInput[]
  }

  export type ChoreSwapRequestUncheckedUpdateManyWithoutChoreNestedInput = {
    create?: XOR<ChoreSwapRequestCreateWithoutChoreInput, ChoreSwapRequestUncheckedCreateWithoutChoreInput> | ChoreSwapRequestCreateWithoutChoreInput[] | ChoreSwapRequestUncheckedCreateWithoutChoreInput[]
    connectOrCreate?: ChoreSwapRequestCreateOrConnectWithoutChoreInput | ChoreSwapRequestCreateOrConnectWithoutChoreInput[]
    upsert?: ChoreSwapRequestUpsertWithWhereUniqueWithoutChoreInput | ChoreSwapRequestUpsertWithWhereUniqueWithoutChoreInput[]
    createMany?: ChoreSwapRequestCreateManyChoreInputEnvelope
    set?: ChoreSwapRequestWhereUniqueInput | ChoreSwapRequestWhereUniqueInput[]
    disconnect?: ChoreSwapRequestWhereUniqueInput | ChoreSwapRequestWhereUniqueInput[]
    delete?: ChoreSwapRequestWhereUniqueInput | ChoreSwapRequestWhereUniqueInput[]
    connect?: ChoreSwapRequestWhereUniqueInput | ChoreSwapRequestWhereUniqueInput[]
    update?: ChoreSwapRequestUpdateWithWhereUniqueWithoutChoreInput | ChoreSwapRequestUpdateWithWhereUniqueWithoutChoreInput[]
    updateMany?: ChoreSwapRequestUpdateManyWithWhereWithoutChoreInput | ChoreSwapRequestUpdateManyWithWhereWithoutChoreInput[]
    deleteMany?: ChoreSwapRequestScalarWhereInput | ChoreSwapRequestScalarWhereInput[]
  }

  export type ChoreHistoryUncheckedUpdateManyWithoutChoreNestedInput = {
    create?: XOR<ChoreHistoryCreateWithoutChoreInput, ChoreHistoryUncheckedCreateWithoutChoreInput> | ChoreHistoryCreateWithoutChoreInput[] | ChoreHistoryUncheckedCreateWithoutChoreInput[]
    connectOrCreate?: ChoreHistoryCreateOrConnectWithoutChoreInput | ChoreHistoryCreateOrConnectWithoutChoreInput[]
    upsert?: ChoreHistoryUpsertWithWhereUniqueWithoutChoreInput | ChoreHistoryUpsertWithWhereUniqueWithoutChoreInput[]
    createMany?: ChoreHistoryCreateManyChoreInputEnvelope
    set?: ChoreHistoryWhereUniqueInput | ChoreHistoryWhereUniqueInput[]
    disconnect?: ChoreHistoryWhereUniqueInput | ChoreHistoryWhereUniqueInput[]
    delete?: ChoreHistoryWhereUniqueInput | ChoreHistoryWhereUniqueInput[]
    connect?: ChoreHistoryWhereUniqueInput | ChoreHistoryWhereUniqueInput[]
    update?: ChoreHistoryUpdateWithWhereUniqueWithoutChoreInput | ChoreHistoryUpdateWithWhereUniqueWithoutChoreInput[]
    updateMany?: ChoreHistoryUpdateManyWithWhereWithoutChoreInput | ChoreHistoryUpdateManyWithWhereWithoutChoreInput[]
    deleteMany?: ChoreHistoryScalarWhereInput | ChoreHistoryScalarWhereInput[]
  }

  export type ChoreCreateNestedOneWithoutSubtasksInput = {
    create?: XOR<ChoreCreateWithoutSubtasksInput, ChoreUncheckedCreateWithoutSubtasksInput>
    connectOrCreate?: ChoreCreateOrConnectWithoutSubtasksInput
    connect?: ChoreWhereUniqueInput
  }

  export type EnumSubtaskStatusFieldUpdateOperationsInput = {
    set?: $Enums.SubtaskStatus
  }

  export type ChoreUpdateOneRequiredWithoutSubtasksNestedInput = {
    create?: XOR<ChoreCreateWithoutSubtasksInput, ChoreUncheckedCreateWithoutSubtasksInput>
    connectOrCreate?: ChoreCreateOrConnectWithoutSubtasksInput
    upsert?: ChoreUpsertWithoutSubtasksInput
    connect?: ChoreWhereUniqueInput
    update?: XOR<XOR<ChoreUpdateToOneWithWhereWithoutSubtasksInput, ChoreUpdateWithoutSubtasksInput>, ChoreUncheckedUpdateWithoutSubtasksInput>
  }

  export type ChoreCreateNestedOneWithoutAssignedUsersInput = {
    create?: XOR<ChoreCreateWithoutAssignedUsersInput, ChoreUncheckedCreateWithoutAssignedUsersInput>
    connectOrCreate?: ChoreCreateOrConnectWithoutAssignedUsersInput
    connect?: ChoreWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAssignedChoresInput = {
    create?: XOR<UserCreateWithoutAssignedChoresInput, UserUncheckedCreateWithoutAssignedChoresInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignedChoresInput
    connect?: UserWhereUniqueInput
  }

  export type ChoreUpdateOneRequiredWithoutAssignedUsersNestedInput = {
    create?: XOR<ChoreCreateWithoutAssignedUsersInput, ChoreUncheckedCreateWithoutAssignedUsersInput>
    connectOrCreate?: ChoreCreateOrConnectWithoutAssignedUsersInput
    upsert?: ChoreUpsertWithoutAssignedUsersInput
    connect?: ChoreWhereUniqueInput
    update?: XOR<XOR<ChoreUpdateToOneWithWhereWithoutAssignedUsersInput, ChoreUpdateWithoutAssignedUsersInput>, ChoreUncheckedUpdateWithoutAssignedUsersInput>
  }

  export type UserUpdateOneRequiredWithoutAssignedChoresNestedInput = {
    create?: XOR<UserCreateWithoutAssignedChoresInput, UserUncheckedCreateWithoutAssignedChoresInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignedChoresInput
    upsert?: UserUpsertWithoutAssignedChoresInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAssignedChoresInput, UserUpdateWithoutAssignedChoresInput>, UserUncheckedUpdateWithoutAssignedChoresInput>
  }

  export type UserCreateNestedOneWithoutChoreSwapRequestsInitiatedInput = {
    create?: XOR<UserCreateWithoutChoreSwapRequestsInitiatedInput, UserUncheckedCreateWithoutChoreSwapRequestsInitiatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutChoreSwapRequestsInitiatedInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutChoreSwapRequestsReceivedInput = {
    create?: XOR<UserCreateWithoutChoreSwapRequestsReceivedInput, UserUncheckedCreateWithoutChoreSwapRequestsReceivedInput>
    connectOrCreate?: UserCreateOrConnectWithoutChoreSwapRequestsReceivedInput
    connect?: UserWhereUniqueInput
  }

  export type ChoreCreateNestedOneWithoutChoreSwapRequestsInput = {
    create?: XOR<ChoreCreateWithoutChoreSwapRequestsInput, ChoreUncheckedCreateWithoutChoreSwapRequestsInput>
    connectOrCreate?: ChoreCreateOrConnectWithoutChoreSwapRequestsInput
    connect?: ChoreWhereUniqueInput
  }

  export type EnumChoreSwapRequestStatusFieldUpdateOperationsInput = {
    set?: $Enums.ChoreSwapRequestStatus
  }

  export type UserUpdateOneRequiredWithoutChoreSwapRequestsInitiatedNestedInput = {
    create?: XOR<UserCreateWithoutChoreSwapRequestsInitiatedInput, UserUncheckedCreateWithoutChoreSwapRequestsInitiatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutChoreSwapRequestsInitiatedInput
    upsert?: UserUpsertWithoutChoreSwapRequestsInitiatedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutChoreSwapRequestsInitiatedInput, UserUpdateWithoutChoreSwapRequestsInitiatedInput>, UserUncheckedUpdateWithoutChoreSwapRequestsInitiatedInput>
  }

  export type UserUpdateOneRequiredWithoutChoreSwapRequestsReceivedNestedInput = {
    create?: XOR<UserCreateWithoutChoreSwapRequestsReceivedInput, UserUncheckedCreateWithoutChoreSwapRequestsReceivedInput>
    connectOrCreate?: UserCreateOrConnectWithoutChoreSwapRequestsReceivedInput
    upsert?: UserUpsertWithoutChoreSwapRequestsReceivedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutChoreSwapRequestsReceivedInput, UserUpdateWithoutChoreSwapRequestsReceivedInput>, UserUncheckedUpdateWithoutChoreSwapRequestsReceivedInput>
  }

  export type ChoreUpdateOneRequiredWithoutChoreSwapRequestsNestedInput = {
    create?: XOR<ChoreCreateWithoutChoreSwapRequestsInput, ChoreUncheckedCreateWithoutChoreSwapRequestsInput>
    connectOrCreate?: ChoreCreateOrConnectWithoutChoreSwapRequestsInput
    upsert?: ChoreUpsertWithoutChoreSwapRequestsInput
    connect?: ChoreWhereUniqueInput
    update?: XOR<XOR<ChoreUpdateToOneWithWhereWithoutChoreSwapRequestsInput, ChoreUpdateWithoutChoreSwapRequestsInput>, ChoreUncheckedUpdateWithoutChoreSwapRequestsInput>
  }

  export type HouseholdCreateNestedOneWithoutChoreTemplatesInput = {
    create?: XOR<HouseholdCreateWithoutChoreTemplatesInput, HouseholdUncheckedCreateWithoutChoreTemplatesInput>
    connectOrCreate?: HouseholdCreateOrConnectWithoutChoreTemplatesInput
    connect?: HouseholdWhereUniqueInput
  }

  export type SubtaskTemplateCreateNestedManyWithoutChoreTemplateInput = {
    create?: XOR<SubtaskTemplateCreateWithoutChoreTemplateInput, SubtaskTemplateUncheckedCreateWithoutChoreTemplateInput> | SubtaskTemplateCreateWithoutChoreTemplateInput[] | SubtaskTemplateUncheckedCreateWithoutChoreTemplateInput[]
    connectOrCreate?: SubtaskTemplateCreateOrConnectWithoutChoreTemplateInput | SubtaskTemplateCreateOrConnectWithoutChoreTemplateInput[]
    createMany?: SubtaskTemplateCreateManyChoreTemplateInputEnvelope
    connect?: SubtaskTemplateWhereUniqueInput | SubtaskTemplateWhereUniqueInput[]
  }

  export type SubtaskTemplateUncheckedCreateNestedManyWithoutChoreTemplateInput = {
    create?: XOR<SubtaskTemplateCreateWithoutChoreTemplateInput, SubtaskTemplateUncheckedCreateWithoutChoreTemplateInput> | SubtaskTemplateCreateWithoutChoreTemplateInput[] | SubtaskTemplateUncheckedCreateWithoutChoreTemplateInput[]
    connectOrCreate?: SubtaskTemplateCreateOrConnectWithoutChoreTemplateInput | SubtaskTemplateCreateOrConnectWithoutChoreTemplateInput[]
    createMany?: SubtaskTemplateCreateManyChoreTemplateInputEnvelope
    connect?: SubtaskTemplateWhereUniqueInput | SubtaskTemplateWhereUniqueInput[]
  }

  export type HouseholdUpdateOneRequiredWithoutChoreTemplatesNestedInput = {
    create?: XOR<HouseholdCreateWithoutChoreTemplatesInput, HouseholdUncheckedCreateWithoutChoreTemplatesInput>
    connectOrCreate?: HouseholdCreateOrConnectWithoutChoreTemplatesInput
    upsert?: HouseholdUpsertWithoutChoreTemplatesInput
    connect?: HouseholdWhereUniqueInput
    update?: XOR<XOR<HouseholdUpdateToOneWithWhereWithoutChoreTemplatesInput, HouseholdUpdateWithoutChoreTemplatesInput>, HouseholdUncheckedUpdateWithoutChoreTemplatesInput>
  }

  export type SubtaskTemplateUpdateManyWithoutChoreTemplateNestedInput = {
    create?: XOR<SubtaskTemplateCreateWithoutChoreTemplateInput, SubtaskTemplateUncheckedCreateWithoutChoreTemplateInput> | SubtaskTemplateCreateWithoutChoreTemplateInput[] | SubtaskTemplateUncheckedCreateWithoutChoreTemplateInput[]
    connectOrCreate?: SubtaskTemplateCreateOrConnectWithoutChoreTemplateInput | SubtaskTemplateCreateOrConnectWithoutChoreTemplateInput[]
    upsert?: SubtaskTemplateUpsertWithWhereUniqueWithoutChoreTemplateInput | SubtaskTemplateUpsertWithWhereUniqueWithoutChoreTemplateInput[]
    createMany?: SubtaskTemplateCreateManyChoreTemplateInputEnvelope
    set?: SubtaskTemplateWhereUniqueInput | SubtaskTemplateWhereUniqueInput[]
    disconnect?: SubtaskTemplateWhereUniqueInput | SubtaskTemplateWhereUniqueInput[]
    delete?: SubtaskTemplateWhereUniqueInput | SubtaskTemplateWhereUniqueInput[]
    connect?: SubtaskTemplateWhereUniqueInput | SubtaskTemplateWhereUniqueInput[]
    update?: SubtaskTemplateUpdateWithWhereUniqueWithoutChoreTemplateInput | SubtaskTemplateUpdateWithWhereUniqueWithoutChoreTemplateInput[]
    updateMany?: SubtaskTemplateUpdateManyWithWhereWithoutChoreTemplateInput | SubtaskTemplateUpdateManyWithWhereWithoutChoreTemplateInput[]
    deleteMany?: SubtaskTemplateScalarWhereInput | SubtaskTemplateScalarWhereInput[]
  }

  export type SubtaskTemplateUncheckedUpdateManyWithoutChoreTemplateNestedInput = {
    create?: XOR<SubtaskTemplateCreateWithoutChoreTemplateInput, SubtaskTemplateUncheckedCreateWithoutChoreTemplateInput> | SubtaskTemplateCreateWithoutChoreTemplateInput[] | SubtaskTemplateUncheckedCreateWithoutChoreTemplateInput[]
    connectOrCreate?: SubtaskTemplateCreateOrConnectWithoutChoreTemplateInput | SubtaskTemplateCreateOrConnectWithoutChoreTemplateInput[]
    upsert?: SubtaskTemplateUpsertWithWhereUniqueWithoutChoreTemplateInput | SubtaskTemplateUpsertWithWhereUniqueWithoutChoreTemplateInput[]
    createMany?: SubtaskTemplateCreateManyChoreTemplateInputEnvelope
    set?: SubtaskTemplateWhereUniqueInput | SubtaskTemplateWhereUniqueInput[]
    disconnect?: SubtaskTemplateWhereUniqueInput | SubtaskTemplateWhereUniqueInput[]
    delete?: SubtaskTemplateWhereUniqueInput | SubtaskTemplateWhereUniqueInput[]
    connect?: SubtaskTemplateWhereUniqueInput | SubtaskTemplateWhereUniqueInput[]
    update?: SubtaskTemplateUpdateWithWhereUniqueWithoutChoreTemplateInput | SubtaskTemplateUpdateWithWhereUniqueWithoutChoreTemplateInput[]
    updateMany?: SubtaskTemplateUpdateManyWithWhereWithoutChoreTemplateInput | SubtaskTemplateUpdateManyWithWhereWithoutChoreTemplateInput[]
    deleteMany?: SubtaskTemplateScalarWhereInput | SubtaskTemplateScalarWhereInput[]
  }

  export type ChoreTemplateCreateNestedOneWithoutSubtasksInput = {
    create?: XOR<ChoreTemplateCreateWithoutSubtasksInput, ChoreTemplateUncheckedCreateWithoutSubtasksInput>
    connectOrCreate?: ChoreTemplateCreateOrConnectWithoutSubtasksInput
    connect?: ChoreTemplateWhereUniqueInput
  }

  export type ChoreTemplateUpdateOneRequiredWithoutSubtasksNestedInput = {
    create?: XOR<ChoreTemplateCreateWithoutSubtasksInput, ChoreTemplateUncheckedCreateWithoutSubtasksInput>
    connectOrCreate?: ChoreTemplateCreateOrConnectWithoutSubtasksInput
    upsert?: ChoreTemplateUpsertWithoutSubtasksInput
    connect?: ChoreTemplateWhereUniqueInput
    update?: XOR<XOR<ChoreTemplateUpdateToOneWithWhereWithoutSubtasksInput, ChoreTemplateUpdateWithoutSubtasksInput>, ChoreTemplateUncheckedUpdateWithoutSubtasksInput>
  }

  export type ChoreCreateNestedOneWithoutHistoryInput = {
    create?: XOR<ChoreCreateWithoutHistoryInput, ChoreUncheckedCreateWithoutHistoryInput>
    connectOrCreate?: ChoreCreateOrConnectWithoutHistoryInput
    connect?: ChoreWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutChoreHistoryInput = {
    create?: XOR<UserCreateWithoutChoreHistoryInput, UserUncheckedCreateWithoutChoreHistoryInput>
    connectOrCreate?: UserCreateOrConnectWithoutChoreHistoryInput
    connect?: UserWhereUniqueInput
  }

  export type EnumChoreActionFieldUpdateOperationsInput = {
    set?: $Enums.ChoreAction
  }

  export type ChoreUpdateOneRequiredWithoutHistoryNestedInput = {
    create?: XOR<ChoreCreateWithoutHistoryInput, ChoreUncheckedCreateWithoutHistoryInput>
    connectOrCreate?: ChoreCreateOrConnectWithoutHistoryInput
    upsert?: ChoreUpsertWithoutHistoryInput
    connect?: ChoreWhereUniqueInput
    update?: XOR<XOR<ChoreUpdateToOneWithWhereWithoutHistoryInput, ChoreUpdateWithoutHistoryInput>, ChoreUncheckedUpdateWithoutHistoryInput>
  }

  export type UserUpdateOneRequiredWithoutChoreHistoryNestedInput = {
    create?: XOR<UserCreateWithoutChoreHistoryInput, UserUncheckedCreateWithoutChoreHistoryInput>
    connectOrCreate?: UserCreateOrConnectWithoutChoreHistoryInput
    upsert?: UserUpsertWithoutChoreHistoryInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutChoreHistoryInput, UserUpdateWithoutChoreHistoryInput>, UserUncheckedUpdateWithoutChoreHistoryInput>
  }

  export type HouseholdCreateNestedOneWithoutExpensesInput = {
    create?: XOR<HouseholdCreateWithoutExpensesInput, HouseholdUncheckedCreateWithoutExpensesInput>
    connectOrCreate?: HouseholdCreateOrConnectWithoutExpensesInput
    connect?: HouseholdWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutExpensesPaidInput = {
    create?: XOR<UserCreateWithoutExpensesPaidInput, UserUncheckedCreateWithoutExpensesPaidInput>
    connectOrCreate?: UserCreateOrConnectWithoutExpensesPaidInput
    connect?: UserWhereUniqueInput
  }

  export type ExpenseSplitCreateNestedManyWithoutExpenseInput = {
    create?: XOR<ExpenseSplitCreateWithoutExpenseInput, ExpenseSplitUncheckedCreateWithoutExpenseInput> | ExpenseSplitCreateWithoutExpenseInput[] | ExpenseSplitUncheckedCreateWithoutExpenseInput[]
    connectOrCreate?: ExpenseSplitCreateOrConnectWithoutExpenseInput | ExpenseSplitCreateOrConnectWithoutExpenseInput[]
    createMany?: ExpenseSplitCreateManyExpenseInputEnvelope
    connect?: ExpenseSplitWhereUniqueInput | ExpenseSplitWhereUniqueInput[]
  }

  export type TransactionCreateNestedManyWithoutExpenseInput = {
    create?: XOR<TransactionCreateWithoutExpenseInput, TransactionUncheckedCreateWithoutExpenseInput> | TransactionCreateWithoutExpenseInput[] | TransactionUncheckedCreateWithoutExpenseInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutExpenseInput | TransactionCreateOrConnectWithoutExpenseInput[]
    createMany?: TransactionCreateManyExpenseInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type ReceiptCreateNestedManyWithoutExpenseInput = {
    create?: XOR<ReceiptCreateWithoutExpenseInput, ReceiptUncheckedCreateWithoutExpenseInput> | ReceiptCreateWithoutExpenseInput[] | ReceiptUncheckedCreateWithoutExpenseInput[]
    connectOrCreate?: ReceiptCreateOrConnectWithoutExpenseInput | ReceiptCreateOrConnectWithoutExpenseInput[]
    createMany?: ReceiptCreateManyExpenseInputEnvelope
    connect?: ReceiptWhereUniqueInput | ReceiptWhereUniqueInput[]
  }

  export type ExpenseHistoryCreateNestedManyWithoutExpenseInput = {
    create?: XOR<ExpenseHistoryCreateWithoutExpenseInput, ExpenseHistoryUncheckedCreateWithoutExpenseInput> | ExpenseHistoryCreateWithoutExpenseInput[] | ExpenseHistoryUncheckedCreateWithoutExpenseInput[]
    connectOrCreate?: ExpenseHistoryCreateOrConnectWithoutExpenseInput | ExpenseHistoryCreateOrConnectWithoutExpenseInput[]
    createMany?: ExpenseHistoryCreateManyExpenseInputEnvelope
    connect?: ExpenseHistoryWhereUniqueInput | ExpenseHistoryWhereUniqueInput[]
  }

  export type ExpenseSplitUncheckedCreateNestedManyWithoutExpenseInput = {
    create?: XOR<ExpenseSplitCreateWithoutExpenseInput, ExpenseSplitUncheckedCreateWithoutExpenseInput> | ExpenseSplitCreateWithoutExpenseInput[] | ExpenseSplitUncheckedCreateWithoutExpenseInput[]
    connectOrCreate?: ExpenseSplitCreateOrConnectWithoutExpenseInput | ExpenseSplitCreateOrConnectWithoutExpenseInput[]
    createMany?: ExpenseSplitCreateManyExpenseInputEnvelope
    connect?: ExpenseSplitWhereUniqueInput | ExpenseSplitWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutExpenseInput = {
    create?: XOR<TransactionCreateWithoutExpenseInput, TransactionUncheckedCreateWithoutExpenseInput> | TransactionCreateWithoutExpenseInput[] | TransactionUncheckedCreateWithoutExpenseInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutExpenseInput | TransactionCreateOrConnectWithoutExpenseInput[]
    createMany?: TransactionCreateManyExpenseInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type ReceiptUncheckedCreateNestedManyWithoutExpenseInput = {
    create?: XOR<ReceiptCreateWithoutExpenseInput, ReceiptUncheckedCreateWithoutExpenseInput> | ReceiptCreateWithoutExpenseInput[] | ReceiptUncheckedCreateWithoutExpenseInput[]
    connectOrCreate?: ReceiptCreateOrConnectWithoutExpenseInput | ReceiptCreateOrConnectWithoutExpenseInput[]
    createMany?: ReceiptCreateManyExpenseInputEnvelope
    connect?: ReceiptWhereUniqueInput | ReceiptWhereUniqueInput[]
  }

  export type ExpenseHistoryUncheckedCreateNestedManyWithoutExpenseInput = {
    create?: XOR<ExpenseHistoryCreateWithoutExpenseInput, ExpenseHistoryUncheckedCreateWithoutExpenseInput> | ExpenseHistoryCreateWithoutExpenseInput[] | ExpenseHistoryUncheckedCreateWithoutExpenseInput[]
    connectOrCreate?: ExpenseHistoryCreateOrConnectWithoutExpenseInput | ExpenseHistoryCreateOrConnectWithoutExpenseInput[]
    createMany?: ExpenseHistoryCreateManyExpenseInputEnvelope
    connect?: ExpenseHistoryWhereUniqueInput | ExpenseHistoryWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumExpenseCategoryFieldUpdateOperationsInput = {
    set?: $Enums.ExpenseCategory
  }

  export type HouseholdUpdateOneRequiredWithoutExpensesNestedInput = {
    create?: XOR<HouseholdCreateWithoutExpensesInput, HouseholdUncheckedCreateWithoutExpensesInput>
    connectOrCreate?: HouseholdCreateOrConnectWithoutExpensesInput
    upsert?: HouseholdUpsertWithoutExpensesInput
    connect?: HouseholdWhereUniqueInput
    update?: XOR<XOR<HouseholdUpdateToOneWithWhereWithoutExpensesInput, HouseholdUpdateWithoutExpensesInput>, HouseholdUncheckedUpdateWithoutExpensesInput>
  }

  export type UserUpdateOneRequiredWithoutExpensesPaidNestedInput = {
    create?: XOR<UserCreateWithoutExpensesPaidInput, UserUncheckedCreateWithoutExpensesPaidInput>
    connectOrCreate?: UserCreateOrConnectWithoutExpensesPaidInput
    upsert?: UserUpsertWithoutExpensesPaidInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutExpensesPaidInput, UserUpdateWithoutExpensesPaidInput>, UserUncheckedUpdateWithoutExpensesPaidInput>
  }

  export type ExpenseSplitUpdateManyWithoutExpenseNestedInput = {
    create?: XOR<ExpenseSplitCreateWithoutExpenseInput, ExpenseSplitUncheckedCreateWithoutExpenseInput> | ExpenseSplitCreateWithoutExpenseInput[] | ExpenseSplitUncheckedCreateWithoutExpenseInput[]
    connectOrCreate?: ExpenseSplitCreateOrConnectWithoutExpenseInput | ExpenseSplitCreateOrConnectWithoutExpenseInput[]
    upsert?: ExpenseSplitUpsertWithWhereUniqueWithoutExpenseInput | ExpenseSplitUpsertWithWhereUniqueWithoutExpenseInput[]
    createMany?: ExpenseSplitCreateManyExpenseInputEnvelope
    set?: ExpenseSplitWhereUniqueInput | ExpenseSplitWhereUniqueInput[]
    disconnect?: ExpenseSplitWhereUniqueInput | ExpenseSplitWhereUniqueInput[]
    delete?: ExpenseSplitWhereUniqueInput | ExpenseSplitWhereUniqueInput[]
    connect?: ExpenseSplitWhereUniqueInput | ExpenseSplitWhereUniqueInput[]
    update?: ExpenseSplitUpdateWithWhereUniqueWithoutExpenseInput | ExpenseSplitUpdateWithWhereUniqueWithoutExpenseInput[]
    updateMany?: ExpenseSplitUpdateManyWithWhereWithoutExpenseInput | ExpenseSplitUpdateManyWithWhereWithoutExpenseInput[]
    deleteMany?: ExpenseSplitScalarWhereInput | ExpenseSplitScalarWhereInput[]
  }

  export type TransactionUpdateManyWithoutExpenseNestedInput = {
    create?: XOR<TransactionCreateWithoutExpenseInput, TransactionUncheckedCreateWithoutExpenseInput> | TransactionCreateWithoutExpenseInput[] | TransactionUncheckedCreateWithoutExpenseInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutExpenseInput | TransactionCreateOrConnectWithoutExpenseInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutExpenseInput | TransactionUpsertWithWhereUniqueWithoutExpenseInput[]
    createMany?: TransactionCreateManyExpenseInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutExpenseInput | TransactionUpdateWithWhereUniqueWithoutExpenseInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutExpenseInput | TransactionUpdateManyWithWhereWithoutExpenseInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type ReceiptUpdateManyWithoutExpenseNestedInput = {
    create?: XOR<ReceiptCreateWithoutExpenseInput, ReceiptUncheckedCreateWithoutExpenseInput> | ReceiptCreateWithoutExpenseInput[] | ReceiptUncheckedCreateWithoutExpenseInput[]
    connectOrCreate?: ReceiptCreateOrConnectWithoutExpenseInput | ReceiptCreateOrConnectWithoutExpenseInput[]
    upsert?: ReceiptUpsertWithWhereUniqueWithoutExpenseInput | ReceiptUpsertWithWhereUniqueWithoutExpenseInput[]
    createMany?: ReceiptCreateManyExpenseInputEnvelope
    set?: ReceiptWhereUniqueInput | ReceiptWhereUniqueInput[]
    disconnect?: ReceiptWhereUniqueInput | ReceiptWhereUniqueInput[]
    delete?: ReceiptWhereUniqueInput | ReceiptWhereUniqueInput[]
    connect?: ReceiptWhereUniqueInput | ReceiptWhereUniqueInput[]
    update?: ReceiptUpdateWithWhereUniqueWithoutExpenseInput | ReceiptUpdateWithWhereUniqueWithoutExpenseInput[]
    updateMany?: ReceiptUpdateManyWithWhereWithoutExpenseInput | ReceiptUpdateManyWithWhereWithoutExpenseInput[]
    deleteMany?: ReceiptScalarWhereInput | ReceiptScalarWhereInput[]
  }

  export type ExpenseHistoryUpdateManyWithoutExpenseNestedInput = {
    create?: XOR<ExpenseHistoryCreateWithoutExpenseInput, ExpenseHistoryUncheckedCreateWithoutExpenseInput> | ExpenseHistoryCreateWithoutExpenseInput[] | ExpenseHistoryUncheckedCreateWithoutExpenseInput[]
    connectOrCreate?: ExpenseHistoryCreateOrConnectWithoutExpenseInput | ExpenseHistoryCreateOrConnectWithoutExpenseInput[]
    upsert?: ExpenseHistoryUpsertWithWhereUniqueWithoutExpenseInput | ExpenseHistoryUpsertWithWhereUniqueWithoutExpenseInput[]
    createMany?: ExpenseHistoryCreateManyExpenseInputEnvelope
    set?: ExpenseHistoryWhereUniqueInput | ExpenseHistoryWhereUniqueInput[]
    disconnect?: ExpenseHistoryWhereUniqueInput | ExpenseHistoryWhereUniqueInput[]
    delete?: ExpenseHistoryWhereUniqueInput | ExpenseHistoryWhereUniqueInput[]
    connect?: ExpenseHistoryWhereUniqueInput | ExpenseHistoryWhereUniqueInput[]
    update?: ExpenseHistoryUpdateWithWhereUniqueWithoutExpenseInput | ExpenseHistoryUpdateWithWhereUniqueWithoutExpenseInput[]
    updateMany?: ExpenseHistoryUpdateManyWithWhereWithoutExpenseInput | ExpenseHistoryUpdateManyWithWhereWithoutExpenseInput[]
    deleteMany?: ExpenseHistoryScalarWhereInput | ExpenseHistoryScalarWhereInput[]
  }

  export type ExpenseSplitUncheckedUpdateManyWithoutExpenseNestedInput = {
    create?: XOR<ExpenseSplitCreateWithoutExpenseInput, ExpenseSplitUncheckedCreateWithoutExpenseInput> | ExpenseSplitCreateWithoutExpenseInput[] | ExpenseSplitUncheckedCreateWithoutExpenseInput[]
    connectOrCreate?: ExpenseSplitCreateOrConnectWithoutExpenseInput | ExpenseSplitCreateOrConnectWithoutExpenseInput[]
    upsert?: ExpenseSplitUpsertWithWhereUniqueWithoutExpenseInput | ExpenseSplitUpsertWithWhereUniqueWithoutExpenseInput[]
    createMany?: ExpenseSplitCreateManyExpenseInputEnvelope
    set?: ExpenseSplitWhereUniqueInput | ExpenseSplitWhereUniqueInput[]
    disconnect?: ExpenseSplitWhereUniqueInput | ExpenseSplitWhereUniqueInput[]
    delete?: ExpenseSplitWhereUniqueInput | ExpenseSplitWhereUniqueInput[]
    connect?: ExpenseSplitWhereUniqueInput | ExpenseSplitWhereUniqueInput[]
    update?: ExpenseSplitUpdateWithWhereUniqueWithoutExpenseInput | ExpenseSplitUpdateWithWhereUniqueWithoutExpenseInput[]
    updateMany?: ExpenseSplitUpdateManyWithWhereWithoutExpenseInput | ExpenseSplitUpdateManyWithWhereWithoutExpenseInput[]
    deleteMany?: ExpenseSplitScalarWhereInput | ExpenseSplitScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutExpenseNestedInput = {
    create?: XOR<TransactionCreateWithoutExpenseInput, TransactionUncheckedCreateWithoutExpenseInput> | TransactionCreateWithoutExpenseInput[] | TransactionUncheckedCreateWithoutExpenseInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutExpenseInput | TransactionCreateOrConnectWithoutExpenseInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutExpenseInput | TransactionUpsertWithWhereUniqueWithoutExpenseInput[]
    createMany?: TransactionCreateManyExpenseInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutExpenseInput | TransactionUpdateWithWhereUniqueWithoutExpenseInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutExpenseInput | TransactionUpdateManyWithWhereWithoutExpenseInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type ReceiptUncheckedUpdateManyWithoutExpenseNestedInput = {
    create?: XOR<ReceiptCreateWithoutExpenseInput, ReceiptUncheckedCreateWithoutExpenseInput> | ReceiptCreateWithoutExpenseInput[] | ReceiptUncheckedCreateWithoutExpenseInput[]
    connectOrCreate?: ReceiptCreateOrConnectWithoutExpenseInput | ReceiptCreateOrConnectWithoutExpenseInput[]
    upsert?: ReceiptUpsertWithWhereUniqueWithoutExpenseInput | ReceiptUpsertWithWhereUniqueWithoutExpenseInput[]
    createMany?: ReceiptCreateManyExpenseInputEnvelope
    set?: ReceiptWhereUniqueInput | ReceiptWhereUniqueInput[]
    disconnect?: ReceiptWhereUniqueInput | ReceiptWhereUniqueInput[]
    delete?: ReceiptWhereUniqueInput | ReceiptWhereUniqueInput[]
    connect?: ReceiptWhereUniqueInput | ReceiptWhereUniqueInput[]
    update?: ReceiptUpdateWithWhereUniqueWithoutExpenseInput | ReceiptUpdateWithWhereUniqueWithoutExpenseInput[]
    updateMany?: ReceiptUpdateManyWithWhereWithoutExpenseInput | ReceiptUpdateManyWithWhereWithoutExpenseInput[]
    deleteMany?: ReceiptScalarWhereInput | ReceiptScalarWhereInput[]
  }

  export type ExpenseHistoryUncheckedUpdateManyWithoutExpenseNestedInput = {
    create?: XOR<ExpenseHistoryCreateWithoutExpenseInput, ExpenseHistoryUncheckedCreateWithoutExpenseInput> | ExpenseHistoryCreateWithoutExpenseInput[] | ExpenseHistoryUncheckedCreateWithoutExpenseInput[]
    connectOrCreate?: ExpenseHistoryCreateOrConnectWithoutExpenseInput | ExpenseHistoryCreateOrConnectWithoutExpenseInput[]
    upsert?: ExpenseHistoryUpsertWithWhereUniqueWithoutExpenseInput | ExpenseHistoryUpsertWithWhereUniqueWithoutExpenseInput[]
    createMany?: ExpenseHistoryCreateManyExpenseInputEnvelope
    set?: ExpenseHistoryWhereUniqueInput | ExpenseHistoryWhereUniqueInput[]
    disconnect?: ExpenseHistoryWhereUniqueInput | ExpenseHistoryWhereUniqueInput[]
    delete?: ExpenseHistoryWhereUniqueInput | ExpenseHistoryWhereUniqueInput[]
    connect?: ExpenseHistoryWhereUniqueInput | ExpenseHistoryWhereUniqueInput[]
    update?: ExpenseHistoryUpdateWithWhereUniqueWithoutExpenseInput | ExpenseHistoryUpdateWithWhereUniqueWithoutExpenseInput[]
    updateMany?: ExpenseHistoryUpdateManyWithWhereWithoutExpenseInput | ExpenseHistoryUpdateManyWithWhereWithoutExpenseInput[]
    deleteMany?: ExpenseHistoryScalarWhereInput | ExpenseHistoryScalarWhereInput[]
  }

  export type ExpenseCreateNestedOneWithoutSplitsInput = {
    create?: XOR<ExpenseCreateWithoutSplitsInput, ExpenseUncheckedCreateWithoutSplitsInput>
    connectOrCreate?: ExpenseCreateOrConnectWithoutSplitsInput
    connect?: ExpenseWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutExpenseSplitsInput = {
    create?: XOR<UserCreateWithoutExpenseSplitsInput, UserUncheckedCreateWithoutExpenseSplitsInput>
    connectOrCreate?: UserCreateOrConnectWithoutExpenseSplitsInput
    connect?: UserWhereUniqueInput
  }

  export type ExpenseUpdateOneRequiredWithoutSplitsNestedInput = {
    create?: XOR<ExpenseCreateWithoutSplitsInput, ExpenseUncheckedCreateWithoutSplitsInput>
    connectOrCreate?: ExpenseCreateOrConnectWithoutSplitsInput
    upsert?: ExpenseUpsertWithoutSplitsInput
    connect?: ExpenseWhereUniqueInput
    update?: XOR<XOR<ExpenseUpdateToOneWithWhereWithoutSplitsInput, ExpenseUpdateWithoutSplitsInput>, ExpenseUncheckedUpdateWithoutSplitsInput>
  }

  export type UserUpdateOneRequiredWithoutExpenseSplitsNestedInput = {
    create?: XOR<UserCreateWithoutExpenseSplitsInput, UserUncheckedCreateWithoutExpenseSplitsInput>
    connectOrCreate?: UserCreateOrConnectWithoutExpenseSplitsInput
    upsert?: UserUpsertWithoutExpenseSplitsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutExpenseSplitsInput, UserUpdateWithoutExpenseSplitsInput>, UserUncheckedUpdateWithoutExpenseSplitsInput>
  }

  export type ExpenseCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<ExpenseCreateWithoutTransactionsInput, ExpenseUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: ExpenseCreateOrConnectWithoutTransactionsInput
    connect?: ExpenseWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTransactionsFromInput = {
    create?: XOR<UserCreateWithoutTransactionsFromInput, UserUncheckedCreateWithoutTransactionsFromInput>
    connectOrCreate?: UserCreateOrConnectWithoutTransactionsFromInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTransactionsToInput = {
    create?: XOR<UserCreateWithoutTransactionsToInput, UserUncheckedCreateWithoutTransactionsToInput>
    connectOrCreate?: UserCreateOrConnectWithoutTransactionsToInput
    connect?: UserWhereUniqueInput
  }

  export type EnumTransactionStatusFieldUpdateOperationsInput = {
    set?: $Enums.TransactionStatus
  }

  export type ExpenseUpdateOneRequiredWithoutTransactionsNestedInput = {
    create?: XOR<ExpenseCreateWithoutTransactionsInput, ExpenseUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: ExpenseCreateOrConnectWithoutTransactionsInput
    upsert?: ExpenseUpsertWithoutTransactionsInput
    connect?: ExpenseWhereUniqueInput
    update?: XOR<XOR<ExpenseUpdateToOneWithWhereWithoutTransactionsInput, ExpenseUpdateWithoutTransactionsInput>, ExpenseUncheckedUpdateWithoutTransactionsInput>
  }

  export type UserUpdateOneRequiredWithoutTransactionsFromNestedInput = {
    create?: XOR<UserCreateWithoutTransactionsFromInput, UserUncheckedCreateWithoutTransactionsFromInput>
    connectOrCreate?: UserCreateOrConnectWithoutTransactionsFromInput
    upsert?: UserUpsertWithoutTransactionsFromInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTransactionsFromInput, UserUpdateWithoutTransactionsFromInput>, UserUncheckedUpdateWithoutTransactionsFromInput>
  }

  export type UserUpdateOneRequiredWithoutTransactionsToNestedInput = {
    create?: XOR<UserCreateWithoutTransactionsToInput, UserUncheckedCreateWithoutTransactionsToInput>
    connectOrCreate?: UserCreateOrConnectWithoutTransactionsToInput
    upsert?: UserUpsertWithoutTransactionsToInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTransactionsToInput, UserUpdateWithoutTransactionsToInput>, UserUncheckedUpdateWithoutTransactionsToInput>
  }

  export type ExpenseCreateNestedOneWithoutReceiptsInput = {
    create?: XOR<ExpenseCreateWithoutReceiptsInput, ExpenseUncheckedCreateWithoutReceiptsInput>
    connectOrCreate?: ExpenseCreateOrConnectWithoutReceiptsInput
    connect?: ExpenseWhereUniqueInput
  }

  export type ExpenseUpdateOneRequiredWithoutReceiptsNestedInput = {
    create?: XOR<ExpenseCreateWithoutReceiptsInput, ExpenseUncheckedCreateWithoutReceiptsInput>
    connectOrCreate?: ExpenseCreateOrConnectWithoutReceiptsInput
    upsert?: ExpenseUpsertWithoutReceiptsInput
    connect?: ExpenseWhereUniqueInput
    update?: XOR<XOR<ExpenseUpdateToOneWithWhereWithoutReceiptsInput, ExpenseUpdateWithoutReceiptsInput>, ExpenseUncheckedUpdateWithoutReceiptsInput>
  }

  export type ExpenseCreateNestedOneWithoutHistoryInput = {
    create?: XOR<ExpenseCreateWithoutHistoryInput, ExpenseUncheckedCreateWithoutHistoryInput>
    connectOrCreate?: ExpenseCreateOrConnectWithoutHistoryInput
    connect?: ExpenseWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutExpenseHistoryInput = {
    create?: XOR<UserCreateWithoutExpenseHistoryInput, UserUncheckedCreateWithoutExpenseHistoryInput>
    connectOrCreate?: UserCreateOrConnectWithoutExpenseHistoryInput
    connect?: UserWhereUniqueInput
  }

  export type EnumExpenseActionFieldUpdateOperationsInput = {
    set?: $Enums.ExpenseAction
  }

  export type ExpenseUpdateOneRequiredWithoutHistoryNestedInput = {
    create?: XOR<ExpenseCreateWithoutHistoryInput, ExpenseUncheckedCreateWithoutHistoryInput>
    connectOrCreate?: ExpenseCreateOrConnectWithoutHistoryInput
    upsert?: ExpenseUpsertWithoutHistoryInput
    connect?: ExpenseWhereUniqueInput
    update?: XOR<XOR<ExpenseUpdateToOneWithWhereWithoutHistoryInput, ExpenseUpdateWithoutHistoryInput>, ExpenseUncheckedUpdateWithoutHistoryInput>
  }

  export type UserUpdateOneRequiredWithoutExpenseHistoryNestedInput = {
    create?: XOR<UserCreateWithoutExpenseHistoryInput, UserUncheckedCreateWithoutExpenseHistoryInput>
    connectOrCreate?: UserCreateOrConnectWithoutExpenseHistoryInput
    upsert?: UserUpsertWithoutExpenseHistoryInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutExpenseHistoryInput, UserUpdateWithoutExpenseHistoryInput>, UserUncheckedUpdateWithoutExpenseHistoryInput>
  }

  export type EventReminderCreateNestedManyWithoutEventInput = {
    create?: XOR<EventReminderCreateWithoutEventInput, EventReminderUncheckedCreateWithoutEventInput> | EventReminderCreateWithoutEventInput[] | EventReminderUncheckedCreateWithoutEventInput[]
    connectOrCreate?: EventReminderCreateOrConnectWithoutEventInput | EventReminderCreateOrConnectWithoutEventInput[]
    createMany?: EventReminderCreateManyEventInputEnvelope
    connect?: EventReminderWhereUniqueInput | EventReminderWhereUniqueInput[]
  }

  export type HouseholdCreateNestedOneWithoutEventsInput = {
    create?: XOR<HouseholdCreateWithoutEventsInput, HouseholdUncheckedCreateWithoutEventsInput>
    connectOrCreate?: HouseholdCreateOrConnectWithoutEventsInput
    connect?: HouseholdWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutEventsCreatedInput = {
    create?: XOR<UserCreateWithoutEventsCreatedInput, UserUncheckedCreateWithoutEventsCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutEventsCreatedInput
    connect?: UserWhereUniqueInput
  }

  export type ChoreCreateNestedOneWithoutEventInput = {
    create?: XOR<ChoreCreateWithoutEventInput, ChoreUncheckedCreateWithoutEventInput>
    connectOrCreate?: ChoreCreateOrConnectWithoutEventInput
    connect?: ChoreWhereUniqueInput
  }

  export type RecurrenceRuleCreateNestedOneWithoutEventsInput = {
    create?: XOR<RecurrenceRuleCreateWithoutEventsInput, RecurrenceRuleUncheckedCreateWithoutEventsInput>
    connectOrCreate?: RecurrenceRuleCreateOrConnectWithoutEventsInput
    connect?: RecurrenceRuleWhereUniqueInput
  }

  export type CalendarEventHistoryCreateNestedManyWithoutEventInput = {
    create?: XOR<CalendarEventHistoryCreateWithoutEventInput, CalendarEventHistoryUncheckedCreateWithoutEventInput> | CalendarEventHistoryCreateWithoutEventInput[] | CalendarEventHistoryUncheckedCreateWithoutEventInput[]
    connectOrCreate?: CalendarEventHistoryCreateOrConnectWithoutEventInput | CalendarEventHistoryCreateOrConnectWithoutEventInput[]
    createMany?: CalendarEventHistoryCreateManyEventInputEnvelope
    connect?: CalendarEventHistoryWhereUniqueInput | CalendarEventHistoryWhereUniqueInput[]
  }

  export type EventReminderUncheckedCreateNestedManyWithoutEventInput = {
    create?: XOR<EventReminderCreateWithoutEventInput, EventReminderUncheckedCreateWithoutEventInput> | EventReminderCreateWithoutEventInput[] | EventReminderUncheckedCreateWithoutEventInput[]
    connectOrCreate?: EventReminderCreateOrConnectWithoutEventInput | EventReminderCreateOrConnectWithoutEventInput[]
    createMany?: EventReminderCreateManyEventInputEnvelope
    connect?: EventReminderWhereUniqueInput | EventReminderWhereUniqueInput[]
  }

  export type ChoreUncheckedCreateNestedOneWithoutEventInput = {
    create?: XOR<ChoreCreateWithoutEventInput, ChoreUncheckedCreateWithoutEventInput>
    connectOrCreate?: ChoreCreateOrConnectWithoutEventInput
    connect?: ChoreWhereUniqueInput
  }

  export type CalendarEventHistoryUncheckedCreateNestedManyWithoutEventInput = {
    create?: XOR<CalendarEventHistoryCreateWithoutEventInput, CalendarEventHistoryUncheckedCreateWithoutEventInput> | CalendarEventHistoryCreateWithoutEventInput[] | CalendarEventHistoryUncheckedCreateWithoutEventInput[]
    connectOrCreate?: CalendarEventHistoryCreateOrConnectWithoutEventInput | CalendarEventHistoryCreateOrConnectWithoutEventInput[]
    createMany?: CalendarEventHistoryCreateManyEventInputEnvelope
    connect?: CalendarEventHistoryWhereUniqueInput | CalendarEventHistoryWhereUniqueInput[]
  }

  export type EnumEventCategoryFieldUpdateOperationsInput = {
    set?: $Enums.EventCategory
  }

  export type EnumEventStatusFieldUpdateOperationsInput = {
    set?: $Enums.EventStatus
  }

  export type EventReminderUpdateManyWithoutEventNestedInput = {
    create?: XOR<EventReminderCreateWithoutEventInput, EventReminderUncheckedCreateWithoutEventInput> | EventReminderCreateWithoutEventInput[] | EventReminderUncheckedCreateWithoutEventInput[]
    connectOrCreate?: EventReminderCreateOrConnectWithoutEventInput | EventReminderCreateOrConnectWithoutEventInput[]
    upsert?: EventReminderUpsertWithWhereUniqueWithoutEventInput | EventReminderUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: EventReminderCreateManyEventInputEnvelope
    set?: EventReminderWhereUniqueInput | EventReminderWhereUniqueInput[]
    disconnect?: EventReminderWhereUniqueInput | EventReminderWhereUniqueInput[]
    delete?: EventReminderWhereUniqueInput | EventReminderWhereUniqueInput[]
    connect?: EventReminderWhereUniqueInput | EventReminderWhereUniqueInput[]
    update?: EventReminderUpdateWithWhereUniqueWithoutEventInput | EventReminderUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: EventReminderUpdateManyWithWhereWithoutEventInput | EventReminderUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: EventReminderScalarWhereInput | EventReminderScalarWhereInput[]
  }

  export type HouseholdUpdateOneRequiredWithoutEventsNestedInput = {
    create?: XOR<HouseholdCreateWithoutEventsInput, HouseholdUncheckedCreateWithoutEventsInput>
    connectOrCreate?: HouseholdCreateOrConnectWithoutEventsInput
    upsert?: HouseholdUpsertWithoutEventsInput
    connect?: HouseholdWhereUniqueInput
    update?: XOR<XOR<HouseholdUpdateToOneWithWhereWithoutEventsInput, HouseholdUpdateWithoutEventsInput>, HouseholdUncheckedUpdateWithoutEventsInput>
  }

  export type UserUpdateOneRequiredWithoutEventsCreatedNestedInput = {
    create?: XOR<UserCreateWithoutEventsCreatedInput, UserUncheckedCreateWithoutEventsCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutEventsCreatedInput
    upsert?: UserUpsertWithoutEventsCreatedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEventsCreatedInput, UserUpdateWithoutEventsCreatedInput>, UserUncheckedUpdateWithoutEventsCreatedInput>
  }

  export type ChoreUpdateOneWithoutEventNestedInput = {
    create?: XOR<ChoreCreateWithoutEventInput, ChoreUncheckedCreateWithoutEventInput>
    connectOrCreate?: ChoreCreateOrConnectWithoutEventInput
    upsert?: ChoreUpsertWithoutEventInput
    disconnect?: ChoreWhereInput | boolean
    delete?: ChoreWhereInput | boolean
    connect?: ChoreWhereUniqueInput
    update?: XOR<XOR<ChoreUpdateToOneWithWhereWithoutEventInput, ChoreUpdateWithoutEventInput>, ChoreUncheckedUpdateWithoutEventInput>
  }

  export type RecurrenceRuleUpdateOneWithoutEventsNestedInput = {
    create?: XOR<RecurrenceRuleCreateWithoutEventsInput, RecurrenceRuleUncheckedCreateWithoutEventsInput>
    connectOrCreate?: RecurrenceRuleCreateOrConnectWithoutEventsInput
    upsert?: RecurrenceRuleUpsertWithoutEventsInput
    disconnect?: RecurrenceRuleWhereInput | boolean
    delete?: RecurrenceRuleWhereInput | boolean
    connect?: RecurrenceRuleWhereUniqueInput
    update?: XOR<XOR<RecurrenceRuleUpdateToOneWithWhereWithoutEventsInput, RecurrenceRuleUpdateWithoutEventsInput>, RecurrenceRuleUncheckedUpdateWithoutEventsInput>
  }

  export type CalendarEventHistoryUpdateManyWithoutEventNestedInput = {
    create?: XOR<CalendarEventHistoryCreateWithoutEventInput, CalendarEventHistoryUncheckedCreateWithoutEventInput> | CalendarEventHistoryCreateWithoutEventInput[] | CalendarEventHistoryUncheckedCreateWithoutEventInput[]
    connectOrCreate?: CalendarEventHistoryCreateOrConnectWithoutEventInput | CalendarEventHistoryCreateOrConnectWithoutEventInput[]
    upsert?: CalendarEventHistoryUpsertWithWhereUniqueWithoutEventInput | CalendarEventHistoryUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: CalendarEventHistoryCreateManyEventInputEnvelope
    set?: CalendarEventHistoryWhereUniqueInput | CalendarEventHistoryWhereUniqueInput[]
    disconnect?: CalendarEventHistoryWhereUniqueInput | CalendarEventHistoryWhereUniqueInput[]
    delete?: CalendarEventHistoryWhereUniqueInput | CalendarEventHistoryWhereUniqueInput[]
    connect?: CalendarEventHistoryWhereUniqueInput | CalendarEventHistoryWhereUniqueInput[]
    update?: CalendarEventHistoryUpdateWithWhereUniqueWithoutEventInput | CalendarEventHistoryUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: CalendarEventHistoryUpdateManyWithWhereWithoutEventInput | CalendarEventHistoryUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: CalendarEventHistoryScalarWhereInput | CalendarEventHistoryScalarWhereInput[]
  }

  export type EventReminderUncheckedUpdateManyWithoutEventNestedInput = {
    create?: XOR<EventReminderCreateWithoutEventInput, EventReminderUncheckedCreateWithoutEventInput> | EventReminderCreateWithoutEventInput[] | EventReminderUncheckedCreateWithoutEventInput[]
    connectOrCreate?: EventReminderCreateOrConnectWithoutEventInput | EventReminderCreateOrConnectWithoutEventInput[]
    upsert?: EventReminderUpsertWithWhereUniqueWithoutEventInput | EventReminderUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: EventReminderCreateManyEventInputEnvelope
    set?: EventReminderWhereUniqueInput | EventReminderWhereUniqueInput[]
    disconnect?: EventReminderWhereUniqueInput | EventReminderWhereUniqueInput[]
    delete?: EventReminderWhereUniqueInput | EventReminderWhereUniqueInput[]
    connect?: EventReminderWhereUniqueInput | EventReminderWhereUniqueInput[]
    update?: EventReminderUpdateWithWhereUniqueWithoutEventInput | EventReminderUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: EventReminderUpdateManyWithWhereWithoutEventInput | EventReminderUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: EventReminderScalarWhereInput | EventReminderScalarWhereInput[]
  }

  export type ChoreUncheckedUpdateOneWithoutEventNestedInput = {
    create?: XOR<ChoreCreateWithoutEventInput, ChoreUncheckedCreateWithoutEventInput>
    connectOrCreate?: ChoreCreateOrConnectWithoutEventInput
    upsert?: ChoreUpsertWithoutEventInput
    disconnect?: ChoreWhereInput | boolean
    delete?: ChoreWhereInput | boolean
    connect?: ChoreWhereUniqueInput
    update?: XOR<XOR<ChoreUpdateToOneWithWhereWithoutEventInput, ChoreUpdateWithoutEventInput>, ChoreUncheckedUpdateWithoutEventInput>
  }

  export type CalendarEventHistoryUncheckedUpdateManyWithoutEventNestedInput = {
    create?: XOR<CalendarEventHistoryCreateWithoutEventInput, CalendarEventHistoryUncheckedCreateWithoutEventInput> | CalendarEventHistoryCreateWithoutEventInput[] | CalendarEventHistoryUncheckedCreateWithoutEventInput[]
    connectOrCreate?: CalendarEventHistoryCreateOrConnectWithoutEventInput | CalendarEventHistoryCreateOrConnectWithoutEventInput[]
    upsert?: CalendarEventHistoryUpsertWithWhereUniqueWithoutEventInput | CalendarEventHistoryUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: CalendarEventHistoryCreateManyEventInputEnvelope
    set?: CalendarEventHistoryWhereUniqueInput | CalendarEventHistoryWhereUniqueInput[]
    disconnect?: CalendarEventHistoryWhereUniqueInput | CalendarEventHistoryWhereUniqueInput[]
    delete?: CalendarEventHistoryWhereUniqueInput | CalendarEventHistoryWhereUniqueInput[]
    connect?: CalendarEventHistoryWhereUniqueInput | CalendarEventHistoryWhereUniqueInput[]
    update?: CalendarEventHistoryUpdateWithWhereUniqueWithoutEventInput | CalendarEventHistoryUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: CalendarEventHistoryUpdateManyWithWhereWithoutEventInput | CalendarEventHistoryUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: CalendarEventHistoryScalarWhereInput | CalendarEventHistoryScalarWhereInput[]
  }

  export type EventCreateNestedOneWithoutRemindersInput = {
    create?: XOR<EventCreateWithoutRemindersInput, EventUncheckedCreateWithoutRemindersInput>
    connectOrCreate?: EventCreateOrConnectWithoutRemindersInput
    connect?: EventWhereUniqueInput
  }

  export type EnumEventReminderTypeFieldUpdateOperationsInput = {
    set?: $Enums.EventReminderType
  }

  export type EventUpdateOneRequiredWithoutRemindersNestedInput = {
    create?: XOR<EventCreateWithoutRemindersInput, EventUncheckedCreateWithoutRemindersInput>
    connectOrCreate?: EventCreateOrConnectWithoutRemindersInput
    upsert?: EventUpsertWithoutRemindersInput
    connect?: EventWhereUniqueInput
    update?: XOR<XOR<EventUpdateToOneWithWhereWithoutRemindersInput, EventUpdateWithoutRemindersInput>, EventUncheckedUpdateWithoutRemindersInput>
  }

  export type EventCreateNestedOneWithoutHistoryInput = {
    create?: XOR<EventCreateWithoutHistoryInput, EventUncheckedCreateWithoutHistoryInput>
    connectOrCreate?: EventCreateOrConnectWithoutHistoryInput
    connect?: EventWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCalendarEventHistoryInput = {
    create?: XOR<UserCreateWithoutCalendarEventHistoryInput, UserUncheckedCreateWithoutCalendarEventHistoryInput>
    connectOrCreate?: UserCreateOrConnectWithoutCalendarEventHistoryInput
    connect?: UserWhereUniqueInput
  }

  export type EnumCalendarEventActionFieldUpdateOperationsInput = {
    set?: $Enums.CalendarEventAction
  }

  export type EventUpdateOneRequiredWithoutHistoryNestedInput = {
    create?: XOR<EventCreateWithoutHistoryInput, EventUncheckedCreateWithoutHistoryInput>
    connectOrCreate?: EventCreateOrConnectWithoutHistoryInput
    upsert?: EventUpsertWithoutHistoryInput
    connect?: EventWhereUniqueInput
    update?: XOR<XOR<EventUpdateToOneWithWhereWithoutHistoryInput, EventUpdateWithoutHistoryInput>, EventUncheckedUpdateWithoutHistoryInput>
  }

  export type UserUpdateOneRequiredWithoutCalendarEventHistoryNestedInput = {
    create?: XOR<UserCreateWithoutCalendarEventHistoryInput, UserUncheckedCreateWithoutCalendarEventHistoryInput>
    connectOrCreate?: UserCreateOrConnectWithoutCalendarEventHistoryInput
    upsert?: UserUpsertWithoutCalendarEventHistoryInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCalendarEventHistoryInput, UserUpdateWithoutCalendarEventHistoryInput>, UserUncheckedUpdateWithoutCalendarEventHistoryInput>
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumNotificationTypeFieldUpdateOperationsInput = {
    set?: $Enums.NotificationType
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserCreateNestedOneWithoutNotificationSettingsInput = {
    create?: XOR<UserCreateWithoutNotificationSettingsInput, UserUncheckedCreateWithoutNotificationSettingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationSettingsInput
    connect?: UserWhereUniqueInput
  }

  export type HouseholdCreateNestedOneWithoutNotificationSettingsInput = {
    create?: XOR<HouseholdCreateWithoutNotificationSettingsInput, HouseholdUncheckedCreateWithoutNotificationSettingsInput>
    connectOrCreate?: HouseholdCreateOrConnectWithoutNotificationSettingsInput
    connect?: HouseholdWhereUniqueInput
  }

  export type UserUpdateOneWithoutNotificationSettingsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationSettingsInput, UserUncheckedCreateWithoutNotificationSettingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationSettingsInput
    upsert?: UserUpsertWithoutNotificationSettingsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationSettingsInput, UserUpdateWithoutNotificationSettingsInput>, UserUncheckedUpdateWithoutNotificationSettingsInput>
  }

  export type HouseholdUpdateOneWithoutNotificationSettingsNestedInput = {
    create?: XOR<HouseholdCreateWithoutNotificationSettingsInput, HouseholdUncheckedCreateWithoutNotificationSettingsInput>
    connectOrCreate?: HouseholdCreateOrConnectWithoutNotificationSettingsInput
    upsert?: HouseholdUpsertWithoutNotificationSettingsInput
    disconnect?: HouseholdWhereInput | boolean
    delete?: HouseholdWhereInput | boolean
    connect?: HouseholdWhereUniqueInput
    update?: XOR<XOR<HouseholdUpdateToOneWithWhereWithoutNotificationSettingsInput, HouseholdUpdateWithoutNotificationSettingsInput>, HouseholdUncheckedUpdateWithoutNotificationSettingsInput>
  }

  export type UserCreateNestedOneWithoutOauthIntegrationsInput = {
    create?: XOR<UserCreateWithoutOauthIntegrationsInput, UserUncheckedCreateWithoutOauthIntegrationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOauthIntegrationsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumProviderFieldUpdateOperationsInput = {
    set?: $Enums.Provider
  }

  export type UserUpdateOneRequiredWithoutOauthIntegrationsNestedInput = {
    create?: XOR<UserCreateWithoutOauthIntegrationsInput, UserUncheckedCreateWithoutOauthIntegrationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOauthIntegrationsInput
    upsert?: UserUpsertWithoutOauthIntegrationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOauthIntegrationsInput, UserUpdateWithoutOauthIntegrationsInput>, UserUncheckedUpdateWithoutOauthIntegrationsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumHouseholdRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.HouseholdRole | EnumHouseholdRoleFieldRefInput<$PrismaModel>
    in?: $Enums.HouseholdRole[] | ListEnumHouseholdRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.HouseholdRole[] | ListEnumHouseholdRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumHouseholdRoleFilter<$PrismaModel> | $Enums.HouseholdRole
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumHouseholdRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.HouseholdRole | EnumHouseholdRoleFieldRefInput<$PrismaModel>
    in?: $Enums.HouseholdRole[] | ListEnumHouseholdRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.HouseholdRole[] | ListEnumHouseholdRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumHouseholdRoleWithAggregatesFilter<$PrismaModel> | $Enums.HouseholdRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumHouseholdRoleFilter<$PrismaModel>
    _max?: NestedEnumHouseholdRoleFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumRecurrenceFrequencyFilter<$PrismaModel = never> = {
    equals?: $Enums.RecurrenceFrequency | EnumRecurrenceFrequencyFieldRefInput<$PrismaModel>
    in?: $Enums.RecurrenceFrequency[] | ListEnumRecurrenceFrequencyFieldRefInput<$PrismaModel>
    notIn?: $Enums.RecurrenceFrequency[] | ListEnumRecurrenceFrequencyFieldRefInput<$PrismaModel>
    not?: NestedEnumRecurrenceFrequencyFilter<$PrismaModel> | $Enums.RecurrenceFrequency
  }

  export type NestedEnumRecurrenceFrequencyWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RecurrenceFrequency | EnumRecurrenceFrequencyFieldRefInput<$PrismaModel>
    in?: $Enums.RecurrenceFrequency[] | ListEnumRecurrenceFrequencyFieldRefInput<$PrismaModel>
    notIn?: $Enums.RecurrenceFrequency[] | ListEnumRecurrenceFrequencyFieldRefInput<$PrismaModel>
    not?: NestedEnumRecurrenceFrequencyWithAggregatesFilter<$PrismaModel> | $Enums.RecurrenceFrequency
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRecurrenceFrequencyFilter<$PrismaModel>
    _max?: NestedEnumRecurrenceFrequencyFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumReactionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ReactionType | EnumReactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReactionType[] | ListEnumReactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReactionType[] | ListEnumReactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReactionTypeFilter<$PrismaModel> | $Enums.ReactionType
  }

  export type NestedEnumReactionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReactionType | EnumReactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReactionType[] | ListEnumReactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReactionType[] | ListEnumReactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReactionTypeWithAggregatesFilter<$PrismaModel> | $Enums.ReactionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReactionTypeFilter<$PrismaModel>
    _max?: NestedEnumReactionTypeFilter<$PrismaModel>
  }

  export type NestedEnumChoreStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ChoreStatus | EnumChoreStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ChoreStatus[] | ListEnumChoreStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChoreStatus[] | ListEnumChoreStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumChoreStatusFilter<$PrismaModel> | $Enums.ChoreStatus
  }

  export type NestedEnumChoreStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ChoreStatus | EnumChoreStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ChoreStatus[] | ListEnumChoreStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChoreStatus[] | ListEnumChoreStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumChoreStatusWithAggregatesFilter<$PrismaModel> | $Enums.ChoreStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumChoreStatusFilter<$PrismaModel>
    _max?: NestedEnumChoreStatusFilter<$PrismaModel>
  }

  export type NestedEnumSubtaskStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SubtaskStatus | EnumSubtaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubtaskStatus[] | ListEnumSubtaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubtaskStatus[] | ListEnumSubtaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubtaskStatusFilter<$PrismaModel> | $Enums.SubtaskStatus
  }

  export type NestedEnumSubtaskStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubtaskStatus | EnumSubtaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubtaskStatus[] | ListEnumSubtaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubtaskStatus[] | ListEnumSubtaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubtaskStatusWithAggregatesFilter<$PrismaModel> | $Enums.SubtaskStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubtaskStatusFilter<$PrismaModel>
    _max?: NestedEnumSubtaskStatusFilter<$PrismaModel>
  }

  export type NestedEnumChoreSwapRequestStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ChoreSwapRequestStatus | EnumChoreSwapRequestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ChoreSwapRequestStatus[] | ListEnumChoreSwapRequestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChoreSwapRequestStatus[] | ListEnumChoreSwapRequestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumChoreSwapRequestStatusFilter<$PrismaModel> | $Enums.ChoreSwapRequestStatus
  }

  export type NestedEnumChoreSwapRequestStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ChoreSwapRequestStatus | EnumChoreSwapRequestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ChoreSwapRequestStatus[] | ListEnumChoreSwapRequestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChoreSwapRequestStatus[] | ListEnumChoreSwapRequestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumChoreSwapRequestStatusWithAggregatesFilter<$PrismaModel> | $Enums.ChoreSwapRequestStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumChoreSwapRequestStatusFilter<$PrismaModel>
    _max?: NestedEnumChoreSwapRequestStatusFilter<$PrismaModel>
  }

  export type NestedEnumChoreActionFilter<$PrismaModel = never> = {
    equals?: $Enums.ChoreAction | EnumChoreActionFieldRefInput<$PrismaModel>
    in?: $Enums.ChoreAction[] | ListEnumChoreActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChoreAction[] | ListEnumChoreActionFieldRefInput<$PrismaModel>
    not?: NestedEnumChoreActionFilter<$PrismaModel> | $Enums.ChoreAction
  }

  export type NestedEnumChoreActionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ChoreAction | EnumChoreActionFieldRefInput<$PrismaModel>
    in?: $Enums.ChoreAction[] | ListEnumChoreActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChoreAction[] | ListEnumChoreActionFieldRefInput<$PrismaModel>
    not?: NestedEnumChoreActionWithAggregatesFilter<$PrismaModel> | $Enums.ChoreAction
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumChoreActionFilter<$PrismaModel>
    _max?: NestedEnumChoreActionFilter<$PrismaModel>
  }

  export type NestedEnumExpenseCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.ExpenseCategory | EnumExpenseCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ExpenseCategory[] | ListEnumExpenseCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExpenseCategory[] | ListEnumExpenseCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumExpenseCategoryFilter<$PrismaModel> | $Enums.ExpenseCategory
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumExpenseCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ExpenseCategory | EnumExpenseCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ExpenseCategory[] | ListEnumExpenseCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExpenseCategory[] | ListEnumExpenseCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumExpenseCategoryWithAggregatesFilter<$PrismaModel> | $Enums.ExpenseCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumExpenseCategoryFilter<$PrismaModel>
    _max?: NestedEnumExpenseCategoryFilter<$PrismaModel>
  }

  export type NestedEnumTransactionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionStatus | EnumTransactionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionStatusFilter<$PrismaModel> | $Enums.TransactionStatus
  }

  export type NestedEnumTransactionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionStatus | EnumTransactionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionStatusWithAggregatesFilter<$PrismaModel> | $Enums.TransactionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionStatusFilter<$PrismaModel>
    _max?: NestedEnumTransactionStatusFilter<$PrismaModel>
  }

  export type NestedEnumExpenseActionFilter<$PrismaModel = never> = {
    equals?: $Enums.ExpenseAction | EnumExpenseActionFieldRefInput<$PrismaModel>
    in?: $Enums.ExpenseAction[] | ListEnumExpenseActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExpenseAction[] | ListEnumExpenseActionFieldRefInput<$PrismaModel>
    not?: NestedEnumExpenseActionFilter<$PrismaModel> | $Enums.ExpenseAction
  }

  export type NestedEnumExpenseActionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ExpenseAction | EnumExpenseActionFieldRefInput<$PrismaModel>
    in?: $Enums.ExpenseAction[] | ListEnumExpenseActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExpenseAction[] | ListEnumExpenseActionFieldRefInput<$PrismaModel>
    not?: NestedEnumExpenseActionWithAggregatesFilter<$PrismaModel> | $Enums.ExpenseAction
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumExpenseActionFilter<$PrismaModel>
    _max?: NestedEnumExpenseActionFilter<$PrismaModel>
  }

  export type NestedEnumEventCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.EventCategory | EnumEventCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.EventCategory[] | ListEnumEventCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.EventCategory[] | ListEnumEventCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumEventCategoryFilter<$PrismaModel> | $Enums.EventCategory
  }

  export type NestedEnumEventStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.EventStatus | EnumEventStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EventStatus[] | ListEnumEventStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EventStatus[] | ListEnumEventStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEventStatusFilter<$PrismaModel> | $Enums.EventStatus
  }

  export type NestedEnumEventCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EventCategory | EnumEventCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.EventCategory[] | ListEnumEventCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.EventCategory[] | ListEnumEventCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumEventCategoryWithAggregatesFilter<$PrismaModel> | $Enums.EventCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEventCategoryFilter<$PrismaModel>
    _max?: NestedEnumEventCategoryFilter<$PrismaModel>
  }

  export type NestedEnumEventStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EventStatus | EnumEventStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EventStatus[] | ListEnumEventStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EventStatus[] | ListEnumEventStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEventStatusWithAggregatesFilter<$PrismaModel> | $Enums.EventStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEventStatusFilter<$PrismaModel>
    _max?: NestedEnumEventStatusFilter<$PrismaModel>
  }

  export type NestedEnumEventReminderTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.EventReminderType | EnumEventReminderTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EventReminderType[] | ListEnumEventReminderTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EventReminderType[] | ListEnumEventReminderTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEventReminderTypeFilter<$PrismaModel> | $Enums.EventReminderType
  }

  export type NestedEnumEventReminderTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EventReminderType | EnumEventReminderTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EventReminderType[] | ListEnumEventReminderTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EventReminderType[] | ListEnumEventReminderTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEventReminderTypeWithAggregatesFilter<$PrismaModel> | $Enums.EventReminderType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEventReminderTypeFilter<$PrismaModel>
    _max?: NestedEnumEventReminderTypeFilter<$PrismaModel>
  }

  export type NestedEnumCalendarEventActionFilter<$PrismaModel = never> = {
    equals?: $Enums.CalendarEventAction | EnumCalendarEventActionFieldRefInput<$PrismaModel>
    in?: $Enums.CalendarEventAction[] | ListEnumCalendarEventActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.CalendarEventAction[] | ListEnumCalendarEventActionFieldRefInput<$PrismaModel>
    not?: NestedEnumCalendarEventActionFilter<$PrismaModel> | $Enums.CalendarEventAction
  }

  export type NestedEnumCalendarEventActionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CalendarEventAction | EnumCalendarEventActionFieldRefInput<$PrismaModel>
    in?: $Enums.CalendarEventAction[] | ListEnumCalendarEventActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.CalendarEventAction[] | ListEnumCalendarEventActionFieldRefInput<$PrismaModel>
    not?: NestedEnumCalendarEventActionWithAggregatesFilter<$PrismaModel> | $Enums.CalendarEventAction
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCalendarEventActionFilter<$PrismaModel>
    _max?: NestedEnumCalendarEventActionFilter<$PrismaModel>
  }

  export type NestedEnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type NestedEnumProviderFilter<$PrismaModel = never> = {
    equals?: $Enums.Provider | EnumProviderFieldRefInput<$PrismaModel>
    in?: $Enums.Provider[] | ListEnumProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Provider[] | ListEnumProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumProviderFilter<$PrismaModel> | $Enums.Provider
  }

  export type NestedEnumProviderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Provider | EnumProviderFieldRefInput<$PrismaModel>
    in?: $Enums.Provider[] | ListEnumProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Provider[] | ListEnumProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumProviderWithAggregatesFilter<$PrismaModel> | $Enums.Provider
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProviderFilter<$PrismaModel>
    _max?: NestedEnumProviderFilter<$PrismaModel>
  }

  export type HouseholdMemberCreateWithoutUserInput = {
    id?: string
    role?: $Enums.HouseholdRole
    joinedAt?: Date | string
    leftAt?: Date | string | null
    isInvited?: boolean
    isAccepted?: boolean
    isRejected?: boolean
    isSelected?: boolean
    lastAssignedChoreAt?: Date | string | null
    household: HouseholdCreateNestedOneWithoutMembersInput
    threads?: ThreadCreateNestedManyWithoutParticipantsInput
  }

  export type HouseholdMemberUncheckedCreateWithoutUserInput = {
    id?: string
    householdId: string
    role?: $Enums.HouseholdRole
    joinedAt?: Date | string
    leftAt?: Date | string | null
    isInvited?: boolean
    isAccepted?: boolean
    isRejected?: boolean
    isSelected?: boolean
    lastAssignedChoreAt?: Date | string | null
    threads?: ThreadUncheckedCreateNestedManyWithoutParticipantsInput
  }

  export type HouseholdMemberCreateOrConnectWithoutUserInput = {
    where: HouseholdMemberWhereUniqueInput
    create: XOR<HouseholdMemberCreateWithoutUserInput, HouseholdMemberUncheckedCreateWithoutUserInput>
  }

  export type HouseholdMemberCreateManyUserInputEnvelope = {
    data: HouseholdMemberCreateManyUserInput | HouseholdMemberCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MessageCreateWithoutAuthorInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    thread: ThreadCreateNestedOneWithoutMessagesInput
    attachments?: AttachmentCreateNestedManyWithoutMessageInput
    reactions?: ReactionCreateNestedManyWithoutMessageInput
    mentions?: MentionCreateNestedManyWithoutMessageInput
    reads?: MessageReadCreateNestedManyWithoutMessageInput
  }

  export type MessageUncheckedCreateWithoutAuthorInput = {
    id?: string
    threadId: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    attachments?: AttachmentUncheckedCreateNestedManyWithoutMessageInput
    reactions?: ReactionUncheckedCreateNestedManyWithoutMessageInput
    mentions?: MentionUncheckedCreateNestedManyWithoutMessageInput
    reads?: MessageReadUncheckedCreateNestedManyWithoutMessageInput
  }

  export type MessageCreateOrConnectWithoutAuthorInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutAuthorInput, MessageUncheckedCreateWithoutAuthorInput>
  }

  export type MessageCreateManyAuthorInputEnvelope = {
    data: MessageCreateManyAuthorInput | MessageCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type ThreadCreateWithoutAuthorInput = {
    id?: string
    title?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    household: HouseholdCreateNestedOneWithoutThreadsInput
    messages?: MessageCreateNestedManyWithoutThreadInput
    participants?: HouseholdMemberCreateNestedManyWithoutThreadsInput
  }

  export type ThreadUncheckedCreateWithoutAuthorInput = {
    id?: string
    householdId: string
    title?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    messages?: MessageUncheckedCreateNestedManyWithoutThreadInput
    participants?: HouseholdMemberUncheckedCreateNestedManyWithoutThreadsInput
  }

  export type ThreadCreateOrConnectWithoutAuthorInput = {
    where: ThreadWhereUniqueInput
    create: XOR<ThreadCreateWithoutAuthorInput, ThreadUncheckedCreateWithoutAuthorInput>
  }

  export type ThreadCreateManyAuthorInputEnvelope = {
    data: ThreadCreateManyAuthorInput | ThreadCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type ChoreAssignmentCreateWithoutUserInput = {
    id?: string
    assignedAt?: Date | string
    completedAt?: Date | string | null
    chore: ChoreCreateNestedOneWithoutAssignedUsersInput
  }

  export type ChoreAssignmentUncheckedCreateWithoutUserInput = {
    id?: string
    choreId: string
    assignedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type ChoreAssignmentCreateOrConnectWithoutUserInput = {
    where: ChoreAssignmentWhereUniqueInput
    create: XOR<ChoreAssignmentCreateWithoutUserInput, ChoreAssignmentUncheckedCreateWithoutUserInput>
  }

  export type ChoreAssignmentCreateManyUserInputEnvelope = {
    data: ChoreAssignmentCreateManyUserInput | ChoreAssignmentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ExpenseCreateWithoutPaidByInput = {
    id?: string
    amount: number
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    dueDate?: Date | string | null
    deletedAt?: Date | string | null
    category: $Enums.ExpenseCategory
    household: HouseholdCreateNestedOneWithoutExpensesInput
    splits?: ExpenseSplitCreateNestedManyWithoutExpenseInput
    transactions?: TransactionCreateNestedManyWithoutExpenseInput
    receipts?: ReceiptCreateNestedManyWithoutExpenseInput
    history?: ExpenseHistoryCreateNestedManyWithoutExpenseInput
  }

  export type ExpenseUncheckedCreateWithoutPaidByInput = {
    id?: string
    householdId: string
    amount: number
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    dueDate?: Date | string | null
    deletedAt?: Date | string | null
    category: $Enums.ExpenseCategory
    splits?: ExpenseSplitUncheckedCreateNestedManyWithoutExpenseInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutExpenseInput
    receipts?: ReceiptUncheckedCreateNestedManyWithoutExpenseInput
    history?: ExpenseHistoryUncheckedCreateNestedManyWithoutExpenseInput
  }

  export type ExpenseCreateOrConnectWithoutPaidByInput = {
    where: ExpenseWhereUniqueInput
    create: XOR<ExpenseCreateWithoutPaidByInput, ExpenseUncheckedCreateWithoutPaidByInput>
  }

  export type ExpenseCreateManyPaidByInputEnvelope = {
    data: ExpenseCreateManyPaidByInput | ExpenseCreateManyPaidByInput[]
    skipDuplicates?: boolean
  }

  export type ExpenseSplitCreateWithoutUserInput = {
    id?: string
    amount: number
    expense: ExpenseCreateNestedOneWithoutSplitsInput
  }

  export type ExpenseSplitUncheckedCreateWithoutUserInput = {
    id?: string
    expenseId: string
    amount: number
  }

  export type ExpenseSplitCreateOrConnectWithoutUserInput = {
    where: ExpenseSplitWhereUniqueInput
    create: XOR<ExpenseSplitCreateWithoutUserInput, ExpenseSplitUncheckedCreateWithoutUserInput>
  }

  export type ExpenseSplitCreateManyUserInputEnvelope = {
    data: ExpenseSplitCreateManyUserInput | ExpenseSplitCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TransactionCreateWithoutFromUserInput = {
    id?: string
    amount: number
    status?: $Enums.TransactionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    expense: ExpenseCreateNestedOneWithoutTransactionsInput
    toUser: UserCreateNestedOneWithoutTransactionsToInput
  }

  export type TransactionUncheckedCreateWithoutFromUserInput = {
    id?: string
    expenseId: string
    toUserId: string
    amount: number
    status?: $Enums.TransactionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type TransactionCreateOrConnectWithoutFromUserInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutFromUserInput, TransactionUncheckedCreateWithoutFromUserInput>
  }

  export type TransactionCreateManyFromUserInputEnvelope = {
    data: TransactionCreateManyFromUserInput | TransactionCreateManyFromUserInput[]
    skipDuplicates?: boolean
  }

  export type TransactionCreateWithoutToUserInput = {
    id?: string
    amount: number
    status?: $Enums.TransactionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    expense: ExpenseCreateNestedOneWithoutTransactionsInput
    fromUser: UserCreateNestedOneWithoutTransactionsFromInput
  }

  export type TransactionUncheckedCreateWithoutToUserInput = {
    id?: string
    expenseId: string
    fromUserId: string
    amount: number
    status?: $Enums.TransactionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type TransactionCreateOrConnectWithoutToUserInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutToUserInput, TransactionUncheckedCreateWithoutToUserInput>
  }

  export type TransactionCreateManyToUserInputEnvelope = {
    data: TransactionCreateManyToUserInput | TransactionCreateManyToUserInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutUserInput = {
    id?: string
    type: $Enums.NotificationType
    message: string
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: string
    type: $Enums.NotificationType
    message: string
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type OAuthIntegrationCreateWithoutUserInput = {
    id?: string
    provider: $Enums.Provider
    accessToken: string
    refreshToken?: string | null
    expiresAt?: Date | string | null
  }

  export type OAuthIntegrationUncheckedCreateWithoutUserInput = {
    id?: string
    provider: $Enums.Provider
    accessToken: string
    refreshToken?: string | null
    expiresAt?: Date | string | null
  }

  export type OAuthIntegrationCreateOrConnectWithoutUserInput = {
    where: OAuthIntegrationWhereUniqueInput
    create: XOR<OAuthIntegrationCreateWithoutUserInput, OAuthIntegrationUncheckedCreateWithoutUserInput>
  }

  export type OAuthIntegrationCreateManyUserInputEnvelope = {
    data: OAuthIntegrationCreateManyUserInput | OAuthIntegrationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type EventCreateWithoutCreatedByInput = {
    id?: string
    title: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    choreId?: string | null
    category?: $Enums.EventCategory
    isAllDay?: boolean
    location?: string | null
    isPrivate?: boolean
    status?: $Enums.EventStatus
    deletedAt?: Date | string | null
    reminders?: EventReminderCreateNestedManyWithoutEventInput
    household: HouseholdCreateNestedOneWithoutEventsInput
    chore?: ChoreCreateNestedOneWithoutEventInput
    recurrenceRule?: RecurrenceRuleCreateNestedOneWithoutEventsInput
    history?: CalendarEventHistoryCreateNestedManyWithoutEventInput
  }

  export type EventUncheckedCreateWithoutCreatedByInput = {
    id?: string
    householdId: string
    title: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    choreId?: string | null
    recurrenceRuleId?: string | null
    category?: $Enums.EventCategory
    isAllDay?: boolean
    location?: string | null
    isPrivate?: boolean
    status?: $Enums.EventStatus
    deletedAt?: Date | string | null
    reminders?: EventReminderUncheckedCreateNestedManyWithoutEventInput
    chore?: ChoreUncheckedCreateNestedOneWithoutEventInput
    history?: CalendarEventHistoryUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventCreateOrConnectWithoutCreatedByInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutCreatedByInput, EventUncheckedCreateWithoutCreatedByInput>
  }

  export type EventCreateManyCreatedByInputEnvelope = {
    data: EventCreateManyCreatedByInput | EventCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type ChoreSwapRequestCreateWithoutRequestingUserInput = {
    id?: string
    status?: $Enums.ChoreSwapRequestStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    targetUser: UserCreateNestedOneWithoutChoreSwapRequestsReceivedInput
    chore: ChoreCreateNestedOneWithoutChoreSwapRequestsInput
  }

  export type ChoreSwapRequestUncheckedCreateWithoutRequestingUserInput = {
    id?: string
    choreId: string
    targetUserId: string
    status?: $Enums.ChoreSwapRequestStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChoreSwapRequestCreateOrConnectWithoutRequestingUserInput = {
    where: ChoreSwapRequestWhereUniqueInput
    create: XOR<ChoreSwapRequestCreateWithoutRequestingUserInput, ChoreSwapRequestUncheckedCreateWithoutRequestingUserInput>
  }

  export type ChoreSwapRequestCreateManyRequestingUserInputEnvelope = {
    data: ChoreSwapRequestCreateManyRequestingUserInput | ChoreSwapRequestCreateManyRequestingUserInput[]
    skipDuplicates?: boolean
  }

  export type ChoreSwapRequestCreateWithoutTargetUserInput = {
    id?: string
    status?: $Enums.ChoreSwapRequestStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    requestingUser: UserCreateNestedOneWithoutChoreSwapRequestsInitiatedInput
    chore: ChoreCreateNestedOneWithoutChoreSwapRequestsInput
  }

  export type ChoreSwapRequestUncheckedCreateWithoutTargetUserInput = {
    id?: string
    choreId: string
    requestingUserId: string
    status?: $Enums.ChoreSwapRequestStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChoreSwapRequestCreateOrConnectWithoutTargetUserInput = {
    where: ChoreSwapRequestWhereUniqueInput
    create: XOR<ChoreSwapRequestCreateWithoutTargetUserInput, ChoreSwapRequestUncheckedCreateWithoutTargetUserInput>
  }

  export type ChoreSwapRequestCreateManyTargetUserInputEnvelope = {
    data: ChoreSwapRequestCreateManyTargetUserInput | ChoreSwapRequestCreateManyTargetUserInput[]
    skipDuplicates?: boolean
  }

  export type ReactionCreateWithoutUserInput = {
    id?: string
    emoji: string
    type: $Enums.ReactionType
    createdAt?: Date | string
    message: MessageCreateNestedOneWithoutReactionsInput
  }

  export type ReactionUncheckedCreateWithoutUserInput = {
    id?: string
    messageId: string
    emoji: string
    type: $Enums.ReactionType
    createdAt?: Date | string
  }

  export type ReactionCreateOrConnectWithoutUserInput = {
    where: ReactionWhereUniqueInput
    create: XOR<ReactionCreateWithoutUserInput, ReactionUncheckedCreateWithoutUserInput>
  }

  export type ReactionCreateManyUserInputEnvelope = {
    data: ReactionCreateManyUserInput | ReactionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MentionCreateWithoutUserInput = {
    id?: string
    mentionedAt?: Date | string
    message: MessageCreateNestedOneWithoutMentionsInput
  }

  export type MentionUncheckedCreateWithoutUserInput = {
    id?: string
    messageId: string
    mentionedAt?: Date | string
  }

  export type MentionCreateOrConnectWithoutUserInput = {
    where: MentionWhereUniqueInput
    create: XOR<MentionCreateWithoutUserInput, MentionUncheckedCreateWithoutUserInput>
  }

  export type MentionCreateManyUserInputEnvelope = {
    data: MentionCreateManyUserInput | MentionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ChoreHistoryCreateWithoutUserInput = {
    id?: string
    action: $Enums.ChoreAction
    changedAt?: Date | string
    chore: ChoreCreateNestedOneWithoutHistoryInput
  }

  export type ChoreHistoryUncheckedCreateWithoutUserInput = {
    id?: string
    choreId: string
    action: $Enums.ChoreAction
    changedAt?: Date | string
  }

  export type ChoreHistoryCreateOrConnectWithoutUserInput = {
    where: ChoreHistoryWhereUniqueInput
    create: XOR<ChoreHistoryCreateWithoutUserInput, ChoreHistoryUncheckedCreateWithoutUserInput>
  }

  export type ChoreHistoryCreateManyUserInputEnvelope = {
    data: ChoreHistoryCreateManyUserInput | ChoreHistoryCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type NotificationSettingsCreateWithoutUserInput = {
    id?: string
    messageNotif?: boolean
    mentionsNotif?: boolean
    reactionsNotif?: boolean
    choreNotif?: boolean
    financeNotif?: boolean
    calendarNotif?: boolean
    remindersNotif?: boolean
    household?: HouseholdCreateNestedOneWithoutNotificationSettingsInput
  }

  export type NotificationSettingsUncheckedCreateWithoutUserInput = {
    id?: string
    householdId?: string | null
    messageNotif?: boolean
    mentionsNotif?: boolean
    reactionsNotif?: boolean
    choreNotif?: boolean
    financeNotif?: boolean
    calendarNotif?: boolean
    remindersNotif?: boolean
  }

  export type NotificationSettingsCreateOrConnectWithoutUserInput = {
    where: NotificationSettingsWhereUniqueInput
    create: XOR<NotificationSettingsCreateWithoutUserInput, NotificationSettingsUncheckedCreateWithoutUserInput>
  }

  export type NotificationSettingsCreateManyUserInputEnvelope = {
    data: NotificationSettingsCreateManyUserInput | NotificationSettingsCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CalendarEventHistoryCreateWithoutUserInput = {
    id?: string
    action: $Enums.CalendarEventAction
    changedAt?: Date | string
    event: EventCreateNestedOneWithoutHistoryInput
  }

  export type CalendarEventHistoryUncheckedCreateWithoutUserInput = {
    id?: string
    eventId: string
    action: $Enums.CalendarEventAction
    changedAt?: Date | string
  }

  export type CalendarEventHistoryCreateOrConnectWithoutUserInput = {
    where: CalendarEventHistoryWhereUniqueInput
    create: XOR<CalendarEventHistoryCreateWithoutUserInput, CalendarEventHistoryUncheckedCreateWithoutUserInput>
  }

  export type CalendarEventHistoryCreateManyUserInputEnvelope = {
    data: CalendarEventHistoryCreateManyUserInput | CalendarEventHistoryCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ExpenseHistoryCreateWithoutUserInput = {
    id?: string
    action: $Enums.ExpenseAction
    changedAt?: Date | string
    expense: ExpenseCreateNestedOneWithoutHistoryInput
  }

  export type ExpenseHistoryUncheckedCreateWithoutUserInput = {
    id?: string
    expenseId: string
    action: $Enums.ExpenseAction
    changedAt?: Date | string
  }

  export type ExpenseHistoryCreateOrConnectWithoutUserInput = {
    where: ExpenseHistoryWhereUniqueInput
    create: XOR<ExpenseHistoryCreateWithoutUserInput, ExpenseHistoryUncheckedCreateWithoutUserInput>
  }

  export type ExpenseHistoryCreateManyUserInputEnvelope = {
    data: ExpenseHistoryCreateManyUserInput | ExpenseHistoryCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MessageReadCreateWithoutUserInput = {
    id?: string
    readAt?: Date | string
    message: MessageCreateNestedOneWithoutReadsInput
  }

  export type MessageReadUncheckedCreateWithoutUserInput = {
    id?: string
    messageId: string
    readAt?: Date | string
  }

  export type MessageReadCreateOrConnectWithoutUserInput = {
    where: MessageReadWhereUniqueInput
    create: XOR<MessageReadCreateWithoutUserInput, MessageReadUncheckedCreateWithoutUserInput>
  }

  export type MessageReadCreateManyUserInputEnvelope = {
    data: MessageReadCreateManyUserInput | MessageReadCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type HouseholdMemberUpsertWithWhereUniqueWithoutUserInput = {
    where: HouseholdMemberWhereUniqueInput
    update: XOR<HouseholdMemberUpdateWithoutUserInput, HouseholdMemberUncheckedUpdateWithoutUserInput>
    create: XOR<HouseholdMemberCreateWithoutUserInput, HouseholdMemberUncheckedCreateWithoutUserInput>
  }

  export type HouseholdMemberUpdateWithWhereUniqueWithoutUserInput = {
    where: HouseholdMemberWhereUniqueInput
    data: XOR<HouseholdMemberUpdateWithoutUserInput, HouseholdMemberUncheckedUpdateWithoutUserInput>
  }

  export type HouseholdMemberUpdateManyWithWhereWithoutUserInput = {
    where: HouseholdMemberScalarWhereInput
    data: XOR<HouseholdMemberUpdateManyMutationInput, HouseholdMemberUncheckedUpdateManyWithoutUserInput>
  }

  export type HouseholdMemberScalarWhereInput = {
    AND?: HouseholdMemberScalarWhereInput | HouseholdMemberScalarWhereInput[]
    OR?: HouseholdMemberScalarWhereInput[]
    NOT?: HouseholdMemberScalarWhereInput | HouseholdMemberScalarWhereInput[]
    id?: StringFilter<"HouseholdMember"> | string
    userId?: StringFilter<"HouseholdMember"> | string
    householdId?: StringFilter<"HouseholdMember"> | string
    role?: EnumHouseholdRoleFilter<"HouseholdMember"> | $Enums.HouseholdRole
    joinedAt?: DateTimeFilter<"HouseholdMember"> | Date | string
    leftAt?: DateTimeNullableFilter<"HouseholdMember"> | Date | string | null
    isInvited?: BoolFilter<"HouseholdMember"> | boolean
    isAccepted?: BoolFilter<"HouseholdMember"> | boolean
    isRejected?: BoolFilter<"HouseholdMember"> | boolean
    isSelected?: BoolFilter<"HouseholdMember"> | boolean
    lastAssignedChoreAt?: DateTimeNullableFilter<"HouseholdMember"> | Date | string | null
  }

  export type MessageUpsertWithWhereUniqueWithoutAuthorInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutAuthorInput, MessageUncheckedUpdateWithoutAuthorInput>
    create: XOR<MessageCreateWithoutAuthorInput, MessageUncheckedCreateWithoutAuthorInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutAuthorInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutAuthorInput, MessageUncheckedUpdateWithoutAuthorInput>
  }

  export type MessageUpdateManyWithWhereWithoutAuthorInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutAuthorInput>
  }

  export type MessageScalarWhereInput = {
    AND?: MessageScalarWhereInput | MessageScalarWhereInput[]
    OR?: MessageScalarWhereInput[]
    NOT?: MessageScalarWhereInput | MessageScalarWhereInput[]
    id?: StringFilter<"Message"> | string
    threadId?: StringFilter<"Message"> | string
    authorId?: StringFilter<"Message"> | string
    content?: StringFilter<"Message"> | string
    createdAt?: DateTimeFilter<"Message"> | Date | string
    updatedAt?: DateTimeFilter<"Message"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Message"> | Date | string | null
  }

  export type ThreadUpsertWithWhereUniqueWithoutAuthorInput = {
    where: ThreadWhereUniqueInput
    update: XOR<ThreadUpdateWithoutAuthorInput, ThreadUncheckedUpdateWithoutAuthorInput>
    create: XOR<ThreadCreateWithoutAuthorInput, ThreadUncheckedCreateWithoutAuthorInput>
  }

  export type ThreadUpdateWithWhereUniqueWithoutAuthorInput = {
    where: ThreadWhereUniqueInput
    data: XOR<ThreadUpdateWithoutAuthorInput, ThreadUncheckedUpdateWithoutAuthorInput>
  }

  export type ThreadUpdateManyWithWhereWithoutAuthorInput = {
    where: ThreadScalarWhereInput
    data: XOR<ThreadUpdateManyMutationInput, ThreadUncheckedUpdateManyWithoutAuthorInput>
  }

  export type ThreadScalarWhereInput = {
    AND?: ThreadScalarWhereInput | ThreadScalarWhereInput[]
    OR?: ThreadScalarWhereInput[]
    NOT?: ThreadScalarWhereInput | ThreadScalarWhereInput[]
    id?: StringFilter<"Thread"> | string
    householdId?: StringFilter<"Thread"> | string
    authorId?: StringFilter<"Thread"> | string
    title?: StringNullableFilter<"Thread"> | string | null
    createdAt?: DateTimeFilter<"Thread"> | Date | string
    updatedAt?: DateTimeFilter<"Thread"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Thread"> | Date | string | null
  }

  export type ChoreAssignmentUpsertWithWhereUniqueWithoutUserInput = {
    where: ChoreAssignmentWhereUniqueInput
    update: XOR<ChoreAssignmentUpdateWithoutUserInput, ChoreAssignmentUncheckedUpdateWithoutUserInput>
    create: XOR<ChoreAssignmentCreateWithoutUserInput, ChoreAssignmentUncheckedCreateWithoutUserInput>
  }

  export type ChoreAssignmentUpdateWithWhereUniqueWithoutUserInput = {
    where: ChoreAssignmentWhereUniqueInput
    data: XOR<ChoreAssignmentUpdateWithoutUserInput, ChoreAssignmentUncheckedUpdateWithoutUserInput>
  }

  export type ChoreAssignmentUpdateManyWithWhereWithoutUserInput = {
    where: ChoreAssignmentScalarWhereInput
    data: XOR<ChoreAssignmentUpdateManyMutationInput, ChoreAssignmentUncheckedUpdateManyWithoutUserInput>
  }

  export type ChoreAssignmentScalarWhereInput = {
    AND?: ChoreAssignmentScalarWhereInput | ChoreAssignmentScalarWhereInput[]
    OR?: ChoreAssignmentScalarWhereInput[]
    NOT?: ChoreAssignmentScalarWhereInput | ChoreAssignmentScalarWhereInput[]
    id?: StringFilter<"ChoreAssignment"> | string
    choreId?: StringFilter<"ChoreAssignment"> | string
    userId?: StringFilter<"ChoreAssignment"> | string
    assignedAt?: DateTimeFilter<"ChoreAssignment"> | Date | string
    completedAt?: DateTimeNullableFilter<"ChoreAssignment"> | Date | string | null
  }

  export type ExpenseUpsertWithWhereUniqueWithoutPaidByInput = {
    where: ExpenseWhereUniqueInput
    update: XOR<ExpenseUpdateWithoutPaidByInput, ExpenseUncheckedUpdateWithoutPaidByInput>
    create: XOR<ExpenseCreateWithoutPaidByInput, ExpenseUncheckedCreateWithoutPaidByInput>
  }

  export type ExpenseUpdateWithWhereUniqueWithoutPaidByInput = {
    where: ExpenseWhereUniqueInput
    data: XOR<ExpenseUpdateWithoutPaidByInput, ExpenseUncheckedUpdateWithoutPaidByInput>
  }

  export type ExpenseUpdateManyWithWhereWithoutPaidByInput = {
    where: ExpenseScalarWhereInput
    data: XOR<ExpenseUpdateManyMutationInput, ExpenseUncheckedUpdateManyWithoutPaidByInput>
  }

  export type ExpenseScalarWhereInput = {
    AND?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
    OR?: ExpenseScalarWhereInput[]
    NOT?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
    id?: StringFilter<"Expense"> | string
    householdId?: StringFilter<"Expense"> | string
    amount?: FloatFilter<"Expense"> | number
    description?: StringFilter<"Expense"> | string
    paidById?: StringFilter<"Expense"> | string
    createdAt?: DateTimeFilter<"Expense"> | Date | string
    updatedAt?: DateTimeFilter<"Expense"> | Date | string
    dueDate?: DateTimeNullableFilter<"Expense"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"Expense"> | Date | string | null
    category?: EnumExpenseCategoryFilter<"Expense"> | $Enums.ExpenseCategory
  }

  export type ExpenseSplitUpsertWithWhereUniqueWithoutUserInput = {
    where: ExpenseSplitWhereUniqueInput
    update: XOR<ExpenseSplitUpdateWithoutUserInput, ExpenseSplitUncheckedUpdateWithoutUserInput>
    create: XOR<ExpenseSplitCreateWithoutUserInput, ExpenseSplitUncheckedCreateWithoutUserInput>
  }

  export type ExpenseSplitUpdateWithWhereUniqueWithoutUserInput = {
    where: ExpenseSplitWhereUniqueInput
    data: XOR<ExpenseSplitUpdateWithoutUserInput, ExpenseSplitUncheckedUpdateWithoutUserInput>
  }

  export type ExpenseSplitUpdateManyWithWhereWithoutUserInput = {
    where: ExpenseSplitScalarWhereInput
    data: XOR<ExpenseSplitUpdateManyMutationInput, ExpenseSplitUncheckedUpdateManyWithoutUserInput>
  }

  export type ExpenseSplitScalarWhereInput = {
    AND?: ExpenseSplitScalarWhereInput | ExpenseSplitScalarWhereInput[]
    OR?: ExpenseSplitScalarWhereInput[]
    NOT?: ExpenseSplitScalarWhereInput | ExpenseSplitScalarWhereInput[]
    id?: StringFilter<"ExpenseSplit"> | string
    expenseId?: StringFilter<"ExpenseSplit"> | string
    userId?: StringFilter<"ExpenseSplit"> | string
    amount?: FloatFilter<"ExpenseSplit"> | number
  }

  export type TransactionUpsertWithWhereUniqueWithoutFromUserInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutFromUserInput, TransactionUncheckedUpdateWithoutFromUserInput>
    create: XOR<TransactionCreateWithoutFromUserInput, TransactionUncheckedCreateWithoutFromUserInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutFromUserInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutFromUserInput, TransactionUncheckedUpdateWithoutFromUserInput>
  }

  export type TransactionUpdateManyWithWhereWithoutFromUserInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutFromUserInput>
  }

  export type TransactionScalarWhereInput = {
    AND?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    OR?: TransactionScalarWhereInput[]
    NOT?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    id?: StringFilter<"Transaction"> | string
    expenseId?: StringFilter<"Transaction"> | string
    fromUserId?: StringFilter<"Transaction"> | string
    toUserId?: StringFilter<"Transaction"> | string
    amount?: FloatFilter<"Transaction"> | number
    status?: EnumTransactionStatusFilter<"Transaction"> | $Enums.TransactionStatus
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeFilter<"Transaction"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Transaction"> | Date | string | null
  }

  export type TransactionUpsertWithWhereUniqueWithoutToUserInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutToUserInput, TransactionUncheckedUpdateWithoutToUserInput>
    create: XOR<TransactionCreateWithoutToUserInput, TransactionUncheckedCreateWithoutToUserInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutToUserInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutToUserInput, TransactionUncheckedUpdateWithoutToUserInput>
  }

  export type TransactionUpdateManyWithWhereWithoutToUserInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutToUserInput>
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    message?: StringFilter<"Notification"> | string
    isRead?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type OAuthIntegrationUpsertWithWhereUniqueWithoutUserInput = {
    where: OAuthIntegrationWhereUniqueInput
    update: XOR<OAuthIntegrationUpdateWithoutUserInput, OAuthIntegrationUncheckedUpdateWithoutUserInput>
    create: XOR<OAuthIntegrationCreateWithoutUserInput, OAuthIntegrationUncheckedCreateWithoutUserInput>
  }

  export type OAuthIntegrationUpdateWithWhereUniqueWithoutUserInput = {
    where: OAuthIntegrationWhereUniqueInput
    data: XOR<OAuthIntegrationUpdateWithoutUserInput, OAuthIntegrationUncheckedUpdateWithoutUserInput>
  }

  export type OAuthIntegrationUpdateManyWithWhereWithoutUserInput = {
    where: OAuthIntegrationScalarWhereInput
    data: XOR<OAuthIntegrationUpdateManyMutationInput, OAuthIntegrationUncheckedUpdateManyWithoutUserInput>
  }

  export type OAuthIntegrationScalarWhereInput = {
    AND?: OAuthIntegrationScalarWhereInput | OAuthIntegrationScalarWhereInput[]
    OR?: OAuthIntegrationScalarWhereInput[]
    NOT?: OAuthIntegrationScalarWhereInput | OAuthIntegrationScalarWhereInput[]
    id?: StringFilter<"OAuthIntegration"> | string
    userId?: StringFilter<"OAuthIntegration"> | string
    provider?: EnumProviderFilter<"OAuthIntegration"> | $Enums.Provider
    accessToken?: StringFilter<"OAuthIntegration"> | string
    refreshToken?: StringNullableFilter<"OAuthIntegration"> | string | null
    expiresAt?: DateTimeNullableFilter<"OAuthIntegration"> | Date | string | null
  }

  export type EventUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: EventWhereUniqueInput
    update: XOR<EventUpdateWithoutCreatedByInput, EventUncheckedUpdateWithoutCreatedByInput>
    create: XOR<EventCreateWithoutCreatedByInput, EventUncheckedCreateWithoutCreatedByInput>
  }

  export type EventUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: EventWhereUniqueInput
    data: XOR<EventUpdateWithoutCreatedByInput, EventUncheckedUpdateWithoutCreatedByInput>
  }

  export type EventUpdateManyWithWhereWithoutCreatedByInput = {
    where: EventScalarWhereInput
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type EventScalarWhereInput = {
    AND?: EventScalarWhereInput | EventScalarWhereInput[]
    OR?: EventScalarWhereInput[]
    NOT?: EventScalarWhereInput | EventScalarWhereInput[]
    id?: StringFilter<"Event"> | string
    householdId?: StringFilter<"Event"> | string
    title?: StringFilter<"Event"> | string
    description?: StringNullableFilter<"Event"> | string | null
    startTime?: DateTimeFilter<"Event"> | Date | string
    endTime?: DateTimeFilter<"Event"> | Date | string
    createdById?: StringFilter<"Event"> | string
    createdAt?: DateTimeFilter<"Event"> | Date | string
    updatedAt?: DateTimeFilter<"Event"> | Date | string
    choreId?: StringNullableFilter<"Event"> | string | null
    recurrenceRuleId?: StringNullableFilter<"Event"> | string | null
    category?: EnumEventCategoryFilter<"Event"> | $Enums.EventCategory
    isAllDay?: BoolFilter<"Event"> | boolean
    location?: StringNullableFilter<"Event"> | string | null
    isPrivate?: BoolFilter<"Event"> | boolean
    status?: EnumEventStatusFilter<"Event"> | $Enums.EventStatus
    deletedAt?: DateTimeNullableFilter<"Event"> | Date | string | null
  }

  export type ChoreSwapRequestUpsertWithWhereUniqueWithoutRequestingUserInput = {
    where: ChoreSwapRequestWhereUniqueInput
    update: XOR<ChoreSwapRequestUpdateWithoutRequestingUserInput, ChoreSwapRequestUncheckedUpdateWithoutRequestingUserInput>
    create: XOR<ChoreSwapRequestCreateWithoutRequestingUserInput, ChoreSwapRequestUncheckedCreateWithoutRequestingUserInput>
  }

  export type ChoreSwapRequestUpdateWithWhereUniqueWithoutRequestingUserInput = {
    where: ChoreSwapRequestWhereUniqueInput
    data: XOR<ChoreSwapRequestUpdateWithoutRequestingUserInput, ChoreSwapRequestUncheckedUpdateWithoutRequestingUserInput>
  }

  export type ChoreSwapRequestUpdateManyWithWhereWithoutRequestingUserInput = {
    where: ChoreSwapRequestScalarWhereInput
    data: XOR<ChoreSwapRequestUpdateManyMutationInput, ChoreSwapRequestUncheckedUpdateManyWithoutRequestingUserInput>
  }

  export type ChoreSwapRequestScalarWhereInput = {
    AND?: ChoreSwapRequestScalarWhereInput | ChoreSwapRequestScalarWhereInput[]
    OR?: ChoreSwapRequestScalarWhereInput[]
    NOT?: ChoreSwapRequestScalarWhereInput | ChoreSwapRequestScalarWhereInput[]
    id?: StringFilter<"ChoreSwapRequest"> | string
    choreId?: StringFilter<"ChoreSwapRequest"> | string
    requestingUserId?: StringFilter<"ChoreSwapRequest"> | string
    targetUserId?: StringFilter<"ChoreSwapRequest"> | string
    status?: EnumChoreSwapRequestStatusFilter<"ChoreSwapRequest"> | $Enums.ChoreSwapRequestStatus
    createdAt?: DateTimeFilter<"ChoreSwapRequest"> | Date | string
    updatedAt?: DateTimeFilter<"ChoreSwapRequest"> | Date | string
  }

  export type ChoreSwapRequestUpsertWithWhereUniqueWithoutTargetUserInput = {
    where: ChoreSwapRequestWhereUniqueInput
    update: XOR<ChoreSwapRequestUpdateWithoutTargetUserInput, ChoreSwapRequestUncheckedUpdateWithoutTargetUserInput>
    create: XOR<ChoreSwapRequestCreateWithoutTargetUserInput, ChoreSwapRequestUncheckedCreateWithoutTargetUserInput>
  }

  export type ChoreSwapRequestUpdateWithWhereUniqueWithoutTargetUserInput = {
    where: ChoreSwapRequestWhereUniqueInput
    data: XOR<ChoreSwapRequestUpdateWithoutTargetUserInput, ChoreSwapRequestUncheckedUpdateWithoutTargetUserInput>
  }

  export type ChoreSwapRequestUpdateManyWithWhereWithoutTargetUserInput = {
    where: ChoreSwapRequestScalarWhereInput
    data: XOR<ChoreSwapRequestUpdateManyMutationInput, ChoreSwapRequestUncheckedUpdateManyWithoutTargetUserInput>
  }

  export type ReactionUpsertWithWhereUniqueWithoutUserInput = {
    where: ReactionWhereUniqueInput
    update: XOR<ReactionUpdateWithoutUserInput, ReactionUncheckedUpdateWithoutUserInput>
    create: XOR<ReactionCreateWithoutUserInput, ReactionUncheckedCreateWithoutUserInput>
  }

  export type ReactionUpdateWithWhereUniqueWithoutUserInput = {
    where: ReactionWhereUniqueInput
    data: XOR<ReactionUpdateWithoutUserInput, ReactionUncheckedUpdateWithoutUserInput>
  }

  export type ReactionUpdateManyWithWhereWithoutUserInput = {
    where: ReactionScalarWhereInput
    data: XOR<ReactionUpdateManyMutationInput, ReactionUncheckedUpdateManyWithoutUserInput>
  }

  export type ReactionScalarWhereInput = {
    AND?: ReactionScalarWhereInput | ReactionScalarWhereInput[]
    OR?: ReactionScalarWhereInput[]
    NOT?: ReactionScalarWhereInput | ReactionScalarWhereInput[]
    id?: StringFilter<"Reaction"> | string
    messageId?: StringFilter<"Reaction"> | string
    userId?: StringFilter<"Reaction"> | string
    emoji?: StringFilter<"Reaction"> | string
    type?: EnumReactionTypeFilter<"Reaction"> | $Enums.ReactionType
    createdAt?: DateTimeFilter<"Reaction"> | Date | string
  }

  export type MentionUpsertWithWhereUniqueWithoutUserInput = {
    where: MentionWhereUniqueInput
    update: XOR<MentionUpdateWithoutUserInput, MentionUncheckedUpdateWithoutUserInput>
    create: XOR<MentionCreateWithoutUserInput, MentionUncheckedCreateWithoutUserInput>
  }

  export type MentionUpdateWithWhereUniqueWithoutUserInput = {
    where: MentionWhereUniqueInput
    data: XOR<MentionUpdateWithoutUserInput, MentionUncheckedUpdateWithoutUserInput>
  }

  export type MentionUpdateManyWithWhereWithoutUserInput = {
    where: MentionScalarWhereInput
    data: XOR<MentionUpdateManyMutationInput, MentionUncheckedUpdateManyWithoutUserInput>
  }

  export type MentionScalarWhereInput = {
    AND?: MentionScalarWhereInput | MentionScalarWhereInput[]
    OR?: MentionScalarWhereInput[]
    NOT?: MentionScalarWhereInput | MentionScalarWhereInput[]
    id?: StringFilter<"Mention"> | string
    messageId?: StringFilter<"Mention"> | string
    userId?: StringFilter<"Mention"> | string
    mentionedAt?: DateTimeFilter<"Mention"> | Date | string
  }

  export type ChoreHistoryUpsertWithWhereUniqueWithoutUserInput = {
    where: ChoreHistoryWhereUniqueInput
    update: XOR<ChoreHistoryUpdateWithoutUserInput, ChoreHistoryUncheckedUpdateWithoutUserInput>
    create: XOR<ChoreHistoryCreateWithoutUserInput, ChoreHistoryUncheckedCreateWithoutUserInput>
  }

  export type ChoreHistoryUpdateWithWhereUniqueWithoutUserInput = {
    where: ChoreHistoryWhereUniqueInput
    data: XOR<ChoreHistoryUpdateWithoutUserInput, ChoreHistoryUncheckedUpdateWithoutUserInput>
  }

  export type ChoreHistoryUpdateManyWithWhereWithoutUserInput = {
    where: ChoreHistoryScalarWhereInput
    data: XOR<ChoreHistoryUpdateManyMutationInput, ChoreHistoryUncheckedUpdateManyWithoutUserInput>
  }

  export type ChoreHistoryScalarWhereInput = {
    AND?: ChoreHistoryScalarWhereInput | ChoreHistoryScalarWhereInput[]
    OR?: ChoreHistoryScalarWhereInput[]
    NOT?: ChoreHistoryScalarWhereInput | ChoreHistoryScalarWhereInput[]
    id?: StringFilter<"ChoreHistory"> | string
    choreId?: StringFilter<"ChoreHistory"> | string
    action?: EnumChoreActionFilter<"ChoreHistory"> | $Enums.ChoreAction
    changedById?: StringFilter<"ChoreHistory"> | string
    changedAt?: DateTimeFilter<"ChoreHistory"> | Date | string
  }

  export type NotificationSettingsUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationSettingsWhereUniqueInput
    update: XOR<NotificationSettingsUpdateWithoutUserInput, NotificationSettingsUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationSettingsCreateWithoutUserInput, NotificationSettingsUncheckedCreateWithoutUserInput>
  }

  export type NotificationSettingsUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationSettingsWhereUniqueInput
    data: XOR<NotificationSettingsUpdateWithoutUserInput, NotificationSettingsUncheckedUpdateWithoutUserInput>
  }

  export type NotificationSettingsUpdateManyWithWhereWithoutUserInput = {
    where: NotificationSettingsScalarWhereInput
    data: XOR<NotificationSettingsUpdateManyMutationInput, NotificationSettingsUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationSettingsScalarWhereInput = {
    AND?: NotificationSettingsScalarWhereInput | NotificationSettingsScalarWhereInput[]
    OR?: NotificationSettingsScalarWhereInput[]
    NOT?: NotificationSettingsScalarWhereInput | NotificationSettingsScalarWhereInput[]
    id?: StringFilter<"NotificationSettings"> | string
    userId?: StringNullableFilter<"NotificationSettings"> | string | null
    householdId?: StringNullableFilter<"NotificationSettings"> | string | null
    messageNotif?: BoolFilter<"NotificationSettings"> | boolean
    mentionsNotif?: BoolFilter<"NotificationSettings"> | boolean
    reactionsNotif?: BoolFilter<"NotificationSettings"> | boolean
    choreNotif?: BoolFilter<"NotificationSettings"> | boolean
    financeNotif?: BoolFilter<"NotificationSettings"> | boolean
    calendarNotif?: BoolFilter<"NotificationSettings"> | boolean
    remindersNotif?: BoolFilter<"NotificationSettings"> | boolean
  }

  export type CalendarEventHistoryUpsertWithWhereUniqueWithoutUserInput = {
    where: CalendarEventHistoryWhereUniqueInput
    update: XOR<CalendarEventHistoryUpdateWithoutUserInput, CalendarEventHistoryUncheckedUpdateWithoutUserInput>
    create: XOR<CalendarEventHistoryCreateWithoutUserInput, CalendarEventHistoryUncheckedCreateWithoutUserInput>
  }

  export type CalendarEventHistoryUpdateWithWhereUniqueWithoutUserInput = {
    where: CalendarEventHistoryWhereUniqueInput
    data: XOR<CalendarEventHistoryUpdateWithoutUserInput, CalendarEventHistoryUncheckedUpdateWithoutUserInput>
  }

  export type CalendarEventHistoryUpdateManyWithWhereWithoutUserInput = {
    where: CalendarEventHistoryScalarWhereInput
    data: XOR<CalendarEventHistoryUpdateManyMutationInput, CalendarEventHistoryUncheckedUpdateManyWithoutUserInput>
  }

  export type CalendarEventHistoryScalarWhereInput = {
    AND?: CalendarEventHistoryScalarWhereInput | CalendarEventHistoryScalarWhereInput[]
    OR?: CalendarEventHistoryScalarWhereInput[]
    NOT?: CalendarEventHistoryScalarWhereInput | CalendarEventHistoryScalarWhereInput[]
    id?: StringFilter<"CalendarEventHistory"> | string
    eventId?: StringFilter<"CalendarEventHistory"> | string
    action?: EnumCalendarEventActionFilter<"CalendarEventHistory"> | $Enums.CalendarEventAction
    changedById?: StringFilter<"CalendarEventHistory"> | string
    changedAt?: DateTimeFilter<"CalendarEventHistory"> | Date | string
  }

  export type ExpenseHistoryUpsertWithWhereUniqueWithoutUserInput = {
    where: ExpenseHistoryWhereUniqueInput
    update: XOR<ExpenseHistoryUpdateWithoutUserInput, ExpenseHistoryUncheckedUpdateWithoutUserInput>
    create: XOR<ExpenseHistoryCreateWithoutUserInput, ExpenseHistoryUncheckedCreateWithoutUserInput>
  }

  export type ExpenseHistoryUpdateWithWhereUniqueWithoutUserInput = {
    where: ExpenseHistoryWhereUniqueInput
    data: XOR<ExpenseHistoryUpdateWithoutUserInput, ExpenseHistoryUncheckedUpdateWithoutUserInput>
  }

  export type ExpenseHistoryUpdateManyWithWhereWithoutUserInput = {
    where: ExpenseHistoryScalarWhereInput
    data: XOR<ExpenseHistoryUpdateManyMutationInput, ExpenseHistoryUncheckedUpdateManyWithoutUserInput>
  }

  export type ExpenseHistoryScalarWhereInput = {
    AND?: ExpenseHistoryScalarWhereInput | ExpenseHistoryScalarWhereInput[]
    OR?: ExpenseHistoryScalarWhereInput[]
    NOT?: ExpenseHistoryScalarWhereInput | ExpenseHistoryScalarWhereInput[]
    id?: StringFilter<"ExpenseHistory"> | string
    expenseId?: StringFilter<"ExpenseHistory"> | string
    action?: EnumExpenseActionFilter<"ExpenseHistory"> | $Enums.ExpenseAction
    changedById?: StringFilter<"ExpenseHistory"> | string
    changedAt?: DateTimeFilter<"ExpenseHistory"> | Date | string
  }

  export type MessageReadUpsertWithWhereUniqueWithoutUserInput = {
    where: MessageReadWhereUniqueInput
    update: XOR<MessageReadUpdateWithoutUserInput, MessageReadUncheckedUpdateWithoutUserInput>
    create: XOR<MessageReadCreateWithoutUserInput, MessageReadUncheckedCreateWithoutUserInput>
  }

  export type MessageReadUpdateWithWhereUniqueWithoutUserInput = {
    where: MessageReadWhereUniqueInput
    data: XOR<MessageReadUpdateWithoutUserInput, MessageReadUncheckedUpdateWithoutUserInput>
  }

  export type MessageReadUpdateManyWithWhereWithoutUserInput = {
    where: MessageReadScalarWhereInput
    data: XOR<MessageReadUpdateManyMutationInput, MessageReadUncheckedUpdateManyWithoutUserInput>
  }

  export type MessageReadScalarWhereInput = {
    AND?: MessageReadScalarWhereInput | MessageReadScalarWhereInput[]
    OR?: MessageReadScalarWhereInput[]
    NOT?: MessageReadScalarWhereInput | MessageReadScalarWhereInput[]
    id?: StringFilter<"MessageRead"> | string
    messageId?: StringFilter<"MessageRead"> | string
    userId?: StringFilter<"MessageRead"> | string
    readAt?: DateTimeFilter<"MessageRead"> | Date | string
  }

  export type HouseholdMemberCreateWithoutHouseholdInput = {
    id?: string
    role?: $Enums.HouseholdRole
    joinedAt?: Date | string
    leftAt?: Date | string | null
    isInvited?: boolean
    isAccepted?: boolean
    isRejected?: boolean
    isSelected?: boolean
    lastAssignedChoreAt?: Date | string | null
    user: UserCreateNestedOneWithoutHouseholdsInput
    threads?: ThreadCreateNestedManyWithoutParticipantsInput
  }

  export type HouseholdMemberUncheckedCreateWithoutHouseholdInput = {
    id?: string
    userId: string
    role?: $Enums.HouseholdRole
    joinedAt?: Date | string
    leftAt?: Date | string | null
    isInvited?: boolean
    isAccepted?: boolean
    isRejected?: boolean
    isSelected?: boolean
    lastAssignedChoreAt?: Date | string | null
    threads?: ThreadUncheckedCreateNestedManyWithoutParticipantsInput
  }

  export type HouseholdMemberCreateOrConnectWithoutHouseholdInput = {
    where: HouseholdMemberWhereUniqueInput
    create: XOR<HouseholdMemberCreateWithoutHouseholdInput, HouseholdMemberUncheckedCreateWithoutHouseholdInput>
  }

  export type HouseholdMemberCreateManyHouseholdInputEnvelope = {
    data: HouseholdMemberCreateManyHouseholdInput | HouseholdMemberCreateManyHouseholdInput[]
    skipDuplicates?: boolean
  }

  export type ThreadCreateWithoutHouseholdInput = {
    id?: string
    title?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    author: UserCreateNestedOneWithoutThreadsInput
    messages?: MessageCreateNestedManyWithoutThreadInput
    participants?: HouseholdMemberCreateNestedManyWithoutThreadsInput
  }

  export type ThreadUncheckedCreateWithoutHouseholdInput = {
    id?: string
    authorId: string
    title?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    messages?: MessageUncheckedCreateNestedManyWithoutThreadInput
    participants?: HouseholdMemberUncheckedCreateNestedManyWithoutThreadsInput
  }

  export type ThreadCreateOrConnectWithoutHouseholdInput = {
    where: ThreadWhereUniqueInput
    create: XOR<ThreadCreateWithoutHouseholdInput, ThreadUncheckedCreateWithoutHouseholdInput>
  }

  export type ThreadCreateManyHouseholdInputEnvelope = {
    data: ThreadCreateManyHouseholdInput | ThreadCreateManyHouseholdInput[]
    skipDuplicates?: boolean
  }

  export type ChoreCreateWithoutHouseholdInput = {
    id?: string
    title: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dueDate?: Date | string | null
    status?: $Enums.ChoreStatus
    priority?: number | null
    deletedAt?: Date | string | null
    subtasks?: SubtaskCreateNestedManyWithoutChoreInput
    assignedUsers?: ChoreAssignmentCreateNestedManyWithoutChoreInput
    event?: EventCreateNestedOneWithoutChoreInput
    choreSwapRequests?: ChoreSwapRequestCreateNestedManyWithoutChoreInput
    recurrenceRule?: RecurrenceRuleCreateNestedOneWithoutChoresInput
    history?: ChoreHistoryCreateNestedManyWithoutChoreInput
  }

  export type ChoreUncheckedCreateWithoutHouseholdInput = {
    id?: string
    title: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dueDate?: Date | string | null
    status?: $Enums.ChoreStatus
    priority?: number | null
    eventId?: string | null
    recurrenceRuleId?: string | null
    deletedAt?: Date | string | null
    subtasks?: SubtaskUncheckedCreateNestedManyWithoutChoreInput
    assignedUsers?: ChoreAssignmentUncheckedCreateNestedManyWithoutChoreInput
    choreSwapRequests?: ChoreSwapRequestUncheckedCreateNestedManyWithoutChoreInput
    history?: ChoreHistoryUncheckedCreateNestedManyWithoutChoreInput
  }

  export type ChoreCreateOrConnectWithoutHouseholdInput = {
    where: ChoreWhereUniqueInput
    create: XOR<ChoreCreateWithoutHouseholdInput, ChoreUncheckedCreateWithoutHouseholdInput>
  }

  export type ChoreCreateManyHouseholdInputEnvelope = {
    data: ChoreCreateManyHouseholdInput | ChoreCreateManyHouseholdInput[]
    skipDuplicates?: boolean
  }

  export type ExpenseCreateWithoutHouseholdInput = {
    id?: string
    amount: number
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    dueDate?: Date | string | null
    deletedAt?: Date | string | null
    category: $Enums.ExpenseCategory
    paidBy: UserCreateNestedOneWithoutExpensesPaidInput
    splits?: ExpenseSplitCreateNestedManyWithoutExpenseInput
    transactions?: TransactionCreateNestedManyWithoutExpenseInput
    receipts?: ReceiptCreateNestedManyWithoutExpenseInput
    history?: ExpenseHistoryCreateNestedManyWithoutExpenseInput
  }

  export type ExpenseUncheckedCreateWithoutHouseholdInput = {
    id?: string
    amount: number
    description: string
    paidById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    dueDate?: Date | string | null
    deletedAt?: Date | string | null
    category: $Enums.ExpenseCategory
    splits?: ExpenseSplitUncheckedCreateNestedManyWithoutExpenseInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutExpenseInput
    receipts?: ReceiptUncheckedCreateNestedManyWithoutExpenseInput
    history?: ExpenseHistoryUncheckedCreateNestedManyWithoutExpenseInput
  }

  export type ExpenseCreateOrConnectWithoutHouseholdInput = {
    where: ExpenseWhereUniqueInput
    create: XOR<ExpenseCreateWithoutHouseholdInput, ExpenseUncheckedCreateWithoutHouseholdInput>
  }

  export type ExpenseCreateManyHouseholdInputEnvelope = {
    data: ExpenseCreateManyHouseholdInput | ExpenseCreateManyHouseholdInput[]
    skipDuplicates?: boolean
  }

  export type EventCreateWithoutHouseholdInput = {
    id?: string
    title: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    choreId?: string | null
    category?: $Enums.EventCategory
    isAllDay?: boolean
    location?: string | null
    isPrivate?: boolean
    status?: $Enums.EventStatus
    deletedAt?: Date | string | null
    reminders?: EventReminderCreateNestedManyWithoutEventInput
    createdBy: UserCreateNestedOneWithoutEventsCreatedInput
    chore?: ChoreCreateNestedOneWithoutEventInput
    recurrenceRule?: RecurrenceRuleCreateNestedOneWithoutEventsInput
    history?: CalendarEventHistoryCreateNestedManyWithoutEventInput
  }

  export type EventUncheckedCreateWithoutHouseholdInput = {
    id?: string
    title: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    choreId?: string | null
    recurrenceRuleId?: string | null
    category?: $Enums.EventCategory
    isAllDay?: boolean
    location?: string | null
    isPrivate?: boolean
    status?: $Enums.EventStatus
    deletedAt?: Date | string | null
    reminders?: EventReminderUncheckedCreateNestedManyWithoutEventInput
    chore?: ChoreUncheckedCreateNestedOneWithoutEventInput
    history?: CalendarEventHistoryUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventCreateOrConnectWithoutHouseholdInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutHouseholdInput, EventUncheckedCreateWithoutHouseholdInput>
  }

  export type EventCreateManyHouseholdInputEnvelope = {
    data: EventCreateManyHouseholdInput | EventCreateManyHouseholdInput[]
    skipDuplicates?: boolean
  }

  export type ChoreTemplateCreateWithoutHouseholdInput = {
    id?: string
    title: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subtasks?: SubtaskTemplateCreateNestedManyWithoutChoreTemplateInput
  }

  export type ChoreTemplateUncheckedCreateWithoutHouseholdInput = {
    id?: string
    title: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subtasks?: SubtaskTemplateUncheckedCreateNestedManyWithoutChoreTemplateInput
  }

  export type ChoreTemplateCreateOrConnectWithoutHouseholdInput = {
    where: ChoreTemplateWhereUniqueInput
    create: XOR<ChoreTemplateCreateWithoutHouseholdInput, ChoreTemplateUncheckedCreateWithoutHouseholdInput>
  }

  export type ChoreTemplateCreateManyHouseholdInputEnvelope = {
    data: ChoreTemplateCreateManyHouseholdInput | ChoreTemplateCreateManyHouseholdInput[]
    skipDuplicates?: boolean
  }

  export type NotificationSettingsCreateWithoutHouseholdInput = {
    id?: string
    messageNotif?: boolean
    mentionsNotif?: boolean
    reactionsNotif?: boolean
    choreNotif?: boolean
    financeNotif?: boolean
    calendarNotif?: boolean
    remindersNotif?: boolean
    user?: UserCreateNestedOneWithoutNotificationSettingsInput
  }

  export type NotificationSettingsUncheckedCreateWithoutHouseholdInput = {
    id?: string
    userId?: string | null
    messageNotif?: boolean
    mentionsNotif?: boolean
    reactionsNotif?: boolean
    choreNotif?: boolean
    financeNotif?: boolean
    calendarNotif?: boolean
    remindersNotif?: boolean
  }

  export type NotificationSettingsCreateOrConnectWithoutHouseholdInput = {
    where: NotificationSettingsWhereUniqueInput
    create: XOR<NotificationSettingsCreateWithoutHouseholdInput, NotificationSettingsUncheckedCreateWithoutHouseholdInput>
  }

  export type NotificationSettingsCreateManyHouseholdInputEnvelope = {
    data: NotificationSettingsCreateManyHouseholdInput | NotificationSettingsCreateManyHouseholdInput[]
    skipDuplicates?: boolean
  }

  export type HouseholdMemberUpsertWithWhereUniqueWithoutHouseholdInput = {
    where: HouseholdMemberWhereUniqueInput
    update: XOR<HouseholdMemberUpdateWithoutHouseholdInput, HouseholdMemberUncheckedUpdateWithoutHouseholdInput>
    create: XOR<HouseholdMemberCreateWithoutHouseholdInput, HouseholdMemberUncheckedCreateWithoutHouseholdInput>
  }

  export type HouseholdMemberUpdateWithWhereUniqueWithoutHouseholdInput = {
    where: HouseholdMemberWhereUniqueInput
    data: XOR<HouseholdMemberUpdateWithoutHouseholdInput, HouseholdMemberUncheckedUpdateWithoutHouseholdInput>
  }

  export type HouseholdMemberUpdateManyWithWhereWithoutHouseholdInput = {
    where: HouseholdMemberScalarWhereInput
    data: XOR<HouseholdMemberUpdateManyMutationInput, HouseholdMemberUncheckedUpdateManyWithoutHouseholdInput>
  }

  export type ThreadUpsertWithWhereUniqueWithoutHouseholdInput = {
    where: ThreadWhereUniqueInput
    update: XOR<ThreadUpdateWithoutHouseholdInput, ThreadUncheckedUpdateWithoutHouseholdInput>
    create: XOR<ThreadCreateWithoutHouseholdInput, ThreadUncheckedCreateWithoutHouseholdInput>
  }

  export type ThreadUpdateWithWhereUniqueWithoutHouseholdInput = {
    where: ThreadWhereUniqueInput
    data: XOR<ThreadUpdateWithoutHouseholdInput, ThreadUncheckedUpdateWithoutHouseholdInput>
  }

  export type ThreadUpdateManyWithWhereWithoutHouseholdInput = {
    where: ThreadScalarWhereInput
    data: XOR<ThreadUpdateManyMutationInput, ThreadUncheckedUpdateManyWithoutHouseholdInput>
  }

  export type ChoreUpsertWithWhereUniqueWithoutHouseholdInput = {
    where: ChoreWhereUniqueInput
    update: XOR<ChoreUpdateWithoutHouseholdInput, ChoreUncheckedUpdateWithoutHouseholdInput>
    create: XOR<ChoreCreateWithoutHouseholdInput, ChoreUncheckedCreateWithoutHouseholdInput>
  }

  export type ChoreUpdateWithWhereUniqueWithoutHouseholdInput = {
    where: ChoreWhereUniqueInput
    data: XOR<ChoreUpdateWithoutHouseholdInput, ChoreUncheckedUpdateWithoutHouseholdInput>
  }

  export type ChoreUpdateManyWithWhereWithoutHouseholdInput = {
    where: ChoreScalarWhereInput
    data: XOR<ChoreUpdateManyMutationInput, ChoreUncheckedUpdateManyWithoutHouseholdInput>
  }

  export type ChoreScalarWhereInput = {
    AND?: ChoreScalarWhereInput | ChoreScalarWhereInput[]
    OR?: ChoreScalarWhereInput[]
    NOT?: ChoreScalarWhereInput | ChoreScalarWhereInput[]
    id?: StringFilter<"Chore"> | string
    householdId?: StringFilter<"Chore"> | string
    title?: StringFilter<"Chore"> | string
    description?: StringNullableFilter<"Chore"> | string | null
    createdAt?: DateTimeFilter<"Chore"> | Date | string
    updatedAt?: DateTimeFilter<"Chore"> | Date | string
    dueDate?: DateTimeNullableFilter<"Chore"> | Date | string | null
    status?: EnumChoreStatusFilter<"Chore"> | $Enums.ChoreStatus
    priority?: IntNullableFilter<"Chore"> | number | null
    eventId?: StringNullableFilter<"Chore"> | string | null
    recurrenceRuleId?: StringNullableFilter<"Chore"> | string | null
    deletedAt?: DateTimeNullableFilter<"Chore"> | Date | string | null
  }

  export type ExpenseUpsertWithWhereUniqueWithoutHouseholdInput = {
    where: ExpenseWhereUniqueInput
    update: XOR<ExpenseUpdateWithoutHouseholdInput, ExpenseUncheckedUpdateWithoutHouseholdInput>
    create: XOR<ExpenseCreateWithoutHouseholdInput, ExpenseUncheckedCreateWithoutHouseholdInput>
  }

  export type ExpenseUpdateWithWhereUniqueWithoutHouseholdInput = {
    where: ExpenseWhereUniqueInput
    data: XOR<ExpenseUpdateWithoutHouseholdInput, ExpenseUncheckedUpdateWithoutHouseholdInput>
  }

  export type ExpenseUpdateManyWithWhereWithoutHouseholdInput = {
    where: ExpenseScalarWhereInput
    data: XOR<ExpenseUpdateManyMutationInput, ExpenseUncheckedUpdateManyWithoutHouseholdInput>
  }

  export type EventUpsertWithWhereUniqueWithoutHouseholdInput = {
    where: EventWhereUniqueInput
    update: XOR<EventUpdateWithoutHouseholdInput, EventUncheckedUpdateWithoutHouseholdInput>
    create: XOR<EventCreateWithoutHouseholdInput, EventUncheckedCreateWithoutHouseholdInput>
  }

  export type EventUpdateWithWhereUniqueWithoutHouseholdInput = {
    where: EventWhereUniqueInput
    data: XOR<EventUpdateWithoutHouseholdInput, EventUncheckedUpdateWithoutHouseholdInput>
  }

  export type EventUpdateManyWithWhereWithoutHouseholdInput = {
    where: EventScalarWhereInput
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyWithoutHouseholdInput>
  }

  export type ChoreTemplateUpsertWithWhereUniqueWithoutHouseholdInput = {
    where: ChoreTemplateWhereUniqueInput
    update: XOR<ChoreTemplateUpdateWithoutHouseholdInput, ChoreTemplateUncheckedUpdateWithoutHouseholdInput>
    create: XOR<ChoreTemplateCreateWithoutHouseholdInput, ChoreTemplateUncheckedCreateWithoutHouseholdInput>
  }

  export type ChoreTemplateUpdateWithWhereUniqueWithoutHouseholdInput = {
    where: ChoreTemplateWhereUniqueInput
    data: XOR<ChoreTemplateUpdateWithoutHouseholdInput, ChoreTemplateUncheckedUpdateWithoutHouseholdInput>
  }

  export type ChoreTemplateUpdateManyWithWhereWithoutHouseholdInput = {
    where: ChoreTemplateScalarWhereInput
    data: XOR<ChoreTemplateUpdateManyMutationInput, ChoreTemplateUncheckedUpdateManyWithoutHouseholdInput>
  }

  export type ChoreTemplateScalarWhereInput = {
    AND?: ChoreTemplateScalarWhereInput | ChoreTemplateScalarWhereInput[]
    OR?: ChoreTemplateScalarWhereInput[]
    NOT?: ChoreTemplateScalarWhereInput | ChoreTemplateScalarWhereInput[]
    id?: StringFilter<"ChoreTemplate"> | string
    householdId?: StringFilter<"ChoreTemplate"> | string
    title?: StringFilter<"ChoreTemplate"> | string
    description?: StringNullableFilter<"ChoreTemplate"> | string | null
    createdAt?: DateTimeFilter<"ChoreTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"ChoreTemplate"> | Date | string
  }

  export type NotificationSettingsUpsertWithWhereUniqueWithoutHouseholdInput = {
    where: NotificationSettingsWhereUniqueInput
    update: XOR<NotificationSettingsUpdateWithoutHouseholdInput, NotificationSettingsUncheckedUpdateWithoutHouseholdInput>
    create: XOR<NotificationSettingsCreateWithoutHouseholdInput, NotificationSettingsUncheckedCreateWithoutHouseholdInput>
  }

  export type NotificationSettingsUpdateWithWhereUniqueWithoutHouseholdInput = {
    where: NotificationSettingsWhereUniqueInput
    data: XOR<NotificationSettingsUpdateWithoutHouseholdInput, NotificationSettingsUncheckedUpdateWithoutHouseholdInput>
  }

  export type NotificationSettingsUpdateManyWithWhereWithoutHouseholdInput = {
    where: NotificationSettingsScalarWhereInput
    data: XOR<NotificationSettingsUpdateManyMutationInput, NotificationSettingsUncheckedUpdateManyWithoutHouseholdInput>
  }

  export type UserCreateWithoutHouseholdsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    name: string
    profileImageURL?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deviceTokens?: UserCreatedeviceTokensInput | string[]
    deletedAt?: Date | string | null
    messages?: MessageCreateNestedManyWithoutAuthorInput
    threads?: ThreadCreateNestedManyWithoutAuthorInput
    assignedChores?: ChoreAssignmentCreateNestedManyWithoutUserInput
    expensesPaid?: ExpenseCreateNestedManyWithoutPaidByInput
    expenseSplits?: ExpenseSplitCreateNestedManyWithoutUserInput
    transactionsFrom?: TransactionCreateNestedManyWithoutFromUserInput
    transactionsTo?: TransactionCreateNestedManyWithoutToUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    oauthIntegrations?: OAuthIntegrationCreateNestedManyWithoutUserInput
    eventsCreated?: EventCreateNestedManyWithoutCreatedByInput
    choreSwapRequestsInitiated?: ChoreSwapRequestCreateNestedManyWithoutRequestingUserInput
    choreSwapRequestsReceived?: ChoreSwapRequestCreateNestedManyWithoutTargetUserInput
    reactions?: ReactionCreateNestedManyWithoutUserInput
    mentions?: MentionCreateNestedManyWithoutUserInput
    choreHistory?: ChoreHistoryCreateNestedManyWithoutUserInput
    notificationSettings?: NotificationSettingsCreateNestedManyWithoutUserInput
    calendarEventHistory?: CalendarEventHistoryCreateNestedManyWithoutUserInput
    expenseHistory?: ExpenseHistoryCreateNestedManyWithoutUserInput
    messageReads?: MessageReadCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutHouseholdsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    name: string
    profileImageURL?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deviceTokens?: UserCreatedeviceTokensInput | string[]
    deletedAt?: Date | string | null
    messages?: MessageUncheckedCreateNestedManyWithoutAuthorInput
    threads?: ThreadUncheckedCreateNestedManyWithoutAuthorInput
    assignedChores?: ChoreAssignmentUncheckedCreateNestedManyWithoutUserInput
    expensesPaid?: ExpenseUncheckedCreateNestedManyWithoutPaidByInput
    expenseSplits?: ExpenseSplitUncheckedCreateNestedManyWithoutUserInput
    transactionsFrom?: TransactionUncheckedCreateNestedManyWithoutFromUserInput
    transactionsTo?: TransactionUncheckedCreateNestedManyWithoutToUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    oauthIntegrations?: OAuthIntegrationUncheckedCreateNestedManyWithoutUserInput
    eventsCreated?: EventUncheckedCreateNestedManyWithoutCreatedByInput
    choreSwapRequestsInitiated?: ChoreSwapRequestUncheckedCreateNestedManyWithoutRequestingUserInput
    choreSwapRequestsReceived?: ChoreSwapRequestUncheckedCreateNestedManyWithoutTargetUserInput
    reactions?: ReactionUncheckedCreateNestedManyWithoutUserInput
    mentions?: MentionUncheckedCreateNestedManyWithoutUserInput
    choreHistory?: ChoreHistoryUncheckedCreateNestedManyWithoutUserInput
    notificationSettings?: NotificationSettingsUncheckedCreateNestedManyWithoutUserInput
    calendarEventHistory?: CalendarEventHistoryUncheckedCreateNestedManyWithoutUserInput
    expenseHistory?: ExpenseHistoryUncheckedCreateNestedManyWithoutUserInput
    messageReads?: MessageReadUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutHouseholdsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutHouseholdsInput, UserUncheckedCreateWithoutHouseholdsInput>
  }

  export type HouseholdCreateWithoutMembersInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    currency?: string
    icon?: string | null
    timezone?: string
    language?: string
    deletedAt?: Date | string | null
    threads?: ThreadCreateNestedManyWithoutHouseholdInput
    chores?: ChoreCreateNestedManyWithoutHouseholdInput
    expenses?: ExpenseCreateNestedManyWithoutHouseholdInput
    events?: EventCreateNestedManyWithoutHouseholdInput
    choreTemplates?: ChoreTemplateCreateNestedManyWithoutHouseholdInput
    notificationSettings?: NotificationSettingsCreateNestedManyWithoutHouseholdInput
  }

  export type HouseholdUncheckedCreateWithoutMembersInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    currency?: string
    icon?: string | null
    timezone?: string
    language?: string
    deletedAt?: Date | string | null
    threads?: ThreadUncheckedCreateNestedManyWithoutHouseholdInput
    chores?: ChoreUncheckedCreateNestedManyWithoutHouseholdInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutHouseholdInput
    events?: EventUncheckedCreateNestedManyWithoutHouseholdInput
    choreTemplates?: ChoreTemplateUncheckedCreateNestedManyWithoutHouseholdInput
    notificationSettings?: NotificationSettingsUncheckedCreateNestedManyWithoutHouseholdInput
  }

  export type HouseholdCreateOrConnectWithoutMembersInput = {
    where: HouseholdWhereUniqueInput
    create: XOR<HouseholdCreateWithoutMembersInput, HouseholdUncheckedCreateWithoutMembersInput>
  }

  export type ThreadCreateWithoutParticipantsInput = {
    id?: string
    title?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    household: HouseholdCreateNestedOneWithoutThreadsInput
    author: UserCreateNestedOneWithoutThreadsInput
    messages?: MessageCreateNestedManyWithoutThreadInput
  }

  export type ThreadUncheckedCreateWithoutParticipantsInput = {
    id?: string
    householdId: string
    authorId: string
    title?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    messages?: MessageUncheckedCreateNestedManyWithoutThreadInput
  }

  export type ThreadCreateOrConnectWithoutParticipantsInput = {
    where: ThreadWhereUniqueInput
    create: XOR<ThreadCreateWithoutParticipantsInput, ThreadUncheckedCreateWithoutParticipantsInput>
  }

  export type UserUpsertWithoutHouseholdsInput = {
    update: XOR<UserUpdateWithoutHouseholdsInput, UserUncheckedUpdateWithoutHouseholdsInput>
    create: XOR<UserCreateWithoutHouseholdsInput, UserUncheckedCreateWithoutHouseholdsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutHouseholdsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutHouseholdsInput, UserUncheckedUpdateWithoutHouseholdsInput>
  }

  export type UserUpdateWithoutHouseholdsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    profileImageURL?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deviceTokens?: UserUpdatedeviceTokensInput | string[]
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: MessageUpdateManyWithoutAuthorNestedInput
    threads?: ThreadUpdateManyWithoutAuthorNestedInput
    assignedChores?: ChoreAssignmentUpdateManyWithoutUserNestedInput
    expensesPaid?: ExpenseUpdateManyWithoutPaidByNestedInput
    expenseSplits?: ExpenseSplitUpdateManyWithoutUserNestedInput
    transactionsFrom?: TransactionUpdateManyWithoutFromUserNestedInput
    transactionsTo?: TransactionUpdateManyWithoutToUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    oauthIntegrations?: OAuthIntegrationUpdateManyWithoutUserNestedInput
    eventsCreated?: EventUpdateManyWithoutCreatedByNestedInput
    choreSwapRequestsInitiated?: ChoreSwapRequestUpdateManyWithoutRequestingUserNestedInput
    choreSwapRequestsReceived?: ChoreSwapRequestUpdateManyWithoutTargetUserNestedInput
    reactions?: ReactionUpdateManyWithoutUserNestedInput
    mentions?: MentionUpdateManyWithoutUserNestedInput
    choreHistory?: ChoreHistoryUpdateManyWithoutUserNestedInput
    notificationSettings?: NotificationSettingsUpdateManyWithoutUserNestedInput
    calendarEventHistory?: CalendarEventHistoryUpdateManyWithoutUserNestedInput
    expenseHistory?: ExpenseHistoryUpdateManyWithoutUserNestedInput
    messageReads?: MessageReadUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutHouseholdsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    profileImageURL?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deviceTokens?: UserUpdatedeviceTokensInput | string[]
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: MessageUncheckedUpdateManyWithoutAuthorNestedInput
    threads?: ThreadUncheckedUpdateManyWithoutAuthorNestedInput
    assignedChores?: ChoreAssignmentUncheckedUpdateManyWithoutUserNestedInput
    expensesPaid?: ExpenseUncheckedUpdateManyWithoutPaidByNestedInput
    expenseSplits?: ExpenseSplitUncheckedUpdateManyWithoutUserNestedInput
    transactionsFrom?: TransactionUncheckedUpdateManyWithoutFromUserNestedInput
    transactionsTo?: TransactionUncheckedUpdateManyWithoutToUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    oauthIntegrations?: OAuthIntegrationUncheckedUpdateManyWithoutUserNestedInput
    eventsCreated?: EventUncheckedUpdateManyWithoutCreatedByNestedInput
    choreSwapRequestsInitiated?: ChoreSwapRequestUncheckedUpdateManyWithoutRequestingUserNestedInput
    choreSwapRequestsReceived?: ChoreSwapRequestUncheckedUpdateManyWithoutTargetUserNestedInput
    reactions?: ReactionUncheckedUpdateManyWithoutUserNestedInput
    mentions?: MentionUncheckedUpdateManyWithoutUserNestedInput
    choreHistory?: ChoreHistoryUncheckedUpdateManyWithoutUserNestedInput
    notificationSettings?: NotificationSettingsUncheckedUpdateManyWithoutUserNestedInput
    calendarEventHistory?: CalendarEventHistoryUncheckedUpdateManyWithoutUserNestedInput
    expenseHistory?: ExpenseHistoryUncheckedUpdateManyWithoutUserNestedInput
    messageReads?: MessageReadUncheckedUpdateManyWithoutUserNestedInput
  }

  export type HouseholdUpsertWithoutMembersInput = {
    update: XOR<HouseholdUpdateWithoutMembersInput, HouseholdUncheckedUpdateWithoutMembersInput>
    create: XOR<HouseholdCreateWithoutMembersInput, HouseholdUncheckedCreateWithoutMembersInput>
    where?: HouseholdWhereInput
  }

  export type HouseholdUpdateToOneWithWhereWithoutMembersInput = {
    where?: HouseholdWhereInput
    data: XOR<HouseholdUpdateWithoutMembersInput, HouseholdUncheckedUpdateWithoutMembersInput>
  }

  export type HouseholdUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    threads?: ThreadUpdateManyWithoutHouseholdNestedInput
    chores?: ChoreUpdateManyWithoutHouseholdNestedInput
    expenses?: ExpenseUpdateManyWithoutHouseholdNestedInput
    events?: EventUpdateManyWithoutHouseholdNestedInput
    choreTemplates?: ChoreTemplateUpdateManyWithoutHouseholdNestedInput
    notificationSettings?: NotificationSettingsUpdateManyWithoutHouseholdNestedInput
  }

  export type HouseholdUncheckedUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    threads?: ThreadUncheckedUpdateManyWithoutHouseholdNestedInput
    chores?: ChoreUncheckedUpdateManyWithoutHouseholdNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutHouseholdNestedInput
    events?: EventUncheckedUpdateManyWithoutHouseholdNestedInput
    choreTemplates?: ChoreTemplateUncheckedUpdateManyWithoutHouseholdNestedInput
    notificationSettings?: NotificationSettingsUncheckedUpdateManyWithoutHouseholdNestedInput
  }

  export type ThreadUpsertWithWhereUniqueWithoutParticipantsInput = {
    where: ThreadWhereUniqueInput
    update: XOR<ThreadUpdateWithoutParticipantsInput, ThreadUncheckedUpdateWithoutParticipantsInput>
    create: XOR<ThreadCreateWithoutParticipantsInput, ThreadUncheckedCreateWithoutParticipantsInput>
  }

  export type ThreadUpdateWithWhereUniqueWithoutParticipantsInput = {
    where: ThreadWhereUniqueInput
    data: XOR<ThreadUpdateWithoutParticipantsInput, ThreadUncheckedUpdateWithoutParticipantsInput>
  }

  export type ThreadUpdateManyWithWhereWithoutParticipantsInput = {
    where: ThreadScalarWhereInput
    data: XOR<ThreadUpdateManyMutationInput, ThreadUncheckedUpdateManyWithoutParticipantsInput>
  }

  export type ChoreCreateWithoutRecurrenceRuleInput = {
    id?: string
    title: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dueDate?: Date | string | null
    status?: $Enums.ChoreStatus
    priority?: number | null
    deletedAt?: Date | string | null
    household: HouseholdCreateNestedOneWithoutChoresInput
    subtasks?: SubtaskCreateNestedManyWithoutChoreInput
    assignedUsers?: ChoreAssignmentCreateNestedManyWithoutChoreInput
    event?: EventCreateNestedOneWithoutChoreInput
    choreSwapRequests?: ChoreSwapRequestCreateNestedManyWithoutChoreInput
    history?: ChoreHistoryCreateNestedManyWithoutChoreInput
  }

  export type ChoreUncheckedCreateWithoutRecurrenceRuleInput = {
    id?: string
    householdId: string
    title: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dueDate?: Date | string | null
    status?: $Enums.ChoreStatus
    priority?: number | null
    eventId?: string | null
    deletedAt?: Date | string | null
    subtasks?: SubtaskUncheckedCreateNestedManyWithoutChoreInput
    assignedUsers?: ChoreAssignmentUncheckedCreateNestedManyWithoutChoreInput
    choreSwapRequests?: ChoreSwapRequestUncheckedCreateNestedManyWithoutChoreInput
    history?: ChoreHistoryUncheckedCreateNestedManyWithoutChoreInput
  }

  export type ChoreCreateOrConnectWithoutRecurrenceRuleInput = {
    where: ChoreWhereUniqueInput
    create: XOR<ChoreCreateWithoutRecurrenceRuleInput, ChoreUncheckedCreateWithoutRecurrenceRuleInput>
  }

  export type ChoreCreateManyRecurrenceRuleInputEnvelope = {
    data: ChoreCreateManyRecurrenceRuleInput | ChoreCreateManyRecurrenceRuleInput[]
    skipDuplicates?: boolean
  }

  export type EventCreateWithoutRecurrenceRuleInput = {
    id?: string
    title: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    choreId?: string | null
    category?: $Enums.EventCategory
    isAllDay?: boolean
    location?: string | null
    isPrivate?: boolean
    status?: $Enums.EventStatus
    deletedAt?: Date | string | null
    reminders?: EventReminderCreateNestedManyWithoutEventInput
    household: HouseholdCreateNestedOneWithoutEventsInput
    createdBy: UserCreateNestedOneWithoutEventsCreatedInput
    chore?: ChoreCreateNestedOneWithoutEventInput
    history?: CalendarEventHistoryCreateNestedManyWithoutEventInput
  }

  export type EventUncheckedCreateWithoutRecurrenceRuleInput = {
    id?: string
    householdId: string
    title: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    choreId?: string | null
    category?: $Enums.EventCategory
    isAllDay?: boolean
    location?: string | null
    isPrivate?: boolean
    status?: $Enums.EventStatus
    deletedAt?: Date | string | null
    reminders?: EventReminderUncheckedCreateNestedManyWithoutEventInput
    chore?: ChoreUncheckedCreateNestedOneWithoutEventInput
    history?: CalendarEventHistoryUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventCreateOrConnectWithoutRecurrenceRuleInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutRecurrenceRuleInput, EventUncheckedCreateWithoutRecurrenceRuleInput>
  }

  export type EventCreateManyRecurrenceRuleInputEnvelope = {
    data: EventCreateManyRecurrenceRuleInput | EventCreateManyRecurrenceRuleInput[]
    skipDuplicates?: boolean
  }

  export type ChoreUpsertWithWhereUniqueWithoutRecurrenceRuleInput = {
    where: ChoreWhereUniqueInput
    update: XOR<ChoreUpdateWithoutRecurrenceRuleInput, ChoreUncheckedUpdateWithoutRecurrenceRuleInput>
    create: XOR<ChoreCreateWithoutRecurrenceRuleInput, ChoreUncheckedCreateWithoutRecurrenceRuleInput>
  }

  export type ChoreUpdateWithWhereUniqueWithoutRecurrenceRuleInput = {
    where: ChoreWhereUniqueInput
    data: XOR<ChoreUpdateWithoutRecurrenceRuleInput, ChoreUncheckedUpdateWithoutRecurrenceRuleInput>
  }

  export type ChoreUpdateManyWithWhereWithoutRecurrenceRuleInput = {
    where: ChoreScalarWhereInput
    data: XOR<ChoreUpdateManyMutationInput, ChoreUncheckedUpdateManyWithoutRecurrenceRuleInput>
  }

  export type EventUpsertWithWhereUniqueWithoutRecurrenceRuleInput = {
    where: EventWhereUniqueInput
    update: XOR<EventUpdateWithoutRecurrenceRuleInput, EventUncheckedUpdateWithoutRecurrenceRuleInput>
    create: XOR<EventCreateWithoutRecurrenceRuleInput, EventUncheckedCreateWithoutRecurrenceRuleInput>
  }

  export type EventUpdateWithWhereUniqueWithoutRecurrenceRuleInput = {
    where: EventWhereUniqueInput
    data: XOR<EventUpdateWithoutRecurrenceRuleInput, EventUncheckedUpdateWithoutRecurrenceRuleInput>
  }

  export type EventUpdateManyWithWhereWithoutRecurrenceRuleInput = {
    where: EventScalarWhereInput
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyWithoutRecurrenceRuleInput>
  }

  export type HouseholdCreateWithoutThreadsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    currency?: string
    icon?: string | null
    timezone?: string
    language?: string
    deletedAt?: Date | string | null
    members?: HouseholdMemberCreateNestedManyWithoutHouseholdInput
    chores?: ChoreCreateNestedManyWithoutHouseholdInput
    expenses?: ExpenseCreateNestedManyWithoutHouseholdInput
    events?: EventCreateNestedManyWithoutHouseholdInput
    choreTemplates?: ChoreTemplateCreateNestedManyWithoutHouseholdInput
    notificationSettings?: NotificationSettingsCreateNestedManyWithoutHouseholdInput
  }

  export type HouseholdUncheckedCreateWithoutThreadsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    currency?: string
    icon?: string | null
    timezone?: string
    language?: string
    deletedAt?: Date | string | null
    members?: HouseholdMemberUncheckedCreateNestedManyWithoutHouseholdInput
    chores?: ChoreUncheckedCreateNestedManyWithoutHouseholdInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutHouseholdInput
    events?: EventUncheckedCreateNestedManyWithoutHouseholdInput
    choreTemplates?: ChoreTemplateUncheckedCreateNestedManyWithoutHouseholdInput
    notificationSettings?: NotificationSettingsUncheckedCreateNestedManyWithoutHouseholdInput
  }

  export type HouseholdCreateOrConnectWithoutThreadsInput = {
    where: HouseholdWhereUniqueInput
    create: XOR<HouseholdCreateWithoutThreadsInput, HouseholdUncheckedCreateWithoutThreadsInput>
  }

  export type UserCreateWithoutThreadsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    name: string
    profileImageURL?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deviceTokens?: UserCreatedeviceTokensInput | string[]
    deletedAt?: Date | string | null
    households?: HouseholdMemberCreateNestedManyWithoutUserInput
    messages?: MessageCreateNestedManyWithoutAuthorInput
    assignedChores?: ChoreAssignmentCreateNestedManyWithoutUserInput
    expensesPaid?: ExpenseCreateNestedManyWithoutPaidByInput
    expenseSplits?: ExpenseSplitCreateNestedManyWithoutUserInput
    transactionsFrom?: TransactionCreateNestedManyWithoutFromUserInput
    transactionsTo?: TransactionCreateNestedManyWithoutToUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    oauthIntegrations?: OAuthIntegrationCreateNestedManyWithoutUserInput
    eventsCreated?: EventCreateNestedManyWithoutCreatedByInput
    choreSwapRequestsInitiated?: ChoreSwapRequestCreateNestedManyWithoutRequestingUserInput
    choreSwapRequestsReceived?: ChoreSwapRequestCreateNestedManyWithoutTargetUserInput
    reactions?: ReactionCreateNestedManyWithoutUserInput
    mentions?: MentionCreateNestedManyWithoutUserInput
    choreHistory?: ChoreHistoryCreateNestedManyWithoutUserInput
    notificationSettings?: NotificationSettingsCreateNestedManyWithoutUserInput
    calendarEventHistory?: CalendarEventHistoryCreateNestedManyWithoutUserInput
    expenseHistory?: ExpenseHistoryCreateNestedManyWithoutUserInput
    messageReads?: MessageReadCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutThreadsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    name: string
    profileImageURL?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deviceTokens?: UserCreatedeviceTokensInput | string[]
    deletedAt?: Date | string | null
    households?: HouseholdMemberUncheckedCreateNestedManyWithoutUserInput
    messages?: MessageUncheckedCreateNestedManyWithoutAuthorInput
    assignedChores?: ChoreAssignmentUncheckedCreateNestedManyWithoutUserInput
    expensesPaid?: ExpenseUncheckedCreateNestedManyWithoutPaidByInput
    expenseSplits?: ExpenseSplitUncheckedCreateNestedManyWithoutUserInput
    transactionsFrom?: TransactionUncheckedCreateNestedManyWithoutFromUserInput
    transactionsTo?: TransactionUncheckedCreateNestedManyWithoutToUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    oauthIntegrations?: OAuthIntegrationUncheckedCreateNestedManyWithoutUserInput
    eventsCreated?: EventUncheckedCreateNestedManyWithoutCreatedByInput
    choreSwapRequestsInitiated?: ChoreSwapRequestUncheckedCreateNestedManyWithoutRequestingUserInput
    choreSwapRequestsReceived?: ChoreSwapRequestUncheckedCreateNestedManyWithoutTargetUserInput
    reactions?: ReactionUncheckedCreateNestedManyWithoutUserInput
    mentions?: MentionUncheckedCreateNestedManyWithoutUserInput
    choreHistory?: ChoreHistoryUncheckedCreateNestedManyWithoutUserInput
    notificationSettings?: NotificationSettingsUncheckedCreateNestedManyWithoutUserInput
    calendarEventHistory?: CalendarEventHistoryUncheckedCreateNestedManyWithoutUserInput
    expenseHistory?: ExpenseHistoryUncheckedCreateNestedManyWithoutUserInput
    messageReads?: MessageReadUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutThreadsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutThreadsInput, UserUncheckedCreateWithoutThreadsInput>
  }

  export type MessageCreateWithoutThreadInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    author: UserCreateNestedOneWithoutMessagesInput
    attachments?: AttachmentCreateNestedManyWithoutMessageInput
    reactions?: ReactionCreateNestedManyWithoutMessageInput
    mentions?: MentionCreateNestedManyWithoutMessageInput
    reads?: MessageReadCreateNestedManyWithoutMessageInput
  }

  export type MessageUncheckedCreateWithoutThreadInput = {
    id?: string
    authorId: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    attachments?: AttachmentUncheckedCreateNestedManyWithoutMessageInput
    reactions?: ReactionUncheckedCreateNestedManyWithoutMessageInput
    mentions?: MentionUncheckedCreateNestedManyWithoutMessageInput
    reads?: MessageReadUncheckedCreateNestedManyWithoutMessageInput
  }

  export type MessageCreateOrConnectWithoutThreadInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutThreadInput, MessageUncheckedCreateWithoutThreadInput>
  }

  export type MessageCreateManyThreadInputEnvelope = {
    data: MessageCreateManyThreadInput | MessageCreateManyThreadInput[]
    skipDuplicates?: boolean
  }

  export type HouseholdMemberCreateWithoutThreadsInput = {
    id?: string
    role?: $Enums.HouseholdRole
    joinedAt?: Date | string
    leftAt?: Date | string | null
    isInvited?: boolean
    isAccepted?: boolean
    isRejected?: boolean
    isSelected?: boolean
    lastAssignedChoreAt?: Date | string | null
    user: UserCreateNestedOneWithoutHouseholdsInput
    household: HouseholdCreateNestedOneWithoutMembersInput
  }

  export type HouseholdMemberUncheckedCreateWithoutThreadsInput = {
    id?: string
    userId: string
    householdId: string
    role?: $Enums.HouseholdRole
    joinedAt?: Date | string
    leftAt?: Date | string | null
    isInvited?: boolean
    isAccepted?: boolean
    isRejected?: boolean
    isSelected?: boolean
    lastAssignedChoreAt?: Date | string | null
  }

  export type HouseholdMemberCreateOrConnectWithoutThreadsInput = {
    where: HouseholdMemberWhereUniqueInput
    create: XOR<HouseholdMemberCreateWithoutThreadsInput, HouseholdMemberUncheckedCreateWithoutThreadsInput>
  }

  export type HouseholdUpsertWithoutThreadsInput = {
    update: XOR<HouseholdUpdateWithoutThreadsInput, HouseholdUncheckedUpdateWithoutThreadsInput>
    create: XOR<HouseholdCreateWithoutThreadsInput, HouseholdUncheckedCreateWithoutThreadsInput>
    where?: HouseholdWhereInput
  }

  export type HouseholdUpdateToOneWithWhereWithoutThreadsInput = {
    where?: HouseholdWhereInput
    data: XOR<HouseholdUpdateWithoutThreadsInput, HouseholdUncheckedUpdateWithoutThreadsInput>
  }

  export type HouseholdUpdateWithoutThreadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    members?: HouseholdMemberUpdateManyWithoutHouseholdNestedInput
    chores?: ChoreUpdateManyWithoutHouseholdNestedInput
    expenses?: ExpenseUpdateManyWithoutHouseholdNestedInput
    events?: EventUpdateManyWithoutHouseholdNestedInput
    choreTemplates?: ChoreTemplateUpdateManyWithoutHouseholdNestedInput
    notificationSettings?: NotificationSettingsUpdateManyWithoutHouseholdNestedInput
  }

  export type HouseholdUncheckedUpdateWithoutThreadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    members?: HouseholdMemberUncheckedUpdateManyWithoutHouseholdNestedInput
    chores?: ChoreUncheckedUpdateManyWithoutHouseholdNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutHouseholdNestedInput
    events?: EventUncheckedUpdateManyWithoutHouseholdNestedInput
    choreTemplates?: ChoreTemplateUncheckedUpdateManyWithoutHouseholdNestedInput
    notificationSettings?: NotificationSettingsUncheckedUpdateManyWithoutHouseholdNestedInput
  }

  export type UserUpsertWithoutThreadsInput = {
    update: XOR<UserUpdateWithoutThreadsInput, UserUncheckedUpdateWithoutThreadsInput>
    create: XOR<UserCreateWithoutThreadsInput, UserUncheckedCreateWithoutThreadsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutThreadsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutThreadsInput, UserUncheckedUpdateWithoutThreadsInput>
  }

  export type UserUpdateWithoutThreadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    profileImageURL?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deviceTokens?: UserUpdatedeviceTokensInput | string[]
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    households?: HouseholdMemberUpdateManyWithoutUserNestedInput
    messages?: MessageUpdateManyWithoutAuthorNestedInput
    assignedChores?: ChoreAssignmentUpdateManyWithoutUserNestedInput
    expensesPaid?: ExpenseUpdateManyWithoutPaidByNestedInput
    expenseSplits?: ExpenseSplitUpdateManyWithoutUserNestedInput
    transactionsFrom?: TransactionUpdateManyWithoutFromUserNestedInput
    transactionsTo?: TransactionUpdateManyWithoutToUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    oauthIntegrations?: OAuthIntegrationUpdateManyWithoutUserNestedInput
    eventsCreated?: EventUpdateManyWithoutCreatedByNestedInput
    choreSwapRequestsInitiated?: ChoreSwapRequestUpdateManyWithoutRequestingUserNestedInput
    choreSwapRequestsReceived?: ChoreSwapRequestUpdateManyWithoutTargetUserNestedInput
    reactions?: ReactionUpdateManyWithoutUserNestedInput
    mentions?: MentionUpdateManyWithoutUserNestedInput
    choreHistory?: ChoreHistoryUpdateManyWithoutUserNestedInput
    notificationSettings?: NotificationSettingsUpdateManyWithoutUserNestedInput
    calendarEventHistory?: CalendarEventHistoryUpdateManyWithoutUserNestedInput
    expenseHistory?: ExpenseHistoryUpdateManyWithoutUserNestedInput
    messageReads?: MessageReadUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutThreadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    profileImageURL?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deviceTokens?: UserUpdatedeviceTokensInput | string[]
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    households?: HouseholdMemberUncheckedUpdateManyWithoutUserNestedInput
    messages?: MessageUncheckedUpdateManyWithoutAuthorNestedInput
    assignedChores?: ChoreAssignmentUncheckedUpdateManyWithoutUserNestedInput
    expensesPaid?: ExpenseUncheckedUpdateManyWithoutPaidByNestedInput
    expenseSplits?: ExpenseSplitUncheckedUpdateManyWithoutUserNestedInput
    transactionsFrom?: TransactionUncheckedUpdateManyWithoutFromUserNestedInput
    transactionsTo?: TransactionUncheckedUpdateManyWithoutToUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    oauthIntegrations?: OAuthIntegrationUncheckedUpdateManyWithoutUserNestedInput
    eventsCreated?: EventUncheckedUpdateManyWithoutCreatedByNestedInput
    choreSwapRequestsInitiated?: ChoreSwapRequestUncheckedUpdateManyWithoutRequestingUserNestedInput
    choreSwapRequestsReceived?: ChoreSwapRequestUncheckedUpdateManyWithoutTargetUserNestedInput
    reactions?: ReactionUncheckedUpdateManyWithoutUserNestedInput
    mentions?: MentionUncheckedUpdateManyWithoutUserNestedInput
    choreHistory?: ChoreHistoryUncheckedUpdateManyWithoutUserNestedInput
    notificationSettings?: NotificationSettingsUncheckedUpdateManyWithoutUserNestedInput
    calendarEventHistory?: CalendarEventHistoryUncheckedUpdateManyWithoutUserNestedInput
    expenseHistory?: ExpenseHistoryUncheckedUpdateManyWithoutUserNestedInput
    messageReads?: MessageReadUncheckedUpdateManyWithoutUserNestedInput
  }

  export type MessageUpsertWithWhereUniqueWithoutThreadInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutThreadInput, MessageUncheckedUpdateWithoutThreadInput>
    create: XOR<MessageCreateWithoutThreadInput, MessageUncheckedCreateWithoutThreadInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutThreadInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutThreadInput, MessageUncheckedUpdateWithoutThreadInput>
  }

  export type MessageUpdateManyWithWhereWithoutThreadInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutThreadInput>
  }

  export type HouseholdMemberUpsertWithWhereUniqueWithoutThreadsInput = {
    where: HouseholdMemberWhereUniqueInput
    update: XOR<HouseholdMemberUpdateWithoutThreadsInput, HouseholdMemberUncheckedUpdateWithoutThreadsInput>
    create: XOR<HouseholdMemberCreateWithoutThreadsInput, HouseholdMemberUncheckedCreateWithoutThreadsInput>
  }

  export type HouseholdMemberUpdateWithWhereUniqueWithoutThreadsInput = {
    where: HouseholdMemberWhereUniqueInput
    data: XOR<HouseholdMemberUpdateWithoutThreadsInput, HouseholdMemberUncheckedUpdateWithoutThreadsInput>
  }

  export type HouseholdMemberUpdateManyWithWhereWithoutThreadsInput = {
    where: HouseholdMemberScalarWhereInput
    data: XOR<HouseholdMemberUpdateManyMutationInput, HouseholdMemberUncheckedUpdateManyWithoutThreadsInput>
  }

  export type ThreadCreateWithoutMessagesInput = {
    id?: string
    title?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    household: HouseholdCreateNestedOneWithoutThreadsInput
    author: UserCreateNestedOneWithoutThreadsInput
    participants?: HouseholdMemberCreateNestedManyWithoutThreadsInput
  }

  export type ThreadUncheckedCreateWithoutMessagesInput = {
    id?: string
    householdId: string
    authorId: string
    title?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    participants?: HouseholdMemberUncheckedCreateNestedManyWithoutThreadsInput
  }

  export type ThreadCreateOrConnectWithoutMessagesInput = {
    where: ThreadWhereUniqueInput
    create: XOR<ThreadCreateWithoutMessagesInput, ThreadUncheckedCreateWithoutMessagesInput>
  }

  export type UserCreateWithoutMessagesInput = {
    id?: string
    email: string
    passwordHash?: string | null
    name: string
    profileImageURL?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deviceTokens?: UserCreatedeviceTokensInput | string[]
    deletedAt?: Date | string | null
    households?: HouseholdMemberCreateNestedManyWithoutUserInput
    threads?: ThreadCreateNestedManyWithoutAuthorInput
    assignedChores?: ChoreAssignmentCreateNestedManyWithoutUserInput
    expensesPaid?: ExpenseCreateNestedManyWithoutPaidByInput
    expenseSplits?: ExpenseSplitCreateNestedManyWithoutUserInput
    transactionsFrom?: TransactionCreateNestedManyWithoutFromUserInput
    transactionsTo?: TransactionCreateNestedManyWithoutToUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    oauthIntegrations?: OAuthIntegrationCreateNestedManyWithoutUserInput
    eventsCreated?: EventCreateNestedManyWithoutCreatedByInput
    choreSwapRequestsInitiated?: ChoreSwapRequestCreateNestedManyWithoutRequestingUserInput
    choreSwapRequestsReceived?: ChoreSwapRequestCreateNestedManyWithoutTargetUserInput
    reactions?: ReactionCreateNestedManyWithoutUserInput
    mentions?: MentionCreateNestedManyWithoutUserInput
    choreHistory?: ChoreHistoryCreateNestedManyWithoutUserInput
    notificationSettings?: NotificationSettingsCreateNestedManyWithoutUserInput
    calendarEventHistory?: CalendarEventHistoryCreateNestedManyWithoutUserInput
    expenseHistory?: ExpenseHistoryCreateNestedManyWithoutUserInput
    messageReads?: MessageReadCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMessagesInput = {
    id?: string
    email: string
    passwordHash?: string | null
    name: string
    profileImageURL?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deviceTokens?: UserCreatedeviceTokensInput | string[]
    deletedAt?: Date | string | null
    households?: HouseholdMemberUncheckedCreateNestedManyWithoutUserInput
    threads?: ThreadUncheckedCreateNestedManyWithoutAuthorInput
    assignedChores?: ChoreAssignmentUncheckedCreateNestedManyWithoutUserInput
    expensesPaid?: ExpenseUncheckedCreateNestedManyWithoutPaidByInput
    expenseSplits?: ExpenseSplitUncheckedCreateNestedManyWithoutUserInput
    transactionsFrom?: TransactionUncheckedCreateNestedManyWithoutFromUserInput
    transactionsTo?: TransactionUncheckedCreateNestedManyWithoutToUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    oauthIntegrations?: OAuthIntegrationUncheckedCreateNestedManyWithoutUserInput
    eventsCreated?: EventUncheckedCreateNestedManyWithoutCreatedByInput
    choreSwapRequestsInitiated?: ChoreSwapRequestUncheckedCreateNestedManyWithoutRequestingUserInput
    choreSwapRequestsReceived?: ChoreSwapRequestUncheckedCreateNestedManyWithoutTargetUserInput
    reactions?: ReactionUncheckedCreateNestedManyWithoutUserInput
    mentions?: MentionUncheckedCreateNestedManyWithoutUserInput
    choreHistory?: ChoreHistoryUncheckedCreateNestedManyWithoutUserInput
    notificationSettings?: NotificationSettingsUncheckedCreateNestedManyWithoutUserInput
    calendarEventHistory?: CalendarEventHistoryUncheckedCreateNestedManyWithoutUserInput
    expenseHistory?: ExpenseHistoryUncheckedCreateNestedManyWithoutUserInput
    messageReads?: MessageReadUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMessagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMessagesInput, UserUncheckedCreateWithoutMessagesInput>
  }

  export type AttachmentCreateWithoutMessageInput = {
    id?: string
    url: string
    fileType: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type AttachmentUncheckedCreateWithoutMessageInput = {
    id?: string
    url: string
    fileType: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type AttachmentCreateOrConnectWithoutMessageInput = {
    where: AttachmentWhereUniqueInput
    create: XOR<AttachmentCreateWithoutMessageInput, AttachmentUncheckedCreateWithoutMessageInput>
  }

  export type AttachmentCreateManyMessageInputEnvelope = {
    data: AttachmentCreateManyMessageInput | AttachmentCreateManyMessageInput[]
    skipDuplicates?: boolean
  }

  export type ReactionCreateWithoutMessageInput = {
    id?: string
    emoji: string
    type: $Enums.ReactionType
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutReactionsInput
  }

  export type ReactionUncheckedCreateWithoutMessageInput = {
    id?: string
    userId: string
    emoji: string
    type: $Enums.ReactionType
    createdAt?: Date | string
  }

  export type ReactionCreateOrConnectWithoutMessageInput = {
    where: ReactionWhereUniqueInput
    create: XOR<ReactionCreateWithoutMessageInput, ReactionUncheckedCreateWithoutMessageInput>
  }

  export type ReactionCreateManyMessageInputEnvelope = {
    data: ReactionCreateManyMessageInput | ReactionCreateManyMessageInput[]
    skipDuplicates?: boolean
  }

  export type MentionCreateWithoutMessageInput = {
    id?: string
    mentionedAt?: Date | string
    user: UserCreateNestedOneWithoutMentionsInput
  }

  export type MentionUncheckedCreateWithoutMessageInput = {
    id?: string
    userId: string
    mentionedAt?: Date | string
  }

  export type MentionCreateOrConnectWithoutMessageInput = {
    where: MentionWhereUniqueInput
    create: XOR<MentionCreateWithoutMessageInput, MentionUncheckedCreateWithoutMessageInput>
  }

  export type MentionCreateManyMessageInputEnvelope = {
    data: MentionCreateManyMessageInput | MentionCreateManyMessageInput[]
    skipDuplicates?: boolean
  }

  export type MessageReadCreateWithoutMessageInput = {
    id?: string
    readAt?: Date | string
    user: UserCreateNestedOneWithoutMessageReadsInput
  }

  export type MessageReadUncheckedCreateWithoutMessageInput = {
    id?: string
    userId: string
    readAt?: Date | string
  }

  export type MessageReadCreateOrConnectWithoutMessageInput = {
    where: MessageReadWhereUniqueInput
    create: XOR<MessageReadCreateWithoutMessageInput, MessageReadUncheckedCreateWithoutMessageInput>
  }

  export type MessageReadCreateManyMessageInputEnvelope = {
    data: MessageReadCreateManyMessageInput | MessageReadCreateManyMessageInput[]
    skipDuplicates?: boolean
  }

  export type ThreadUpsertWithoutMessagesInput = {
    update: XOR<ThreadUpdateWithoutMessagesInput, ThreadUncheckedUpdateWithoutMessagesInput>
    create: XOR<ThreadCreateWithoutMessagesInput, ThreadUncheckedCreateWithoutMessagesInput>
    where?: ThreadWhereInput
  }

  export type ThreadUpdateToOneWithWhereWithoutMessagesInput = {
    where?: ThreadWhereInput
    data: XOR<ThreadUpdateWithoutMessagesInput, ThreadUncheckedUpdateWithoutMessagesInput>
  }

  export type ThreadUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    household?: HouseholdUpdateOneRequiredWithoutThreadsNestedInput
    author?: UserUpdateOneRequiredWithoutThreadsNestedInput
    participants?: HouseholdMemberUpdateManyWithoutThreadsNestedInput
  }

  export type ThreadUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    participants?: HouseholdMemberUncheckedUpdateManyWithoutThreadsNestedInput
  }

  export type UserUpsertWithoutMessagesInput = {
    update: XOR<UserUpdateWithoutMessagesInput, UserUncheckedUpdateWithoutMessagesInput>
    create: XOR<UserCreateWithoutMessagesInput, UserUncheckedCreateWithoutMessagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMessagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMessagesInput, UserUncheckedUpdateWithoutMessagesInput>
  }

  export type UserUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    profileImageURL?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deviceTokens?: UserUpdatedeviceTokensInput | string[]
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    households?: HouseholdMemberUpdateManyWithoutUserNestedInput
    threads?: ThreadUpdateManyWithoutAuthorNestedInput
    assignedChores?: ChoreAssignmentUpdateManyWithoutUserNestedInput
    expensesPaid?: ExpenseUpdateManyWithoutPaidByNestedInput
    expenseSplits?: ExpenseSplitUpdateManyWithoutUserNestedInput
    transactionsFrom?: TransactionUpdateManyWithoutFromUserNestedInput
    transactionsTo?: TransactionUpdateManyWithoutToUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    oauthIntegrations?: OAuthIntegrationUpdateManyWithoutUserNestedInput
    eventsCreated?: EventUpdateManyWithoutCreatedByNestedInput
    choreSwapRequestsInitiated?: ChoreSwapRequestUpdateManyWithoutRequestingUserNestedInput
    choreSwapRequestsReceived?: ChoreSwapRequestUpdateManyWithoutTargetUserNestedInput
    reactions?: ReactionUpdateManyWithoutUserNestedInput
    mentions?: MentionUpdateManyWithoutUserNestedInput
    choreHistory?: ChoreHistoryUpdateManyWithoutUserNestedInput
    notificationSettings?: NotificationSettingsUpdateManyWithoutUserNestedInput
    calendarEventHistory?: CalendarEventHistoryUpdateManyWithoutUserNestedInput
    expenseHistory?: ExpenseHistoryUpdateManyWithoutUserNestedInput
    messageReads?: MessageReadUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    profileImageURL?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deviceTokens?: UserUpdatedeviceTokensInput | string[]
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    households?: HouseholdMemberUncheckedUpdateManyWithoutUserNestedInput
    threads?: ThreadUncheckedUpdateManyWithoutAuthorNestedInput
    assignedChores?: ChoreAssignmentUncheckedUpdateManyWithoutUserNestedInput
    expensesPaid?: ExpenseUncheckedUpdateManyWithoutPaidByNestedInput
    expenseSplits?: ExpenseSplitUncheckedUpdateManyWithoutUserNestedInput
    transactionsFrom?: TransactionUncheckedUpdateManyWithoutFromUserNestedInput
    transactionsTo?: TransactionUncheckedUpdateManyWithoutToUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    oauthIntegrations?: OAuthIntegrationUncheckedUpdateManyWithoutUserNestedInput
    eventsCreated?: EventUncheckedUpdateManyWithoutCreatedByNestedInput
    choreSwapRequestsInitiated?: ChoreSwapRequestUncheckedUpdateManyWithoutRequestingUserNestedInput
    choreSwapRequestsReceived?: ChoreSwapRequestUncheckedUpdateManyWithoutTargetUserNestedInput
    reactions?: ReactionUncheckedUpdateManyWithoutUserNestedInput
    mentions?: MentionUncheckedUpdateManyWithoutUserNestedInput
    choreHistory?: ChoreHistoryUncheckedUpdateManyWithoutUserNestedInput
    notificationSettings?: NotificationSettingsUncheckedUpdateManyWithoutUserNestedInput
    calendarEventHistory?: CalendarEventHistoryUncheckedUpdateManyWithoutUserNestedInput
    expenseHistory?: ExpenseHistoryUncheckedUpdateManyWithoutUserNestedInput
    messageReads?: MessageReadUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AttachmentUpsertWithWhereUniqueWithoutMessageInput = {
    where: AttachmentWhereUniqueInput
    update: XOR<AttachmentUpdateWithoutMessageInput, AttachmentUncheckedUpdateWithoutMessageInput>
    create: XOR<AttachmentCreateWithoutMessageInput, AttachmentUncheckedCreateWithoutMessageInput>
  }

  export type AttachmentUpdateWithWhereUniqueWithoutMessageInput = {
    where: AttachmentWhereUniqueInput
    data: XOR<AttachmentUpdateWithoutMessageInput, AttachmentUncheckedUpdateWithoutMessageInput>
  }

  export type AttachmentUpdateManyWithWhereWithoutMessageInput = {
    where: AttachmentScalarWhereInput
    data: XOR<AttachmentUpdateManyMutationInput, AttachmentUncheckedUpdateManyWithoutMessageInput>
  }

  export type AttachmentScalarWhereInput = {
    AND?: AttachmentScalarWhereInput | AttachmentScalarWhereInput[]
    OR?: AttachmentScalarWhereInput[]
    NOT?: AttachmentScalarWhereInput | AttachmentScalarWhereInput[]
    id?: StringFilter<"Attachment"> | string
    messageId?: StringFilter<"Attachment"> | string
    url?: StringFilter<"Attachment"> | string
    fileType?: StringFilter<"Attachment"> | string
    createdAt?: DateTimeFilter<"Attachment"> | Date | string
    updatedAt?: DateTimeFilter<"Attachment"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Attachment"> | Date | string | null
  }

  export type ReactionUpsertWithWhereUniqueWithoutMessageInput = {
    where: ReactionWhereUniqueInput
    update: XOR<ReactionUpdateWithoutMessageInput, ReactionUncheckedUpdateWithoutMessageInput>
    create: XOR<ReactionCreateWithoutMessageInput, ReactionUncheckedCreateWithoutMessageInput>
  }

  export type ReactionUpdateWithWhereUniqueWithoutMessageInput = {
    where: ReactionWhereUniqueInput
    data: XOR<ReactionUpdateWithoutMessageInput, ReactionUncheckedUpdateWithoutMessageInput>
  }

  export type ReactionUpdateManyWithWhereWithoutMessageInput = {
    where: ReactionScalarWhereInput
    data: XOR<ReactionUpdateManyMutationInput, ReactionUncheckedUpdateManyWithoutMessageInput>
  }

  export type MentionUpsertWithWhereUniqueWithoutMessageInput = {
    where: MentionWhereUniqueInput
    update: XOR<MentionUpdateWithoutMessageInput, MentionUncheckedUpdateWithoutMessageInput>
    create: XOR<MentionCreateWithoutMessageInput, MentionUncheckedCreateWithoutMessageInput>
  }

  export type MentionUpdateWithWhereUniqueWithoutMessageInput = {
    where: MentionWhereUniqueInput
    data: XOR<MentionUpdateWithoutMessageInput, MentionUncheckedUpdateWithoutMessageInput>
  }

  export type MentionUpdateManyWithWhereWithoutMessageInput = {
    where: MentionScalarWhereInput
    data: XOR<MentionUpdateManyMutationInput, MentionUncheckedUpdateManyWithoutMessageInput>
  }

  export type MessageReadUpsertWithWhereUniqueWithoutMessageInput = {
    where: MessageReadWhereUniqueInput
    update: XOR<MessageReadUpdateWithoutMessageInput, MessageReadUncheckedUpdateWithoutMessageInput>
    create: XOR<MessageReadCreateWithoutMessageInput, MessageReadUncheckedCreateWithoutMessageInput>
  }

  export type MessageReadUpdateWithWhereUniqueWithoutMessageInput = {
    where: MessageReadWhereUniqueInput
    data: XOR<MessageReadUpdateWithoutMessageInput, MessageReadUncheckedUpdateWithoutMessageInput>
  }

  export type MessageReadUpdateManyWithWhereWithoutMessageInput = {
    where: MessageReadScalarWhereInput
    data: XOR<MessageReadUpdateManyMutationInput, MessageReadUncheckedUpdateManyWithoutMessageInput>
  }

  export type MessageCreateWithoutReactionsInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    thread: ThreadCreateNestedOneWithoutMessagesInput
    author: UserCreateNestedOneWithoutMessagesInput
    attachments?: AttachmentCreateNestedManyWithoutMessageInput
    mentions?: MentionCreateNestedManyWithoutMessageInput
    reads?: MessageReadCreateNestedManyWithoutMessageInput
  }

  export type MessageUncheckedCreateWithoutReactionsInput = {
    id?: string
    threadId: string
    authorId: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    attachments?: AttachmentUncheckedCreateNestedManyWithoutMessageInput
    mentions?: MentionUncheckedCreateNestedManyWithoutMessageInput
    reads?: MessageReadUncheckedCreateNestedManyWithoutMessageInput
  }

  export type MessageCreateOrConnectWithoutReactionsInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutReactionsInput, MessageUncheckedCreateWithoutReactionsInput>
  }

  export type UserCreateWithoutReactionsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    name: string
    profileImageURL?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deviceTokens?: UserCreatedeviceTokensInput | string[]
    deletedAt?: Date | string | null
    households?: HouseholdMemberCreateNestedManyWithoutUserInput
    messages?: MessageCreateNestedManyWithoutAuthorInput
    threads?: ThreadCreateNestedManyWithoutAuthorInput
    assignedChores?: ChoreAssignmentCreateNestedManyWithoutUserInput
    expensesPaid?: ExpenseCreateNestedManyWithoutPaidByInput
    expenseSplits?: ExpenseSplitCreateNestedManyWithoutUserInput
    transactionsFrom?: TransactionCreateNestedManyWithoutFromUserInput
    transactionsTo?: TransactionCreateNestedManyWithoutToUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    oauthIntegrations?: OAuthIntegrationCreateNestedManyWithoutUserInput
    eventsCreated?: EventCreateNestedManyWithoutCreatedByInput
    choreSwapRequestsInitiated?: ChoreSwapRequestCreateNestedManyWithoutRequestingUserInput
    choreSwapRequestsReceived?: ChoreSwapRequestCreateNestedManyWithoutTargetUserInput
    mentions?: MentionCreateNestedManyWithoutUserInput
    choreHistory?: ChoreHistoryCreateNestedManyWithoutUserInput
    notificationSettings?: NotificationSettingsCreateNestedManyWithoutUserInput
    calendarEventHistory?: CalendarEventHistoryCreateNestedManyWithoutUserInput
    expenseHistory?: ExpenseHistoryCreateNestedManyWithoutUserInput
    messageReads?: MessageReadCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReactionsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    name: string
    profileImageURL?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deviceTokens?: UserCreatedeviceTokensInput | string[]
    deletedAt?: Date | string | null
    households?: HouseholdMemberUncheckedCreateNestedManyWithoutUserInput
    messages?: MessageUncheckedCreateNestedManyWithoutAuthorInput
    threads?: ThreadUncheckedCreateNestedManyWithoutAuthorInput
    assignedChores?: ChoreAssignmentUncheckedCreateNestedManyWithoutUserInput
    expensesPaid?: ExpenseUncheckedCreateNestedManyWithoutPaidByInput
    expenseSplits?: ExpenseSplitUncheckedCreateNestedManyWithoutUserInput
    transactionsFrom?: TransactionUncheckedCreateNestedManyWithoutFromUserInput
    transactionsTo?: TransactionUncheckedCreateNestedManyWithoutToUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    oauthIntegrations?: OAuthIntegrationUncheckedCreateNestedManyWithoutUserInput
    eventsCreated?: EventUncheckedCreateNestedManyWithoutCreatedByInput
    choreSwapRequestsInitiated?: ChoreSwapRequestUncheckedCreateNestedManyWithoutRequestingUserInput
    choreSwapRequestsReceived?: ChoreSwapRequestUncheckedCreateNestedManyWithoutTargetUserInput
    mentions?: MentionUncheckedCreateNestedManyWithoutUserInput
    choreHistory?: ChoreHistoryUncheckedCreateNestedManyWithoutUserInput
    notificationSettings?: NotificationSettingsUncheckedCreateNestedManyWithoutUserInput
    calendarEventHistory?: CalendarEventHistoryUncheckedCreateNestedManyWithoutUserInput
    expenseHistory?: ExpenseHistoryUncheckedCreateNestedManyWithoutUserInput
    messageReads?: MessageReadUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReactionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReactionsInput, UserUncheckedCreateWithoutReactionsInput>
  }

  export type MessageUpsertWithoutReactionsInput = {
    update: XOR<MessageUpdateWithoutReactionsInput, MessageUncheckedUpdateWithoutReactionsInput>
    create: XOR<MessageCreateWithoutReactionsInput, MessageUncheckedCreateWithoutReactionsInput>
    where?: MessageWhereInput
  }

  export type MessageUpdateToOneWithWhereWithoutReactionsInput = {
    where?: MessageWhereInput
    data: XOR<MessageUpdateWithoutReactionsInput, MessageUncheckedUpdateWithoutReactionsInput>
  }

  export type MessageUpdateWithoutReactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    thread?: ThreadUpdateOneRequiredWithoutMessagesNestedInput
    author?: UserUpdateOneRequiredWithoutMessagesNestedInput
    attachments?: AttachmentUpdateManyWithoutMessageNestedInput
    mentions?: MentionUpdateManyWithoutMessageNestedInput
    reads?: MessageReadUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateWithoutReactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    threadId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attachments?: AttachmentUncheckedUpdateManyWithoutMessageNestedInput
    mentions?: MentionUncheckedUpdateManyWithoutMessageNestedInput
    reads?: MessageReadUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type UserUpsertWithoutReactionsInput = {
    update: XOR<UserUpdateWithoutReactionsInput, UserUncheckedUpdateWithoutReactionsInput>
    create: XOR<UserCreateWithoutReactionsInput, UserUncheckedCreateWithoutReactionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReactionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReactionsInput, UserUncheckedUpdateWithoutReactionsInput>
  }

  export type UserUpdateWithoutReactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    profileImageURL?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deviceTokens?: UserUpdatedeviceTokensInput | string[]
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    households?: HouseholdMemberUpdateManyWithoutUserNestedInput
    messages?: MessageUpdateManyWithoutAuthorNestedInput
    threads?: ThreadUpdateManyWithoutAuthorNestedInput
    assignedChores?: ChoreAssignmentUpdateManyWithoutUserNestedInput
    expensesPaid?: ExpenseUpdateManyWithoutPaidByNestedInput
    expenseSplits?: ExpenseSplitUpdateManyWithoutUserNestedInput
    transactionsFrom?: TransactionUpdateManyWithoutFromUserNestedInput
    transactionsTo?: TransactionUpdateManyWithoutToUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    oauthIntegrations?: OAuthIntegrationUpdateManyWithoutUserNestedInput
    eventsCreated?: EventUpdateManyWithoutCreatedByNestedInput
    choreSwapRequestsInitiated?: ChoreSwapRequestUpdateManyWithoutRequestingUserNestedInput
    choreSwapRequestsReceived?: ChoreSwapRequestUpdateManyWithoutTargetUserNestedInput
    mentions?: MentionUpdateManyWithoutUserNestedInput
    choreHistory?: ChoreHistoryUpdateManyWithoutUserNestedInput
    notificationSettings?: NotificationSettingsUpdateManyWithoutUserNestedInput
    calendarEventHistory?: CalendarEventHistoryUpdateManyWithoutUserNestedInput
    expenseHistory?: ExpenseHistoryUpdateManyWithoutUserNestedInput
    messageReads?: MessageReadUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    profileImageURL?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deviceTokens?: UserUpdatedeviceTokensInput | string[]
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    households?: HouseholdMemberUncheckedUpdateManyWithoutUserNestedInput
    messages?: MessageUncheckedUpdateManyWithoutAuthorNestedInput
    threads?: ThreadUncheckedUpdateManyWithoutAuthorNestedInput
    assignedChores?: ChoreAssignmentUncheckedUpdateManyWithoutUserNestedInput
    expensesPaid?: ExpenseUncheckedUpdateManyWithoutPaidByNestedInput
    expenseSplits?: ExpenseSplitUncheckedUpdateManyWithoutUserNestedInput
    transactionsFrom?: TransactionUncheckedUpdateManyWithoutFromUserNestedInput
    transactionsTo?: TransactionUncheckedUpdateManyWithoutToUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    oauthIntegrations?: OAuthIntegrationUncheckedUpdateManyWithoutUserNestedInput
    eventsCreated?: EventUncheckedUpdateManyWithoutCreatedByNestedInput
    choreSwapRequestsInitiated?: ChoreSwapRequestUncheckedUpdateManyWithoutRequestingUserNestedInput
    choreSwapRequestsReceived?: ChoreSwapRequestUncheckedUpdateManyWithoutTargetUserNestedInput
    mentions?: MentionUncheckedUpdateManyWithoutUserNestedInput
    choreHistory?: ChoreHistoryUncheckedUpdateManyWithoutUserNestedInput
    notificationSettings?: NotificationSettingsUncheckedUpdateManyWithoutUserNestedInput
    calendarEventHistory?: CalendarEventHistoryUncheckedUpdateManyWithoutUserNestedInput
    expenseHistory?: ExpenseHistoryUncheckedUpdateManyWithoutUserNestedInput
    messageReads?: MessageReadUncheckedUpdateManyWithoutUserNestedInput
  }

  export type MessageCreateWithoutMentionsInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    thread: ThreadCreateNestedOneWithoutMessagesInput
    author: UserCreateNestedOneWithoutMessagesInput
    attachments?: AttachmentCreateNestedManyWithoutMessageInput
    reactions?: ReactionCreateNestedManyWithoutMessageInput
    reads?: MessageReadCreateNestedManyWithoutMessageInput
  }

  export type MessageUncheckedCreateWithoutMentionsInput = {
    id?: string
    threadId: string
    authorId: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    attachments?: AttachmentUncheckedCreateNestedManyWithoutMessageInput
    reactions?: ReactionUncheckedCreateNestedManyWithoutMessageInput
    reads?: MessageReadUncheckedCreateNestedManyWithoutMessageInput
  }

  export type MessageCreateOrConnectWithoutMentionsInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutMentionsInput, MessageUncheckedCreateWithoutMentionsInput>
  }

  export type UserCreateWithoutMentionsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    name: string
    profileImageURL?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deviceTokens?: UserCreatedeviceTokensInput | string[]
    deletedAt?: Date | string | null
    households?: HouseholdMemberCreateNestedManyWithoutUserInput
    messages?: MessageCreateNestedManyWithoutAuthorInput
    threads?: ThreadCreateNestedManyWithoutAuthorInput
    assignedChores?: ChoreAssignmentCreateNestedManyWithoutUserInput
    expensesPaid?: ExpenseCreateNestedManyWithoutPaidByInput
    expenseSplits?: ExpenseSplitCreateNestedManyWithoutUserInput
    transactionsFrom?: TransactionCreateNestedManyWithoutFromUserInput
    transactionsTo?: TransactionCreateNestedManyWithoutToUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    oauthIntegrations?: OAuthIntegrationCreateNestedManyWithoutUserInput
    eventsCreated?: EventCreateNestedManyWithoutCreatedByInput
    choreSwapRequestsInitiated?: ChoreSwapRequestCreateNestedManyWithoutRequestingUserInput
    choreSwapRequestsReceived?: ChoreSwapRequestCreateNestedManyWithoutTargetUserInput
    reactions?: ReactionCreateNestedManyWithoutUserInput
    choreHistory?: ChoreHistoryCreateNestedManyWithoutUserInput
    notificationSettings?: NotificationSettingsCreateNestedManyWithoutUserInput
    calendarEventHistory?: CalendarEventHistoryCreateNestedManyWithoutUserInput
    expenseHistory?: ExpenseHistoryCreateNestedManyWithoutUserInput
    messageReads?: MessageReadCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMentionsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    name: string
    profileImageURL?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deviceTokens?: UserCreatedeviceTokensInput | string[]
    deletedAt?: Date | string | null
    households?: HouseholdMemberUncheckedCreateNestedManyWithoutUserInput
    messages?: MessageUncheckedCreateNestedManyWithoutAuthorInput
    threads?: ThreadUncheckedCreateNestedManyWithoutAuthorInput
    assignedChores?: ChoreAssignmentUncheckedCreateNestedManyWithoutUserInput
    expensesPaid?: ExpenseUncheckedCreateNestedManyWithoutPaidByInput
    expenseSplits?: ExpenseSplitUncheckedCreateNestedManyWithoutUserInput
    transactionsFrom?: TransactionUncheckedCreateNestedManyWithoutFromUserInput
    transactionsTo?: TransactionUncheckedCreateNestedManyWithoutToUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    oauthIntegrations?: OAuthIntegrationUncheckedCreateNestedManyWithoutUserInput
    eventsCreated?: EventUncheckedCreateNestedManyWithoutCreatedByInput
    choreSwapRequestsInitiated?: ChoreSwapRequestUncheckedCreateNestedManyWithoutRequestingUserInput
    choreSwapRequestsReceived?: ChoreSwapRequestUncheckedCreateNestedManyWithoutTargetUserInput
    reactions?: ReactionUncheckedCreateNestedManyWithoutUserInput
    choreHistory?: ChoreHistoryUncheckedCreateNestedManyWithoutUserInput
    notificationSettings?: NotificationSettingsUncheckedCreateNestedManyWithoutUserInput
    calendarEventHistory?: CalendarEventHistoryUncheckedCreateNestedManyWithoutUserInput
    expenseHistory?: ExpenseHistoryUncheckedCreateNestedManyWithoutUserInput
    messageReads?: MessageReadUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMentionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMentionsInput, UserUncheckedCreateWithoutMentionsInput>
  }

  export type MessageUpsertWithoutMentionsInput = {
    update: XOR<MessageUpdateWithoutMentionsInput, MessageUncheckedUpdateWithoutMentionsInput>
    create: XOR<MessageCreateWithoutMentionsInput, MessageUncheckedCreateWithoutMentionsInput>
    where?: MessageWhereInput
  }

  export type MessageUpdateToOneWithWhereWithoutMentionsInput = {
    where?: MessageWhereInput
    data: XOR<MessageUpdateWithoutMentionsInput, MessageUncheckedUpdateWithoutMentionsInput>
  }

  export type MessageUpdateWithoutMentionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    thread?: ThreadUpdateOneRequiredWithoutMessagesNestedInput
    author?: UserUpdateOneRequiredWithoutMessagesNestedInput
    attachments?: AttachmentUpdateManyWithoutMessageNestedInput
    reactions?: ReactionUpdateManyWithoutMessageNestedInput
    reads?: MessageReadUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateWithoutMentionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    threadId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attachments?: AttachmentUncheckedUpdateManyWithoutMessageNestedInput
    reactions?: ReactionUncheckedUpdateManyWithoutMessageNestedInput
    reads?: MessageReadUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type UserUpsertWithoutMentionsInput = {
    update: XOR<UserUpdateWithoutMentionsInput, UserUncheckedUpdateWithoutMentionsInput>
    create: XOR<UserCreateWithoutMentionsInput, UserUncheckedCreateWithoutMentionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMentionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMentionsInput, UserUncheckedUpdateWithoutMentionsInput>
  }

  export type UserUpdateWithoutMentionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    profileImageURL?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deviceTokens?: UserUpdatedeviceTokensInput | string[]
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    households?: HouseholdMemberUpdateManyWithoutUserNestedInput
    messages?: MessageUpdateManyWithoutAuthorNestedInput
    threads?: ThreadUpdateManyWithoutAuthorNestedInput
    assignedChores?: ChoreAssignmentUpdateManyWithoutUserNestedInput
    expensesPaid?: ExpenseUpdateManyWithoutPaidByNestedInput
    expenseSplits?: ExpenseSplitUpdateManyWithoutUserNestedInput
    transactionsFrom?: TransactionUpdateManyWithoutFromUserNestedInput
    transactionsTo?: TransactionUpdateManyWithoutToUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    oauthIntegrations?: OAuthIntegrationUpdateManyWithoutUserNestedInput
    eventsCreated?: EventUpdateManyWithoutCreatedByNestedInput
    choreSwapRequestsInitiated?: ChoreSwapRequestUpdateManyWithoutRequestingUserNestedInput
    choreSwapRequestsReceived?: ChoreSwapRequestUpdateManyWithoutTargetUserNestedInput
    reactions?: ReactionUpdateManyWithoutUserNestedInput
    choreHistory?: ChoreHistoryUpdateManyWithoutUserNestedInput
    notificationSettings?: NotificationSettingsUpdateManyWithoutUserNestedInput
    calendarEventHistory?: CalendarEventHistoryUpdateManyWithoutUserNestedInput
    expenseHistory?: ExpenseHistoryUpdateManyWithoutUserNestedInput
    messageReads?: MessageReadUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMentionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    profileImageURL?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deviceTokens?: UserUpdatedeviceTokensInput | string[]
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    households?: HouseholdMemberUncheckedUpdateManyWithoutUserNestedInput
    messages?: MessageUncheckedUpdateManyWithoutAuthorNestedInput
    threads?: ThreadUncheckedUpdateManyWithoutAuthorNestedInput
    assignedChores?: ChoreAssignmentUncheckedUpdateManyWithoutUserNestedInput
    expensesPaid?: ExpenseUncheckedUpdateManyWithoutPaidByNestedInput
    expenseSplits?: ExpenseSplitUncheckedUpdateManyWithoutUserNestedInput
    transactionsFrom?: TransactionUncheckedUpdateManyWithoutFromUserNestedInput
    transactionsTo?: TransactionUncheckedUpdateManyWithoutToUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    oauthIntegrations?: OAuthIntegrationUncheckedUpdateManyWithoutUserNestedInput
    eventsCreated?: EventUncheckedUpdateManyWithoutCreatedByNestedInput
    choreSwapRequestsInitiated?: ChoreSwapRequestUncheckedUpdateManyWithoutRequestingUserNestedInput
    choreSwapRequestsReceived?: ChoreSwapRequestUncheckedUpdateManyWithoutTargetUserNestedInput
    reactions?: ReactionUncheckedUpdateManyWithoutUserNestedInput
    choreHistory?: ChoreHistoryUncheckedUpdateManyWithoutUserNestedInput
    notificationSettings?: NotificationSettingsUncheckedUpdateManyWithoutUserNestedInput
    calendarEventHistory?: CalendarEventHistoryUncheckedUpdateManyWithoutUserNestedInput
    expenseHistory?: ExpenseHistoryUncheckedUpdateManyWithoutUserNestedInput
    messageReads?: MessageReadUncheckedUpdateManyWithoutUserNestedInput
  }

  export type MessageCreateWithoutAttachmentsInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    thread: ThreadCreateNestedOneWithoutMessagesInput
    author: UserCreateNestedOneWithoutMessagesInput
    reactions?: ReactionCreateNestedManyWithoutMessageInput
    mentions?: MentionCreateNestedManyWithoutMessageInput
    reads?: MessageReadCreateNestedManyWithoutMessageInput
  }

  export type MessageUncheckedCreateWithoutAttachmentsInput = {
    id?: string
    threadId: string
    authorId: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    reactions?: ReactionUncheckedCreateNestedManyWithoutMessageInput
    mentions?: MentionUncheckedCreateNestedManyWithoutMessageInput
    reads?: MessageReadUncheckedCreateNestedManyWithoutMessageInput
  }

  export type MessageCreateOrConnectWithoutAttachmentsInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutAttachmentsInput, MessageUncheckedCreateWithoutAttachmentsInput>
  }

  export type MessageUpsertWithoutAttachmentsInput = {
    update: XOR<MessageUpdateWithoutAttachmentsInput, MessageUncheckedUpdateWithoutAttachmentsInput>
    create: XOR<MessageCreateWithoutAttachmentsInput, MessageUncheckedCreateWithoutAttachmentsInput>
    where?: MessageWhereInput
  }

  export type MessageUpdateToOneWithWhereWithoutAttachmentsInput = {
    where?: MessageWhereInput
    data: XOR<MessageUpdateWithoutAttachmentsInput, MessageUncheckedUpdateWithoutAttachmentsInput>
  }

  export type MessageUpdateWithoutAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    thread?: ThreadUpdateOneRequiredWithoutMessagesNestedInput
    author?: UserUpdateOneRequiredWithoutMessagesNestedInput
    reactions?: ReactionUpdateManyWithoutMessageNestedInput
    mentions?: MentionUpdateManyWithoutMessageNestedInput
    reads?: MessageReadUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateWithoutAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    threadId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reactions?: ReactionUncheckedUpdateManyWithoutMessageNestedInput
    mentions?: MentionUncheckedUpdateManyWithoutMessageNestedInput
    reads?: MessageReadUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type MessageCreateWithoutReadsInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    thread: ThreadCreateNestedOneWithoutMessagesInput
    author: UserCreateNestedOneWithoutMessagesInput
    attachments?: AttachmentCreateNestedManyWithoutMessageInput
    reactions?: ReactionCreateNestedManyWithoutMessageInput
    mentions?: MentionCreateNestedManyWithoutMessageInput
  }

  export type MessageUncheckedCreateWithoutReadsInput = {
    id?: string
    threadId: string
    authorId: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    attachments?: AttachmentUncheckedCreateNestedManyWithoutMessageInput
    reactions?: ReactionUncheckedCreateNestedManyWithoutMessageInput
    mentions?: MentionUncheckedCreateNestedManyWithoutMessageInput
  }

  export type MessageCreateOrConnectWithoutReadsInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutReadsInput, MessageUncheckedCreateWithoutReadsInput>
  }

  export type UserCreateWithoutMessageReadsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    name: string
    profileImageURL?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deviceTokens?: UserCreatedeviceTokensInput | string[]
    deletedAt?: Date | string | null
    households?: HouseholdMemberCreateNestedManyWithoutUserInput
    messages?: MessageCreateNestedManyWithoutAuthorInput
    threads?: ThreadCreateNestedManyWithoutAuthorInput
    assignedChores?: ChoreAssignmentCreateNestedManyWithoutUserInput
    expensesPaid?: ExpenseCreateNestedManyWithoutPaidByInput
    expenseSplits?: ExpenseSplitCreateNestedManyWithoutUserInput
    transactionsFrom?: TransactionCreateNestedManyWithoutFromUserInput
    transactionsTo?: TransactionCreateNestedManyWithoutToUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    oauthIntegrations?: OAuthIntegrationCreateNestedManyWithoutUserInput
    eventsCreated?: EventCreateNestedManyWithoutCreatedByInput
    choreSwapRequestsInitiated?: ChoreSwapRequestCreateNestedManyWithoutRequestingUserInput
    choreSwapRequestsReceived?: ChoreSwapRequestCreateNestedManyWithoutTargetUserInput
    reactions?: ReactionCreateNestedManyWithoutUserInput
    mentions?: MentionCreateNestedManyWithoutUserInput
    choreHistory?: ChoreHistoryCreateNestedManyWithoutUserInput
    notificationSettings?: NotificationSettingsCreateNestedManyWithoutUserInput
    calendarEventHistory?: CalendarEventHistoryCreateNestedManyWithoutUserInput
    expenseHistory?: ExpenseHistoryCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMessageReadsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    name: string
    profileImageURL?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deviceTokens?: UserCreatedeviceTokensInput | string[]
    deletedAt?: Date | string | null
    households?: HouseholdMemberUncheckedCreateNestedManyWithoutUserInput
    messages?: MessageUncheckedCreateNestedManyWithoutAuthorInput
    threads?: ThreadUncheckedCreateNestedManyWithoutAuthorInput
    assignedChores?: ChoreAssignmentUncheckedCreateNestedManyWithoutUserInput
    expensesPaid?: ExpenseUncheckedCreateNestedManyWithoutPaidByInput
    expenseSplits?: ExpenseSplitUncheckedCreateNestedManyWithoutUserInput
    transactionsFrom?: TransactionUncheckedCreateNestedManyWithoutFromUserInput
    transactionsTo?: TransactionUncheckedCreateNestedManyWithoutToUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    oauthIntegrations?: OAuthIntegrationUncheckedCreateNestedManyWithoutUserInput
    eventsCreated?: EventUncheckedCreateNestedManyWithoutCreatedByInput
    choreSwapRequestsInitiated?: ChoreSwapRequestUncheckedCreateNestedManyWithoutRequestingUserInput
    choreSwapRequestsReceived?: ChoreSwapRequestUncheckedCreateNestedManyWithoutTargetUserInput
    reactions?: ReactionUncheckedCreateNestedManyWithoutUserInput
    mentions?: MentionUncheckedCreateNestedManyWithoutUserInput
    choreHistory?: ChoreHistoryUncheckedCreateNestedManyWithoutUserInput
    notificationSettings?: NotificationSettingsUncheckedCreateNestedManyWithoutUserInput
    calendarEventHistory?: CalendarEventHistoryUncheckedCreateNestedManyWithoutUserInput
    expenseHistory?: ExpenseHistoryUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMessageReadsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMessageReadsInput, UserUncheckedCreateWithoutMessageReadsInput>
  }

  export type MessageUpsertWithoutReadsInput = {
    update: XOR<MessageUpdateWithoutReadsInput, MessageUncheckedUpdateWithoutReadsInput>
    create: XOR<MessageCreateWithoutReadsInput, MessageUncheckedCreateWithoutReadsInput>
    where?: MessageWhereInput
  }

  export type MessageUpdateToOneWithWhereWithoutReadsInput = {
    where?: MessageWhereInput
    data: XOR<MessageUpdateWithoutReadsInput, MessageUncheckedUpdateWithoutReadsInput>
  }

  export type MessageUpdateWithoutReadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    thread?: ThreadUpdateOneRequiredWithoutMessagesNestedInput
    author?: UserUpdateOneRequiredWithoutMessagesNestedInput
    attachments?: AttachmentUpdateManyWithoutMessageNestedInput
    reactions?: ReactionUpdateManyWithoutMessageNestedInput
    mentions?: MentionUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateWithoutReadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    threadId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attachments?: AttachmentUncheckedUpdateManyWithoutMessageNestedInput
    reactions?: ReactionUncheckedUpdateManyWithoutMessageNestedInput
    mentions?: MentionUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type UserUpsertWithoutMessageReadsInput = {
    update: XOR<UserUpdateWithoutMessageReadsInput, UserUncheckedUpdateWithoutMessageReadsInput>
    create: XOR<UserCreateWithoutMessageReadsInput, UserUncheckedCreateWithoutMessageReadsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMessageReadsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMessageReadsInput, UserUncheckedUpdateWithoutMessageReadsInput>
  }

  export type UserUpdateWithoutMessageReadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    profileImageURL?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deviceTokens?: UserUpdatedeviceTokensInput | string[]
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    households?: HouseholdMemberUpdateManyWithoutUserNestedInput
    messages?: MessageUpdateManyWithoutAuthorNestedInput
    threads?: ThreadUpdateManyWithoutAuthorNestedInput
    assignedChores?: ChoreAssignmentUpdateManyWithoutUserNestedInput
    expensesPaid?: ExpenseUpdateManyWithoutPaidByNestedInput
    expenseSplits?: ExpenseSplitUpdateManyWithoutUserNestedInput
    transactionsFrom?: TransactionUpdateManyWithoutFromUserNestedInput
    transactionsTo?: TransactionUpdateManyWithoutToUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    oauthIntegrations?: OAuthIntegrationUpdateManyWithoutUserNestedInput
    eventsCreated?: EventUpdateManyWithoutCreatedByNestedInput
    choreSwapRequestsInitiated?: ChoreSwapRequestUpdateManyWithoutRequestingUserNestedInput
    choreSwapRequestsReceived?: ChoreSwapRequestUpdateManyWithoutTargetUserNestedInput
    reactions?: ReactionUpdateManyWithoutUserNestedInput
    mentions?: MentionUpdateManyWithoutUserNestedInput
    choreHistory?: ChoreHistoryUpdateManyWithoutUserNestedInput
    notificationSettings?: NotificationSettingsUpdateManyWithoutUserNestedInput
    calendarEventHistory?: CalendarEventHistoryUpdateManyWithoutUserNestedInput
    expenseHistory?: ExpenseHistoryUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMessageReadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    profileImageURL?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deviceTokens?: UserUpdatedeviceTokensInput | string[]
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    households?: HouseholdMemberUncheckedUpdateManyWithoutUserNestedInput
    messages?: MessageUncheckedUpdateManyWithoutAuthorNestedInput
    threads?: ThreadUncheckedUpdateManyWithoutAuthorNestedInput
    assignedChores?: ChoreAssignmentUncheckedUpdateManyWithoutUserNestedInput
    expensesPaid?: ExpenseUncheckedUpdateManyWithoutPaidByNestedInput
    expenseSplits?: ExpenseSplitUncheckedUpdateManyWithoutUserNestedInput
    transactionsFrom?: TransactionUncheckedUpdateManyWithoutFromUserNestedInput
    transactionsTo?: TransactionUncheckedUpdateManyWithoutToUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    oauthIntegrations?: OAuthIntegrationUncheckedUpdateManyWithoutUserNestedInput
    eventsCreated?: EventUncheckedUpdateManyWithoutCreatedByNestedInput
    choreSwapRequestsInitiated?: ChoreSwapRequestUncheckedUpdateManyWithoutRequestingUserNestedInput
    choreSwapRequestsReceived?: ChoreSwapRequestUncheckedUpdateManyWithoutTargetUserNestedInput
    reactions?: ReactionUncheckedUpdateManyWithoutUserNestedInput
    mentions?: MentionUncheckedUpdateManyWithoutUserNestedInput
    choreHistory?: ChoreHistoryUncheckedUpdateManyWithoutUserNestedInput
    notificationSettings?: NotificationSettingsUncheckedUpdateManyWithoutUserNestedInput
    calendarEventHistory?: CalendarEventHistoryUncheckedUpdateManyWithoutUserNestedInput
    expenseHistory?: ExpenseHistoryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type HouseholdCreateWithoutChoresInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    currency?: string
    icon?: string | null
    timezone?: string
    language?: string
    deletedAt?: Date | string | null
    members?: HouseholdMemberCreateNestedManyWithoutHouseholdInput
    threads?: ThreadCreateNestedManyWithoutHouseholdInput
    expenses?: ExpenseCreateNestedManyWithoutHouseholdInput
    events?: EventCreateNestedManyWithoutHouseholdInput
    choreTemplates?: ChoreTemplateCreateNestedManyWithoutHouseholdInput
    notificationSettings?: NotificationSettingsCreateNestedManyWithoutHouseholdInput
  }

  export type HouseholdUncheckedCreateWithoutChoresInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    currency?: string
    icon?: string | null
    timezone?: string
    language?: string
    deletedAt?: Date | string | null
    members?: HouseholdMemberUncheckedCreateNestedManyWithoutHouseholdInput
    threads?: ThreadUncheckedCreateNestedManyWithoutHouseholdInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutHouseholdInput
    events?: EventUncheckedCreateNestedManyWithoutHouseholdInput
    choreTemplates?: ChoreTemplateUncheckedCreateNestedManyWithoutHouseholdInput
    notificationSettings?: NotificationSettingsUncheckedCreateNestedManyWithoutHouseholdInput
  }

  export type HouseholdCreateOrConnectWithoutChoresInput = {
    where: HouseholdWhereUniqueInput
    create: XOR<HouseholdCreateWithoutChoresInput, HouseholdUncheckedCreateWithoutChoresInput>
  }

  export type SubtaskCreateWithoutChoreInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.SubtaskStatus
  }

  export type SubtaskUncheckedCreateWithoutChoreInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.SubtaskStatus
  }

  export type SubtaskCreateOrConnectWithoutChoreInput = {
    where: SubtaskWhereUniqueInput
    create: XOR<SubtaskCreateWithoutChoreInput, SubtaskUncheckedCreateWithoutChoreInput>
  }

  export type SubtaskCreateManyChoreInputEnvelope = {
    data: SubtaskCreateManyChoreInput | SubtaskCreateManyChoreInput[]
    skipDuplicates?: boolean
  }

  export type ChoreAssignmentCreateWithoutChoreInput = {
    id?: string
    assignedAt?: Date | string
    completedAt?: Date | string | null
    user: UserCreateNestedOneWithoutAssignedChoresInput
  }

  export type ChoreAssignmentUncheckedCreateWithoutChoreInput = {
    id?: string
    userId: string
    assignedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type ChoreAssignmentCreateOrConnectWithoutChoreInput = {
    where: ChoreAssignmentWhereUniqueInput
    create: XOR<ChoreAssignmentCreateWithoutChoreInput, ChoreAssignmentUncheckedCreateWithoutChoreInput>
  }

  export type ChoreAssignmentCreateManyChoreInputEnvelope = {
    data: ChoreAssignmentCreateManyChoreInput | ChoreAssignmentCreateManyChoreInput[]
    skipDuplicates?: boolean
  }

  export type EventCreateWithoutChoreInput = {
    id?: string
    title: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    choreId?: string | null
    category?: $Enums.EventCategory
    isAllDay?: boolean
    location?: string | null
    isPrivate?: boolean
    status?: $Enums.EventStatus
    deletedAt?: Date | string | null
    reminders?: EventReminderCreateNestedManyWithoutEventInput
    household: HouseholdCreateNestedOneWithoutEventsInput
    createdBy: UserCreateNestedOneWithoutEventsCreatedInput
    recurrenceRule?: RecurrenceRuleCreateNestedOneWithoutEventsInput
    history?: CalendarEventHistoryCreateNestedManyWithoutEventInput
  }

  export type EventUncheckedCreateWithoutChoreInput = {
    id?: string
    householdId: string
    title: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    choreId?: string | null
    recurrenceRuleId?: string | null
    category?: $Enums.EventCategory
    isAllDay?: boolean
    location?: string | null
    isPrivate?: boolean
    status?: $Enums.EventStatus
    deletedAt?: Date | string | null
    reminders?: EventReminderUncheckedCreateNestedManyWithoutEventInput
    history?: CalendarEventHistoryUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventCreateOrConnectWithoutChoreInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutChoreInput, EventUncheckedCreateWithoutChoreInput>
  }

  export type ChoreSwapRequestCreateWithoutChoreInput = {
    id?: string
    status?: $Enums.ChoreSwapRequestStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    requestingUser: UserCreateNestedOneWithoutChoreSwapRequestsInitiatedInput
    targetUser: UserCreateNestedOneWithoutChoreSwapRequestsReceivedInput
  }

  export type ChoreSwapRequestUncheckedCreateWithoutChoreInput = {
    id?: string
    requestingUserId: string
    targetUserId: string
    status?: $Enums.ChoreSwapRequestStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChoreSwapRequestCreateOrConnectWithoutChoreInput = {
    where: ChoreSwapRequestWhereUniqueInput
    create: XOR<ChoreSwapRequestCreateWithoutChoreInput, ChoreSwapRequestUncheckedCreateWithoutChoreInput>
  }

  export type ChoreSwapRequestCreateManyChoreInputEnvelope = {
    data: ChoreSwapRequestCreateManyChoreInput | ChoreSwapRequestCreateManyChoreInput[]
    skipDuplicates?: boolean
  }

  export type RecurrenceRuleCreateWithoutChoresInput = {
    id?: string
    frequency: $Enums.RecurrenceFrequency
    interval?: number
    byWeekDay?: RecurrenceRuleCreatebyWeekDayInput | $Enums.DaysOfWeek[]
    byMonthDay?: RecurrenceRuleCreatebyMonthDayInput | number[]
    bySetPos?: number | null
    count?: number | null
    until?: Date | string | null
    customRuleString?: string | null
    events?: EventCreateNestedManyWithoutRecurrenceRuleInput
  }

  export type RecurrenceRuleUncheckedCreateWithoutChoresInput = {
    id?: string
    frequency: $Enums.RecurrenceFrequency
    interval?: number
    byWeekDay?: RecurrenceRuleCreatebyWeekDayInput | $Enums.DaysOfWeek[]
    byMonthDay?: RecurrenceRuleCreatebyMonthDayInput | number[]
    bySetPos?: number | null
    count?: number | null
    until?: Date | string | null
    customRuleString?: string | null
    events?: EventUncheckedCreateNestedManyWithoutRecurrenceRuleInput
  }

  export type RecurrenceRuleCreateOrConnectWithoutChoresInput = {
    where: RecurrenceRuleWhereUniqueInput
    create: XOR<RecurrenceRuleCreateWithoutChoresInput, RecurrenceRuleUncheckedCreateWithoutChoresInput>
  }

  export type ChoreHistoryCreateWithoutChoreInput = {
    id?: string
    action: $Enums.ChoreAction
    changedAt?: Date | string
    user: UserCreateNestedOneWithoutChoreHistoryInput
  }

  export type ChoreHistoryUncheckedCreateWithoutChoreInput = {
    id?: string
    action: $Enums.ChoreAction
    changedById: string
    changedAt?: Date | string
  }

  export type ChoreHistoryCreateOrConnectWithoutChoreInput = {
    where: ChoreHistoryWhereUniqueInput
    create: XOR<ChoreHistoryCreateWithoutChoreInput, ChoreHistoryUncheckedCreateWithoutChoreInput>
  }

  export type ChoreHistoryCreateManyChoreInputEnvelope = {
    data: ChoreHistoryCreateManyChoreInput | ChoreHistoryCreateManyChoreInput[]
    skipDuplicates?: boolean
  }

  export type HouseholdUpsertWithoutChoresInput = {
    update: XOR<HouseholdUpdateWithoutChoresInput, HouseholdUncheckedUpdateWithoutChoresInput>
    create: XOR<HouseholdCreateWithoutChoresInput, HouseholdUncheckedCreateWithoutChoresInput>
    where?: HouseholdWhereInput
  }

  export type HouseholdUpdateToOneWithWhereWithoutChoresInput = {
    where?: HouseholdWhereInput
    data: XOR<HouseholdUpdateWithoutChoresInput, HouseholdUncheckedUpdateWithoutChoresInput>
  }

  export type HouseholdUpdateWithoutChoresInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    members?: HouseholdMemberUpdateManyWithoutHouseholdNestedInput
    threads?: ThreadUpdateManyWithoutHouseholdNestedInput
    expenses?: ExpenseUpdateManyWithoutHouseholdNestedInput
    events?: EventUpdateManyWithoutHouseholdNestedInput
    choreTemplates?: ChoreTemplateUpdateManyWithoutHouseholdNestedInput
    notificationSettings?: NotificationSettingsUpdateManyWithoutHouseholdNestedInput
  }

  export type HouseholdUncheckedUpdateWithoutChoresInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    members?: HouseholdMemberUncheckedUpdateManyWithoutHouseholdNestedInput
    threads?: ThreadUncheckedUpdateManyWithoutHouseholdNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutHouseholdNestedInput
    events?: EventUncheckedUpdateManyWithoutHouseholdNestedInput
    choreTemplates?: ChoreTemplateUncheckedUpdateManyWithoutHouseholdNestedInput
    notificationSettings?: NotificationSettingsUncheckedUpdateManyWithoutHouseholdNestedInput
  }

  export type SubtaskUpsertWithWhereUniqueWithoutChoreInput = {
    where: SubtaskWhereUniqueInput
    update: XOR<SubtaskUpdateWithoutChoreInput, SubtaskUncheckedUpdateWithoutChoreInput>
    create: XOR<SubtaskCreateWithoutChoreInput, SubtaskUncheckedCreateWithoutChoreInput>
  }

  export type SubtaskUpdateWithWhereUniqueWithoutChoreInput = {
    where: SubtaskWhereUniqueInput
    data: XOR<SubtaskUpdateWithoutChoreInput, SubtaskUncheckedUpdateWithoutChoreInput>
  }

  export type SubtaskUpdateManyWithWhereWithoutChoreInput = {
    where: SubtaskScalarWhereInput
    data: XOR<SubtaskUpdateManyMutationInput, SubtaskUncheckedUpdateManyWithoutChoreInput>
  }

  export type SubtaskScalarWhereInput = {
    AND?: SubtaskScalarWhereInput | SubtaskScalarWhereInput[]
    OR?: SubtaskScalarWhereInput[]
    NOT?: SubtaskScalarWhereInput | SubtaskScalarWhereInput[]
    id?: StringFilter<"Subtask"> | string
    choreId?: StringFilter<"Subtask"> | string
    title?: StringFilter<"Subtask"> | string
    description?: StringNullableFilter<"Subtask"> | string | null
    status?: EnumSubtaskStatusFilter<"Subtask"> | $Enums.SubtaskStatus
  }

  export type ChoreAssignmentUpsertWithWhereUniqueWithoutChoreInput = {
    where: ChoreAssignmentWhereUniqueInput
    update: XOR<ChoreAssignmentUpdateWithoutChoreInput, ChoreAssignmentUncheckedUpdateWithoutChoreInput>
    create: XOR<ChoreAssignmentCreateWithoutChoreInput, ChoreAssignmentUncheckedCreateWithoutChoreInput>
  }

  export type ChoreAssignmentUpdateWithWhereUniqueWithoutChoreInput = {
    where: ChoreAssignmentWhereUniqueInput
    data: XOR<ChoreAssignmentUpdateWithoutChoreInput, ChoreAssignmentUncheckedUpdateWithoutChoreInput>
  }

  export type ChoreAssignmentUpdateManyWithWhereWithoutChoreInput = {
    where: ChoreAssignmentScalarWhereInput
    data: XOR<ChoreAssignmentUpdateManyMutationInput, ChoreAssignmentUncheckedUpdateManyWithoutChoreInput>
  }

  export type EventUpsertWithoutChoreInput = {
    update: XOR<EventUpdateWithoutChoreInput, EventUncheckedUpdateWithoutChoreInput>
    create: XOR<EventCreateWithoutChoreInput, EventUncheckedCreateWithoutChoreInput>
    where?: EventWhereInput
  }

  export type EventUpdateToOneWithWhereWithoutChoreInput = {
    where?: EventWhereInput
    data: XOR<EventUpdateWithoutChoreInput, EventUncheckedUpdateWithoutChoreInput>
  }

  export type EventUpdateWithoutChoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    choreId?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumEventCategoryFieldUpdateOperationsInput | $Enums.EventCategory
    isAllDay?: BoolFieldUpdateOperationsInput | boolean
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumEventStatusFieldUpdateOperationsInput | $Enums.EventStatus
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminders?: EventReminderUpdateManyWithoutEventNestedInput
    household?: HouseholdUpdateOneRequiredWithoutEventsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutEventsCreatedNestedInput
    recurrenceRule?: RecurrenceRuleUpdateOneWithoutEventsNestedInput
    history?: CalendarEventHistoryUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateWithoutChoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    choreId?: NullableStringFieldUpdateOperationsInput | string | null
    recurrenceRuleId?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumEventCategoryFieldUpdateOperationsInput | $Enums.EventCategory
    isAllDay?: BoolFieldUpdateOperationsInput | boolean
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumEventStatusFieldUpdateOperationsInput | $Enums.EventStatus
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminders?: EventReminderUncheckedUpdateManyWithoutEventNestedInput
    history?: CalendarEventHistoryUncheckedUpdateManyWithoutEventNestedInput
  }

  export type ChoreSwapRequestUpsertWithWhereUniqueWithoutChoreInput = {
    where: ChoreSwapRequestWhereUniqueInput
    update: XOR<ChoreSwapRequestUpdateWithoutChoreInput, ChoreSwapRequestUncheckedUpdateWithoutChoreInput>
    create: XOR<ChoreSwapRequestCreateWithoutChoreInput, ChoreSwapRequestUncheckedCreateWithoutChoreInput>
  }

  export type ChoreSwapRequestUpdateWithWhereUniqueWithoutChoreInput = {
    where: ChoreSwapRequestWhereUniqueInput
    data: XOR<ChoreSwapRequestUpdateWithoutChoreInput, ChoreSwapRequestUncheckedUpdateWithoutChoreInput>
  }

  export type ChoreSwapRequestUpdateManyWithWhereWithoutChoreInput = {
    where: ChoreSwapRequestScalarWhereInput
    data: XOR<ChoreSwapRequestUpdateManyMutationInput, ChoreSwapRequestUncheckedUpdateManyWithoutChoreInput>
  }

  export type RecurrenceRuleUpsertWithoutChoresInput = {
    update: XOR<RecurrenceRuleUpdateWithoutChoresInput, RecurrenceRuleUncheckedUpdateWithoutChoresInput>
    create: XOR<RecurrenceRuleCreateWithoutChoresInput, RecurrenceRuleUncheckedCreateWithoutChoresInput>
    where?: RecurrenceRuleWhereInput
  }

  export type RecurrenceRuleUpdateToOneWithWhereWithoutChoresInput = {
    where?: RecurrenceRuleWhereInput
    data: XOR<RecurrenceRuleUpdateWithoutChoresInput, RecurrenceRuleUncheckedUpdateWithoutChoresInput>
  }

  export type RecurrenceRuleUpdateWithoutChoresInput = {
    id?: StringFieldUpdateOperationsInput | string
    frequency?: EnumRecurrenceFrequencyFieldUpdateOperationsInput | $Enums.RecurrenceFrequency
    interval?: IntFieldUpdateOperationsInput | number
    byWeekDay?: RecurrenceRuleUpdatebyWeekDayInput | $Enums.DaysOfWeek[]
    byMonthDay?: RecurrenceRuleUpdatebyMonthDayInput | number[]
    bySetPos?: NullableIntFieldUpdateOperationsInput | number | null
    count?: NullableIntFieldUpdateOperationsInput | number | null
    until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customRuleString?: NullableStringFieldUpdateOperationsInput | string | null
    events?: EventUpdateManyWithoutRecurrenceRuleNestedInput
  }

  export type RecurrenceRuleUncheckedUpdateWithoutChoresInput = {
    id?: StringFieldUpdateOperationsInput | string
    frequency?: EnumRecurrenceFrequencyFieldUpdateOperationsInput | $Enums.RecurrenceFrequency
    interval?: IntFieldUpdateOperationsInput | number
    byWeekDay?: RecurrenceRuleUpdatebyWeekDayInput | $Enums.DaysOfWeek[]
    byMonthDay?: RecurrenceRuleUpdatebyMonthDayInput | number[]
    bySetPos?: NullableIntFieldUpdateOperationsInput | number | null
    count?: NullableIntFieldUpdateOperationsInput | number | null
    until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customRuleString?: NullableStringFieldUpdateOperationsInput | string | null
    events?: EventUncheckedUpdateManyWithoutRecurrenceRuleNestedInput
  }

  export type ChoreHistoryUpsertWithWhereUniqueWithoutChoreInput = {
    where: ChoreHistoryWhereUniqueInput
    update: XOR<ChoreHistoryUpdateWithoutChoreInput, ChoreHistoryUncheckedUpdateWithoutChoreInput>
    create: XOR<ChoreHistoryCreateWithoutChoreInput, ChoreHistoryUncheckedCreateWithoutChoreInput>
  }

  export type ChoreHistoryUpdateWithWhereUniqueWithoutChoreInput = {
    where: ChoreHistoryWhereUniqueInput
    data: XOR<ChoreHistoryUpdateWithoutChoreInput, ChoreHistoryUncheckedUpdateWithoutChoreInput>
  }

  export type ChoreHistoryUpdateManyWithWhereWithoutChoreInput = {
    where: ChoreHistoryScalarWhereInput
    data: XOR<ChoreHistoryUpdateManyMutationInput, ChoreHistoryUncheckedUpdateManyWithoutChoreInput>
  }

  export type ChoreCreateWithoutSubtasksInput = {
    id?: string
    title: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dueDate?: Date | string | null
    status?: $Enums.ChoreStatus
    priority?: number | null
    deletedAt?: Date | string | null
    household: HouseholdCreateNestedOneWithoutChoresInput
    assignedUsers?: ChoreAssignmentCreateNestedManyWithoutChoreInput
    event?: EventCreateNestedOneWithoutChoreInput
    choreSwapRequests?: ChoreSwapRequestCreateNestedManyWithoutChoreInput
    recurrenceRule?: RecurrenceRuleCreateNestedOneWithoutChoresInput
    history?: ChoreHistoryCreateNestedManyWithoutChoreInput
  }

  export type ChoreUncheckedCreateWithoutSubtasksInput = {
    id?: string
    householdId: string
    title: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dueDate?: Date | string | null
    status?: $Enums.ChoreStatus
    priority?: number | null
    eventId?: string | null
    recurrenceRuleId?: string | null
    deletedAt?: Date | string | null
    assignedUsers?: ChoreAssignmentUncheckedCreateNestedManyWithoutChoreInput
    choreSwapRequests?: ChoreSwapRequestUncheckedCreateNestedManyWithoutChoreInput
    history?: ChoreHistoryUncheckedCreateNestedManyWithoutChoreInput
  }

  export type ChoreCreateOrConnectWithoutSubtasksInput = {
    where: ChoreWhereUniqueInput
    create: XOR<ChoreCreateWithoutSubtasksInput, ChoreUncheckedCreateWithoutSubtasksInput>
  }

  export type ChoreUpsertWithoutSubtasksInput = {
    update: XOR<ChoreUpdateWithoutSubtasksInput, ChoreUncheckedUpdateWithoutSubtasksInput>
    create: XOR<ChoreCreateWithoutSubtasksInput, ChoreUncheckedCreateWithoutSubtasksInput>
    where?: ChoreWhereInput
  }

  export type ChoreUpdateToOneWithWhereWithoutSubtasksInput = {
    where?: ChoreWhereInput
    data: XOR<ChoreUpdateWithoutSubtasksInput, ChoreUncheckedUpdateWithoutSubtasksInput>
  }

  export type ChoreUpdateWithoutSubtasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumChoreStatusFieldUpdateOperationsInput | $Enums.ChoreStatus
    priority?: NullableIntFieldUpdateOperationsInput | number | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    household?: HouseholdUpdateOneRequiredWithoutChoresNestedInput
    assignedUsers?: ChoreAssignmentUpdateManyWithoutChoreNestedInput
    event?: EventUpdateOneWithoutChoreNestedInput
    choreSwapRequests?: ChoreSwapRequestUpdateManyWithoutChoreNestedInput
    recurrenceRule?: RecurrenceRuleUpdateOneWithoutChoresNestedInput
    history?: ChoreHistoryUpdateManyWithoutChoreNestedInput
  }

  export type ChoreUncheckedUpdateWithoutSubtasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumChoreStatusFieldUpdateOperationsInput | $Enums.ChoreStatus
    priority?: NullableIntFieldUpdateOperationsInput | number | null
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    recurrenceRuleId?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedUsers?: ChoreAssignmentUncheckedUpdateManyWithoutChoreNestedInput
    choreSwapRequests?: ChoreSwapRequestUncheckedUpdateManyWithoutChoreNestedInput
    history?: ChoreHistoryUncheckedUpdateManyWithoutChoreNestedInput
  }

  export type ChoreCreateWithoutAssignedUsersInput = {
    id?: string
    title: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dueDate?: Date | string | null
    status?: $Enums.ChoreStatus
    priority?: number | null
    deletedAt?: Date | string | null
    household: HouseholdCreateNestedOneWithoutChoresInput
    subtasks?: SubtaskCreateNestedManyWithoutChoreInput
    event?: EventCreateNestedOneWithoutChoreInput
    choreSwapRequests?: ChoreSwapRequestCreateNestedManyWithoutChoreInput
    recurrenceRule?: RecurrenceRuleCreateNestedOneWithoutChoresInput
    history?: ChoreHistoryCreateNestedManyWithoutChoreInput
  }

  export type ChoreUncheckedCreateWithoutAssignedUsersInput = {
    id?: string
    householdId: string
    title: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dueDate?: Date | string | null
    status?: $Enums.ChoreStatus
    priority?: number | null
    eventId?: string | null
    recurrenceRuleId?: string | null
    deletedAt?: Date | string | null
    subtasks?: SubtaskUncheckedCreateNestedManyWithoutChoreInput
    choreSwapRequests?: ChoreSwapRequestUncheckedCreateNestedManyWithoutChoreInput
    history?: ChoreHistoryUncheckedCreateNestedManyWithoutChoreInput
  }

  export type ChoreCreateOrConnectWithoutAssignedUsersInput = {
    where: ChoreWhereUniqueInput
    create: XOR<ChoreCreateWithoutAssignedUsersInput, ChoreUncheckedCreateWithoutAssignedUsersInput>
  }

  export type UserCreateWithoutAssignedChoresInput = {
    id?: string
    email: string
    passwordHash?: string | null
    name: string
    profileImageURL?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deviceTokens?: UserCreatedeviceTokensInput | string[]
    deletedAt?: Date | string | null
    households?: HouseholdMemberCreateNestedManyWithoutUserInput
    messages?: MessageCreateNestedManyWithoutAuthorInput
    threads?: ThreadCreateNestedManyWithoutAuthorInput
    expensesPaid?: ExpenseCreateNestedManyWithoutPaidByInput
    expenseSplits?: ExpenseSplitCreateNestedManyWithoutUserInput
    transactionsFrom?: TransactionCreateNestedManyWithoutFromUserInput
    transactionsTo?: TransactionCreateNestedManyWithoutToUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    oauthIntegrations?: OAuthIntegrationCreateNestedManyWithoutUserInput
    eventsCreated?: EventCreateNestedManyWithoutCreatedByInput
    choreSwapRequestsInitiated?: ChoreSwapRequestCreateNestedManyWithoutRequestingUserInput
    choreSwapRequestsReceived?: ChoreSwapRequestCreateNestedManyWithoutTargetUserInput
    reactions?: ReactionCreateNestedManyWithoutUserInput
    mentions?: MentionCreateNestedManyWithoutUserInput
    choreHistory?: ChoreHistoryCreateNestedManyWithoutUserInput
    notificationSettings?: NotificationSettingsCreateNestedManyWithoutUserInput
    calendarEventHistory?: CalendarEventHistoryCreateNestedManyWithoutUserInput
    expenseHistory?: ExpenseHistoryCreateNestedManyWithoutUserInput
    messageReads?: MessageReadCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAssignedChoresInput = {
    id?: string
    email: string
    passwordHash?: string | null
    name: string
    profileImageURL?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deviceTokens?: UserCreatedeviceTokensInput | string[]
    deletedAt?: Date | string | null
    households?: HouseholdMemberUncheckedCreateNestedManyWithoutUserInput
    messages?: MessageUncheckedCreateNestedManyWithoutAuthorInput
    threads?: ThreadUncheckedCreateNestedManyWithoutAuthorInput
    expensesPaid?: ExpenseUncheckedCreateNestedManyWithoutPaidByInput
    expenseSplits?: ExpenseSplitUncheckedCreateNestedManyWithoutUserInput
    transactionsFrom?: TransactionUncheckedCreateNestedManyWithoutFromUserInput
    transactionsTo?: TransactionUncheckedCreateNestedManyWithoutToUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    oauthIntegrations?: OAuthIntegrationUncheckedCreateNestedManyWithoutUserInput
    eventsCreated?: EventUncheckedCreateNestedManyWithoutCreatedByInput
    choreSwapRequestsInitiated?: ChoreSwapRequestUncheckedCreateNestedManyWithoutRequestingUserInput
    choreSwapRequestsReceived?: ChoreSwapRequestUncheckedCreateNestedManyWithoutTargetUserInput
    reactions?: ReactionUncheckedCreateNestedManyWithoutUserInput
    mentions?: MentionUncheckedCreateNestedManyWithoutUserInput
    choreHistory?: ChoreHistoryUncheckedCreateNestedManyWithoutUserInput
    notificationSettings?: NotificationSettingsUncheckedCreateNestedManyWithoutUserInput
    calendarEventHistory?: CalendarEventHistoryUncheckedCreateNestedManyWithoutUserInput
    expenseHistory?: ExpenseHistoryUncheckedCreateNestedManyWithoutUserInput
    messageReads?: MessageReadUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAssignedChoresInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAssignedChoresInput, UserUncheckedCreateWithoutAssignedChoresInput>
  }

  export type ChoreUpsertWithoutAssignedUsersInput = {
    update: XOR<ChoreUpdateWithoutAssignedUsersInput, ChoreUncheckedUpdateWithoutAssignedUsersInput>
    create: XOR<ChoreCreateWithoutAssignedUsersInput, ChoreUncheckedCreateWithoutAssignedUsersInput>
    where?: ChoreWhereInput
  }

  export type ChoreUpdateToOneWithWhereWithoutAssignedUsersInput = {
    where?: ChoreWhereInput
    data: XOR<ChoreUpdateWithoutAssignedUsersInput, ChoreUncheckedUpdateWithoutAssignedUsersInput>
  }

  export type ChoreUpdateWithoutAssignedUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumChoreStatusFieldUpdateOperationsInput | $Enums.ChoreStatus
    priority?: NullableIntFieldUpdateOperationsInput | number | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    household?: HouseholdUpdateOneRequiredWithoutChoresNestedInput
    subtasks?: SubtaskUpdateManyWithoutChoreNestedInput
    event?: EventUpdateOneWithoutChoreNestedInput
    choreSwapRequests?: ChoreSwapRequestUpdateManyWithoutChoreNestedInput
    recurrenceRule?: RecurrenceRuleUpdateOneWithoutChoresNestedInput
    history?: ChoreHistoryUpdateManyWithoutChoreNestedInput
  }

  export type ChoreUncheckedUpdateWithoutAssignedUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumChoreStatusFieldUpdateOperationsInput | $Enums.ChoreStatus
    priority?: NullableIntFieldUpdateOperationsInput | number | null
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    recurrenceRuleId?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtasks?: SubtaskUncheckedUpdateManyWithoutChoreNestedInput
    choreSwapRequests?: ChoreSwapRequestUncheckedUpdateManyWithoutChoreNestedInput
    history?: ChoreHistoryUncheckedUpdateManyWithoutChoreNestedInput
  }

  export type UserUpsertWithoutAssignedChoresInput = {
    update: XOR<UserUpdateWithoutAssignedChoresInput, UserUncheckedUpdateWithoutAssignedChoresInput>
    create: XOR<UserCreateWithoutAssignedChoresInput, UserUncheckedCreateWithoutAssignedChoresInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAssignedChoresInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAssignedChoresInput, UserUncheckedUpdateWithoutAssignedChoresInput>
  }

  export type UserUpdateWithoutAssignedChoresInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    profileImageURL?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deviceTokens?: UserUpdatedeviceTokensInput | string[]
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    households?: HouseholdMemberUpdateManyWithoutUserNestedInput
    messages?: MessageUpdateManyWithoutAuthorNestedInput
    threads?: ThreadUpdateManyWithoutAuthorNestedInput
    expensesPaid?: ExpenseUpdateManyWithoutPaidByNestedInput
    expenseSplits?: ExpenseSplitUpdateManyWithoutUserNestedInput
    transactionsFrom?: TransactionUpdateManyWithoutFromUserNestedInput
    transactionsTo?: TransactionUpdateManyWithoutToUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    oauthIntegrations?: OAuthIntegrationUpdateManyWithoutUserNestedInput
    eventsCreated?: EventUpdateManyWithoutCreatedByNestedInput
    choreSwapRequestsInitiated?: ChoreSwapRequestUpdateManyWithoutRequestingUserNestedInput
    choreSwapRequestsReceived?: ChoreSwapRequestUpdateManyWithoutTargetUserNestedInput
    reactions?: ReactionUpdateManyWithoutUserNestedInput
    mentions?: MentionUpdateManyWithoutUserNestedInput
    choreHistory?: ChoreHistoryUpdateManyWithoutUserNestedInput
    notificationSettings?: NotificationSettingsUpdateManyWithoutUserNestedInput
    calendarEventHistory?: CalendarEventHistoryUpdateManyWithoutUserNestedInput
    expenseHistory?: ExpenseHistoryUpdateManyWithoutUserNestedInput
    messageReads?: MessageReadUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAssignedChoresInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    profileImageURL?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deviceTokens?: UserUpdatedeviceTokensInput | string[]
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    households?: HouseholdMemberUncheckedUpdateManyWithoutUserNestedInput
    messages?: MessageUncheckedUpdateManyWithoutAuthorNestedInput
    threads?: ThreadUncheckedUpdateManyWithoutAuthorNestedInput
    expensesPaid?: ExpenseUncheckedUpdateManyWithoutPaidByNestedInput
    expenseSplits?: ExpenseSplitUncheckedUpdateManyWithoutUserNestedInput
    transactionsFrom?: TransactionUncheckedUpdateManyWithoutFromUserNestedInput
    transactionsTo?: TransactionUncheckedUpdateManyWithoutToUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    oauthIntegrations?: OAuthIntegrationUncheckedUpdateManyWithoutUserNestedInput
    eventsCreated?: EventUncheckedUpdateManyWithoutCreatedByNestedInput
    choreSwapRequestsInitiated?: ChoreSwapRequestUncheckedUpdateManyWithoutRequestingUserNestedInput
    choreSwapRequestsReceived?: ChoreSwapRequestUncheckedUpdateManyWithoutTargetUserNestedInput
    reactions?: ReactionUncheckedUpdateManyWithoutUserNestedInput
    mentions?: MentionUncheckedUpdateManyWithoutUserNestedInput
    choreHistory?: ChoreHistoryUncheckedUpdateManyWithoutUserNestedInput
    notificationSettings?: NotificationSettingsUncheckedUpdateManyWithoutUserNestedInput
    calendarEventHistory?: CalendarEventHistoryUncheckedUpdateManyWithoutUserNestedInput
    expenseHistory?: ExpenseHistoryUncheckedUpdateManyWithoutUserNestedInput
    messageReads?: MessageReadUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutChoreSwapRequestsInitiatedInput = {
    id?: string
    email: string
    passwordHash?: string | null
    name: string
    profileImageURL?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deviceTokens?: UserCreatedeviceTokensInput | string[]
    deletedAt?: Date | string | null
    households?: HouseholdMemberCreateNestedManyWithoutUserInput
    messages?: MessageCreateNestedManyWithoutAuthorInput
    threads?: ThreadCreateNestedManyWithoutAuthorInput
    assignedChores?: ChoreAssignmentCreateNestedManyWithoutUserInput
    expensesPaid?: ExpenseCreateNestedManyWithoutPaidByInput
    expenseSplits?: ExpenseSplitCreateNestedManyWithoutUserInput
    transactionsFrom?: TransactionCreateNestedManyWithoutFromUserInput
    transactionsTo?: TransactionCreateNestedManyWithoutToUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    oauthIntegrations?: OAuthIntegrationCreateNestedManyWithoutUserInput
    eventsCreated?: EventCreateNestedManyWithoutCreatedByInput
    choreSwapRequestsReceived?: ChoreSwapRequestCreateNestedManyWithoutTargetUserInput
    reactions?: ReactionCreateNestedManyWithoutUserInput
    mentions?: MentionCreateNestedManyWithoutUserInput
    choreHistory?: ChoreHistoryCreateNestedManyWithoutUserInput
    notificationSettings?: NotificationSettingsCreateNestedManyWithoutUserInput
    calendarEventHistory?: CalendarEventHistoryCreateNestedManyWithoutUserInput
    expenseHistory?: ExpenseHistoryCreateNestedManyWithoutUserInput
    messageReads?: MessageReadCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutChoreSwapRequestsInitiatedInput = {
    id?: string
    email: string
    passwordHash?: string | null
    name: string
    profileImageURL?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deviceTokens?: UserCreatedeviceTokensInput | string[]
    deletedAt?: Date | string | null
    households?: HouseholdMemberUncheckedCreateNestedManyWithoutUserInput
    messages?: MessageUncheckedCreateNestedManyWithoutAuthorInput
    threads?: ThreadUncheckedCreateNestedManyWithoutAuthorInput
    assignedChores?: ChoreAssignmentUncheckedCreateNestedManyWithoutUserInput
    expensesPaid?: ExpenseUncheckedCreateNestedManyWithoutPaidByInput
    expenseSplits?: ExpenseSplitUncheckedCreateNestedManyWithoutUserInput
    transactionsFrom?: TransactionUncheckedCreateNestedManyWithoutFromUserInput
    transactionsTo?: TransactionUncheckedCreateNestedManyWithoutToUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    oauthIntegrations?: OAuthIntegrationUncheckedCreateNestedManyWithoutUserInput
    eventsCreated?: EventUncheckedCreateNestedManyWithoutCreatedByInput
    choreSwapRequestsReceived?: ChoreSwapRequestUncheckedCreateNestedManyWithoutTargetUserInput
    reactions?: ReactionUncheckedCreateNestedManyWithoutUserInput
    mentions?: MentionUncheckedCreateNestedManyWithoutUserInput
    choreHistory?: ChoreHistoryUncheckedCreateNestedManyWithoutUserInput
    notificationSettings?: NotificationSettingsUncheckedCreateNestedManyWithoutUserInput
    calendarEventHistory?: CalendarEventHistoryUncheckedCreateNestedManyWithoutUserInput
    expenseHistory?: ExpenseHistoryUncheckedCreateNestedManyWithoutUserInput
    messageReads?: MessageReadUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutChoreSwapRequestsInitiatedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutChoreSwapRequestsInitiatedInput, UserUncheckedCreateWithoutChoreSwapRequestsInitiatedInput>
  }

  export type UserCreateWithoutChoreSwapRequestsReceivedInput = {
    id?: string
    email: string
    passwordHash?: string | null
    name: string
    profileImageURL?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deviceTokens?: UserCreatedeviceTokensInput | string[]
    deletedAt?: Date | string | null
    households?: HouseholdMemberCreateNestedManyWithoutUserInput
    messages?: MessageCreateNestedManyWithoutAuthorInput
    threads?: ThreadCreateNestedManyWithoutAuthorInput
    assignedChores?: ChoreAssignmentCreateNestedManyWithoutUserInput
    expensesPaid?: ExpenseCreateNestedManyWithoutPaidByInput
    expenseSplits?: ExpenseSplitCreateNestedManyWithoutUserInput
    transactionsFrom?: TransactionCreateNestedManyWithoutFromUserInput
    transactionsTo?: TransactionCreateNestedManyWithoutToUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    oauthIntegrations?: OAuthIntegrationCreateNestedManyWithoutUserInput
    eventsCreated?: EventCreateNestedManyWithoutCreatedByInput
    choreSwapRequestsInitiated?: ChoreSwapRequestCreateNestedManyWithoutRequestingUserInput
    reactions?: ReactionCreateNestedManyWithoutUserInput
    mentions?: MentionCreateNestedManyWithoutUserInput
    choreHistory?: ChoreHistoryCreateNestedManyWithoutUserInput
    notificationSettings?: NotificationSettingsCreateNestedManyWithoutUserInput
    calendarEventHistory?: CalendarEventHistoryCreateNestedManyWithoutUserInput
    expenseHistory?: ExpenseHistoryCreateNestedManyWithoutUserInput
    messageReads?: MessageReadCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutChoreSwapRequestsReceivedInput = {
    id?: string
    email: string
    passwordHash?: string | null
    name: string
    profileImageURL?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deviceTokens?: UserCreatedeviceTokensInput | string[]
    deletedAt?: Date | string | null
    households?: HouseholdMemberUncheckedCreateNestedManyWithoutUserInput
    messages?: MessageUncheckedCreateNestedManyWithoutAuthorInput
    threads?: ThreadUncheckedCreateNestedManyWithoutAuthorInput
    assignedChores?: ChoreAssignmentUncheckedCreateNestedManyWithoutUserInput
    expensesPaid?: ExpenseUncheckedCreateNestedManyWithoutPaidByInput
    expenseSplits?: ExpenseSplitUncheckedCreateNestedManyWithoutUserInput
    transactionsFrom?: TransactionUncheckedCreateNestedManyWithoutFromUserInput
    transactionsTo?: TransactionUncheckedCreateNestedManyWithoutToUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    oauthIntegrations?: OAuthIntegrationUncheckedCreateNestedManyWithoutUserInput
    eventsCreated?: EventUncheckedCreateNestedManyWithoutCreatedByInput
    choreSwapRequestsInitiated?: ChoreSwapRequestUncheckedCreateNestedManyWithoutRequestingUserInput
    reactions?: ReactionUncheckedCreateNestedManyWithoutUserInput
    mentions?: MentionUncheckedCreateNestedManyWithoutUserInput
    choreHistory?: ChoreHistoryUncheckedCreateNestedManyWithoutUserInput
    notificationSettings?: NotificationSettingsUncheckedCreateNestedManyWithoutUserInput
    calendarEventHistory?: CalendarEventHistoryUncheckedCreateNestedManyWithoutUserInput
    expenseHistory?: ExpenseHistoryUncheckedCreateNestedManyWithoutUserInput
    messageReads?: MessageReadUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutChoreSwapRequestsReceivedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutChoreSwapRequestsReceivedInput, UserUncheckedCreateWithoutChoreSwapRequestsReceivedInput>
  }

  export type ChoreCreateWithoutChoreSwapRequestsInput = {
    id?: string
    title: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dueDate?: Date | string | null
    status?: $Enums.ChoreStatus
    priority?: number | null
    deletedAt?: Date | string | null
    household: HouseholdCreateNestedOneWithoutChoresInput
    subtasks?: SubtaskCreateNestedManyWithoutChoreInput
    assignedUsers?: ChoreAssignmentCreateNestedManyWithoutChoreInput
    event?: EventCreateNestedOneWithoutChoreInput
    recurrenceRule?: RecurrenceRuleCreateNestedOneWithoutChoresInput
    history?: ChoreHistoryCreateNestedManyWithoutChoreInput
  }

  export type ChoreUncheckedCreateWithoutChoreSwapRequestsInput = {
    id?: string
    householdId: string
    title: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dueDate?: Date | string | null
    status?: $Enums.ChoreStatus
    priority?: number | null
    eventId?: string | null
    recurrenceRuleId?: string | null
    deletedAt?: Date | string | null
    subtasks?: SubtaskUncheckedCreateNestedManyWithoutChoreInput
    assignedUsers?: ChoreAssignmentUncheckedCreateNestedManyWithoutChoreInput
    history?: ChoreHistoryUncheckedCreateNestedManyWithoutChoreInput
  }

  export type ChoreCreateOrConnectWithoutChoreSwapRequestsInput = {
    where: ChoreWhereUniqueInput
    create: XOR<ChoreCreateWithoutChoreSwapRequestsInput, ChoreUncheckedCreateWithoutChoreSwapRequestsInput>
  }

  export type UserUpsertWithoutChoreSwapRequestsInitiatedInput = {
    update: XOR<UserUpdateWithoutChoreSwapRequestsInitiatedInput, UserUncheckedUpdateWithoutChoreSwapRequestsInitiatedInput>
    create: XOR<UserCreateWithoutChoreSwapRequestsInitiatedInput, UserUncheckedCreateWithoutChoreSwapRequestsInitiatedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutChoreSwapRequestsInitiatedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutChoreSwapRequestsInitiatedInput, UserUncheckedUpdateWithoutChoreSwapRequestsInitiatedInput>
  }

  export type UserUpdateWithoutChoreSwapRequestsInitiatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    profileImageURL?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deviceTokens?: UserUpdatedeviceTokensInput | string[]
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    households?: HouseholdMemberUpdateManyWithoutUserNestedInput
    messages?: MessageUpdateManyWithoutAuthorNestedInput
    threads?: ThreadUpdateManyWithoutAuthorNestedInput
    assignedChores?: ChoreAssignmentUpdateManyWithoutUserNestedInput
    expensesPaid?: ExpenseUpdateManyWithoutPaidByNestedInput
    expenseSplits?: ExpenseSplitUpdateManyWithoutUserNestedInput
    transactionsFrom?: TransactionUpdateManyWithoutFromUserNestedInput
    transactionsTo?: TransactionUpdateManyWithoutToUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    oauthIntegrations?: OAuthIntegrationUpdateManyWithoutUserNestedInput
    eventsCreated?: EventUpdateManyWithoutCreatedByNestedInput
    choreSwapRequestsReceived?: ChoreSwapRequestUpdateManyWithoutTargetUserNestedInput
    reactions?: ReactionUpdateManyWithoutUserNestedInput
    mentions?: MentionUpdateManyWithoutUserNestedInput
    choreHistory?: ChoreHistoryUpdateManyWithoutUserNestedInput
    notificationSettings?: NotificationSettingsUpdateManyWithoutUserNestedInput
    calendarEventHistory?: CalendarEventHistoryUpdateManyWithoutUserNestedInput
    expenseHistory?: ExpenseHistoryUpdateManyWithoutUserNestedInput
    messageReads?: MessageReadUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutChoreSwapRequestsInitiatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    profileImageURL?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deviceTokens?: UserUpdatedeviceTokensInput | string[]
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    households?: HouseholdMemberUncheckedUpdateManyWithoutUserNestedInput
    messages?: MessageUncheckedUpdateManyWithoutAuthorNestedInput
    threads?: ThreadUncheckedUpdateManyWithoutAuthorNestedInput
    assignedChores?: ChoreAssignmentUncheckedUpdateManyWithoutUserNestedInput
    expensesPaid?: ExpenseUncheckedUpdateManyWithoutPaidByNestedInput
    expenseSplits?: ExpenseSplitUncheckedUpdateManyWithoutUserNestedInput
    transactionsFrom?: TransactionUncheckedUpdateManyWithoutFromUserNestedInput
    transactionsTo?: TransactionUncheckedUpdateManyWithoutToUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    oauthIntegrations?: OAuthIntegrationUncheckedUpdateManyWithoutUserNestedInput
    eventsCreated?: EventUncheckedUpdateManyWithoutCreatedByNestedInput
    choreSwapRequestsReceived?: ChoreSwapRequestUncheckedUpdateManyWithoutTargetUserNestedInput
    reactions?: ReactionUncheckedUpdateManyWithoutUserNestedInput
    mentions?: MentionUncheckedUpdateManyWithoutUserNestedInput
    choreHistory?: ChoreHistoryUncheckedUpdateManyWithoutUserNestedInput
    notificationSettings?: NotificationSettingsUncheckedUpdateManyWithoutUserNestedInput
    calendarEventHistory?: CalendarEventHistoryUncheckedUpdateManyWithoutUserNestedInput
    expenseHistory?: ExpenseHistoryUncheckedUpdateManyWithoutUserNestedInput
    messageReads?: MessageReadUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutChoreSwapRequestsReceivedInput = {
    update: XOR<UserUpdateWithoutChoreSwapRequestsReceivedInput, UserUncheckedUpdateWithoutChoreSwapRequestsReceivedInput>
    create: XOR<UserCreateWithoutChoreSwapRequestsReceivedInput, UserUncheckedCreateWithoutChoreSwapRequestsReceivedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutChoreSwapRequestsReceivedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutChoreSwapRequestsReceivedInput, UserUncheckedUpdateWithoutChoreSwapRequestsReceivedInput>
  }

  export type UserUpdateWithoutChoreSwapRequestsReceivedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    profileImageURL?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deviceTokens?: UserUpdatedeviceTokensInput | string[]
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    households?: HouseholdMemberUpdateManyWithoutUserNestedInput
    messages?: MessageUpdateManyWithoutAuthorNestedInput
    threads?: ThreadUpdateManyWithoutAuthorNestedInput
    assignedChores?: ChoreAssignmentUpdateManyWithoutUserNestedInput
    expensesPaid?: ExpenseUpdateManyWithoutPaidByNestedInput
    expenseSplits?: ExpenseSplitUpdateManyWithoutUserNestedInput
    transactionsFrom?: TransactionUpdateManyWithoutFromUserNestedInput
    transactionsTo?: TransactionUpdateManyWithoutToUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    oauthIntegrations?: OAuthIntegrationUpdateManyWithoutUserNestedInput
    eventsCreated?: EventUpdateManyWithoutCreatedByNestedInput
    choreSwapRequestsInitiated?: ChoreSwapRequestUpdateManyWithoutRequestingUserNestedInput
    reactions?: ReactionUpdateManyWithoutUserNestedInput
    mentions?: MentionUpdateManyWithoutUserNestedInput
    choreHistory?: ChoreHistoryUpdateManyWithoutUserNestedInput
    notificationSettings?: NotificationSettingsUpdateManyWithoutUserNestedInput
    calendarEventHistory?: CalendarEventHistoryUpdateManyWithoutUserNestedInput
    expenseHistory?: ExpenseHistoryUpdateManyWithoutUserNestedInput
    messageReads?: MessageReadUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutChoreSwapRequestsReceivedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    profileImageURL?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deviceTokens?: UserUpdatedeviceTokensInput | string[]
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    households?: HouseholdMemberUncheckedUpdateManyWithoutUserNestedInput
    messages?: MessageUncheckedUpdateManyWithoutAuthorNestedInput
    threads?: ThreadUncheckedUpdateManyWithoutAuthorNestedInput
    assignedChores?: ChoreAssignmentUncheckedUpdateManyWithoutUserNestedInput
    expensesPaid?: ExpenseUncheckedUpdateManyWithoutPaidByNestedInput
    expenseSplits?: ExpenseSplitUncheckedUpdateManyWithoutUserNestedInput
    transactionsFrom?: TransactionUncheckedUpdateManyWithoutFromUserNestedInput
    transactionsTo?: TransactionUncheckedUpdateManyWithoutToUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    oauthIntegrations?: OAuthIntegrationUncheckedUpdateManyWithoutUserNestedInput
    eventsCreated?: EventUncheckedUpdateManyWithoutCreatedByNestedInput
    choreSwapRequestsInitiated?: ChoreSwapRequestUncheckedUpdateManyWithoutRequestingUserNestedInput
    reactions?: ReactionUncheckedUpdateManyWithoutUserNestedInput
    mentions?: MentionUncheckedUpdateManyWithoutUserNestedInput
    choreHistory?: ChoreHistoryUncheckedUpdateManyWithoutUserNestedInput
    notificationSettings?: NotificationSettingsUncheckedUpdateManyWithoutUserNestedInput
    calendarEventHistory?: CalendarEventHistoryUncheckedUpdateManyWithoutUserNestedInput
    expenseHistory?: ExpenseHistoryUncheckedUpdateManyWithoutUserNestedInput
    messageReads?: MessageReadUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ChoreUpsertWithoutChoreSwapRequestsInput = {
    update: XOR<ChoreUpdateWithoutChoreSwapRequestsInput, ChoreUncheckedUpdateWithoutChoreSwapRequestsInput>
    create: XOR<ChoreCreateWithoutChoreSwapRequestsInput, ChoreUncheckedCreateWithoutChoreSwapRequestsInput>
    where?: ChoreWhereInput
  }

  export type ChoreUpdateToOneWithWhereWithoutChoreSwapRequestsInput = {
    where?: ChoreWhereInput
    data: XOR<ChoreUpdateWithoutChoreSwapRequestsInput, ChoreUncheckedUpdateWithoutChoreSwapRequestsInput>
  }

  export type ChoreUpdateWithoutChoreSwapRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumChoreStatusFieldUpdateOperationsInput | $Enums.ChoreStatus
    priority?: NullableIntFieldUpdateOperationsInput | number | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    household?: HouseholdUpdateOneRequiredWithoutChoresNestedInput
    subtasks?: SubtaskUpdateManyWithoutChoreNestedInput
    assignedUsers?: ChoreAssignmentUpdateManyWithoutChoreNestedInput
    event?: EventUpdateOneWithoutChoreNestedInput
    recurrenceRule?: RecurrenceRuleUpdateOneWithoutChoresNestedInput
    history?: ChoreHistoryUpdateManyWithoutChoreNestedInput
  }

  export type ChoreUncheckedUpdateWithoutChoreSwapRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumChoreStatusFieldUpdateOperationsInput | $Enums.ChoreStatus
    priority?: NullableIntFieldUpdateOperationsInput | number | null
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    recurrenceRuleId?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtasks?: SubtaskUncheckedUpdateManyWithoutChoreNestedInput
    assignedUsers?: ChoreAssignmentUncheckedUpdateManyWithoutChoreNestedInput
    history?: ChoreHistoryUncheckedUpdateManyWithoutChoreNestedInput
  }

  export type HouseholdCreateWithoutChoreTemplatesInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    currency?: string
    icon?: string | null
    timezone?: string
    language?: string
    deletedAt?: Date | string | null
    members?: HouseholdMemberCreateNestedManyWithoutHouseholdInput
    threads?: ThreadCreateNestedManyWithoutHouseholdInput
    chores?: ChoreCreateNestedManyWithoutHouseholdInput
    expenses?: ExpenseCreateNestedManyWithoutHouseholdInput
    events?: EventCreateNestedManyWithoutHouseholdInput
    notificationSettings?: NotificationSettingsCreateNestedManyWithoutHouseholdInput
  }

  export type HouseholdUncheckedCreateWithoutChoreTemplatesInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    currency?: string
    icon?: string | null
    timezone?: string
    language?: string
    deletedAt?: Date | string | null
    members?: HouseholdMemberUncheckedCreateNestedManyWithoutHouseholdInput
    threads?: ThreadUncheckedCreateNestedManyWithoutHouseholdInput
    chores?: ChoreUncheckedCreateNestedManyWithoutHouseholdInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutHouseholdInput
    events?: EventUncheckedCreateNestedManyWithoutHouseholdInput
    notificationSettings?: NotificationSettingsUncheckedCreateNestedManyWithoutHouseholdInput
  }

  export type HouseholdCreateOrConnectWithoutChoreTemplatesInput = {
    where: HouseholdWhereUniqueInput
    create: XOR<HouseholdCreateWithoutChoreTemplatesInput, HouseholdUncheckedCreateWithoutChoreTemplatesInput>
  }

  export type SubtaskTemplateCreateWithoutChoreTemplateInput = {
    id?: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubtaskTemplateUncheckedCreateWithoutChoreTemplateInput = {
    id?: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubtaskTemplateCreateOrConnectWithoutChoreTemplateInput = {
    where: SubtaskTemplateWhereUniqueInput
    create: XOR<SubtaskTemplateCreateWithoutChoreTemplateInput, SubtaskTemplateUncheckedCreateWithoutChoreTemplateInput>
  }

  export type SubtaskTemplateCreateManyChoreTemplateInputEnvelope = {
    data: SubtaskTemplateCreateManyChoreTemplateInput | SubtaskTemplateCreateManyChoreTemplateInput[]
    skipDuplicates?: boolean
  }

  export type HouseholdUpsertWithoutChoreTemplatesInput = {
    update: XOR<HouseholdUpdateWithoutChoreTemplatesInput, HouseholdUncheckedUpdateWithoutChoreTemplatesInput>
    create: XOR<HouseholdCreateWithoutChoreTemplatesInput, HouseholdUncheckedCreateWithoutChoreTemplatesInput>
    where?: HouseholdWhereInput
  }

  export type HouseholdUpdateToOneWithWhereWithoutChoreTemplatesInput = {
    where?: HouseholdWhereInput
    data: XOR<HouseholdUpdateWithoutChoreTemplatesInput, HouseholdUncheckedUpdateWithoutChoreTemplatesInput>
  }

  export type HouseholdUpdateWithoutChoreTemplatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    members?: HouseholdMemberUpdateManyWithoutHouseholdNestedInput
    threads?: ThreadUpdateManyWithoutHouseholdNestedInput
    chores?: ChoreUpdateManyWithoutHouseholdNestedInput
    expenses?: ExpenseUpdateManyWithoutHouseholdNestedInput
    events?: EventUpdateManyWithoutHouseholdNestedInput
    notificationSettings?: NotificationSettingsUpdateManyWithoutHouseholdNestedInput
  }

  export type HouseholdUncheckedUpdateWithoutChoreTemplatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    members?: HouseholdMemberUncheckedUpdateManyWithoutHouseholdNestedInput
    threads?: ThreadUncheckedUpdateManyWithoutHouseholdNestedInput
    chores?: ChoreUncheckedUpdateManyWithoutHouseholdNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutHouseholdNestedInput
    events?: EventUncheckedUpdateManyWithoutHouseholdNestedInput
    notificationSettings?: NotificationSettingsUncheckedUpdateManyWithoutHouseholdNestedInput
  }

  export type SubtaskTemplateUpsertWithWhereUniqueWithoutChoreTemplateInput = {
    where: SubtaskTemplateWhereUniqueInput
    update: XOR<SubtaskTemplateUpdateWithoutChoreTemplateInput, SubtaskTemplateUncheckedUpdateWithoutChoreTemplateInput>
    create: XOR<SubtaskTemplateCreateWithoutChoreTemplateInput, SubtaskTemplateUncheckedCreateWithoutChoreTemplateInput>
  }

  export type SubtaskTemplateUpdateWithWhereUniqueWithoutChoreTemplateInput = {
    where: SubtaskTemplateWhereUniqueInput
    data: XOR<SubtaskTemplateUpdateWithoutChoreTemplateInput, SubtaskTemplateUncheckedUpdateWithoutChoreTemplateInput>
  }

  export type SubtaskTemplateUpdateManyWithWhereWithoutChoreTemplateInput = {
    where: SubtaskTemplateScalarWhereInput
    data: XOR<SubtaskTemplateUpdateManyMutationInput, SubtaskTemplateUncheckedUpdateManyWithoutChoreTemplateInput>
  }

  export type SubtaskTemplateScalarWhereInput = {
    AND?: SubtaskTemplateScalarWhereInput | SubtaskTemplateScalarWhereInput[]
    OR?: SubtaskTemplateScalarWhereInput[]
    NOT?: SubtaskTemplateScalarWhereInput | SubtaskTemplateScalarWhereInput[]
    id?: StringFilter<"SubtaskTemplate"> | string
    choreTemplateId?: StringFilter<"SubtaskTemplate"> | string
    title?: StringFilter<"SubtaskTemplate"> | string
    createdAt?: DateTimeFilter<"SubtaskTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"SubtaskTemplate"> | Date | string
  }

  export type ChoreTemplateCreateWithoutSubtasksInput = {
    id?: string
    title: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    household: HouseholdCreateNestedOneWithoutChoreTemplatesInput
  }

  export type ChoreTemplateUncheckedCreateWithoutSubtasksInput = {
    id?: string
    householdId: string
    title: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChoreTemplateCreateOrConnectWithoutSubtasksInput = {
    where: ChoreTemplateWhereUniqueInput
    create: XOR<ChoreTemplateCreateWithoutSubtasksInput, ChoreTemplateUncheckedCreateWithoutSubtasksInput>
  }

  export type ChoreTemplateUpsertWithoutSubtasksInput = {
    update: XOR<ChoreTemplateUpdateWithoutSubtasksInput, ChoreTemplateUncheckedUpdateWithoutSubtasksInput>
    create: XOR<ChoreTemplateCreateWithoutSubtasksInput, ChoreTemplateUncheckedCreateWithoutSubtasksInput>
    where?: ChoreTemplateWhereInput
  }

  export type ChoreTemplateUpdateToOneWithWhereWithoutSubtasksInput = {
    where?: ChoreTemplateWhereInput
    data: XOR<ChoreTemplateUpdateWithoutSubtasksInput, ChoreTemplateUncheckedUpdateWithoutSubtasksInput>
  }

  export type ChoreTemplateUpdateWithoutSubtasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    household?: HouseholdUpdateOneRequiredWithoutChoreTemplatesNestedInput
  }

  export type ChoreTemplateUncheckedUpdateWithoutSubtasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChoreCreateWithoutHistoryInput = {
    id?: string
    title: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dueDate?: Date | string | null
    status?: $Enums.ChoreStatus
    priority?: number | null
    deletedAt?: Date | string | null
    household: HouseholdCreateNestedOneWithoutChoresInput
    subtasks?: SubtaskCreateNestedManyWithoutChoreInput
    assignedUsers?: ChoreAssignmentCreateNestedManyWithoutChoreInput
    event?: EventCreateNestedOneWithoutChoreInput
    choreSwapRequests?: ChoreSwapRequestCreateNestedManyWithoutChoreInput
    recurrenceRule?: RecurrenceRuleCreateNestedOneWithoutChoresInput
  }

  export type ChoreUncheckedCreateWithoutHistoryInput = {
    id?: string
    householdId: string
    title: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dueDate?: Date | string | null
    status?: $Enums.ChoreStatus
    priority?: number | null
    eventId?: string | null
    recurrenceRuleId?: string | null
    deletedAt?: Date | string | null
    subtasks?: SubtaskUncheckedCreateNestedManyWithoutChoreInput
    assignedUsers?: ChoreAssignmentUncheckedCreateNestedManyWithoutChoreInput
    choreSwapRequests?: ChoreSwapRequestUncheckedCreateNestedManyWithoutChoreInput
  }

  export type ChoreCreateOrConnectWithoutHistoryInput = {
    where: ChoreWhereUniqueInput
    create: XOR<ChoreCreateWithoutHistoryInput, ChoreUncheckedCreateWithoutHistoryInput>
  }

  export type UserCreateWithoutChoreHistoryInput = {
    id?: string
    email: string
    passwordHash?: string | null
    name: string
    profileImageURL?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deviceTokens?: UserCreatedeviceTokensInput | string[]
    deletedAt?: Date | string | null
    households?: HouseholdMemberCreateNestedManyWithoutUserInput
    messages?: MessageCreateNestedManyWithoutAuthorInput
    threads?: ThreadCreateNestedManyWithoutAuthorInput
    assignedChores?: ChoreAssignmentCreateNestedManyWithoutUserInput
    expensesPaid?: ExpenseCreateNestedManyWithoutPaidByInput
    expenseSplits?: ExpenseSplitCreateNestedManyWithoutUserInput
    transactionsFrom?: TransactionCreateNestedManyWithoutFromUserInput
    transactionsTo?: TransactionCreateNestedManyWithoutToUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    oauthIntegrations?: OAuthIntegrationCreateNestedManyWithoutUserInput
    eventsCreated?: EventCreateNestedManyWithoutCreatedByInput
    choreSwapRequestsInitiated?: ChoreSwapRequestCreateNestedManyWithoutRequestingUserInput
    choreSwapRequestsReceived?: ChoreSwapRequestCreateNestedManyWithoutTargetUserInput
    reactions?: ReactionCreateNestedManyWithoutUserInput
    mentions?: MentionCreateNestedManyWithoutUserInput
    notificationSettings?: NotificationSettingsCreateNestedManyWithoutUserInput
    calendarEventHistory?: CalendarEventHistoryCreateNestedManyWithoutUserInput
    expenseHistory?: ExpenseHistoryCreateNestedManyWithoutUserInput
    messageReads?: MessageReadCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutChoreHistoryInput = {
    id?: string
    email: string
    passwordHash?: string | null
    name: string
    profileImageURL?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deviceTokens?: UserCreatedeviceTokensInput | string[]
    deletedAt?: Date | string | null
    households?: HouseholdMemberUncheckedCreateNestedManyWithoutUserInput
    messages?: MessageUncheckedCreateNestedManyWithoutAuthorInput
    threads?: ThreadUncheckedCreateNestedManyWithoutAuthorInput
    assignedChores?: ChoreAssignmentUncheckedCreateNestedManyWithoutUserInput
    expensesPaid?: ExpenseUncheckedCreateNestedManyWithoutPaidByInput
    expenseSplits?: ExpenseSplitUncheckedCreateNestedManyWithoutUserInput
    transactionsFrom?: TransactionUncheckedCreateNestedManyWithoutFromUserInput
    transactionsTo?: TransactionUncheckedCreateNestedManyWithoutToUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    oauthIntegrations?: OAuthIntegrationUncheckedCreateNestedManyWithoutUserInput
    eventsCreated?: EventUncheckedCreateNestedManyWithoutCreatedByInput
    choreSwapRequestsInitiated?: ChoreSwapRequestUncheckedCreateNestedManyWithoutRequestingUserInput
    choreSwapRequestsReceived?: ChoreSwapRequestUncheckedCreateNestedManyWithoutTargetUserInput
    reactions?: ReactionUncheckedCreateNestedManyWithoutUserInput
    mentions?: MentionUncheckedCreateNestedManyWithoutUserInput
    notificationSettings?: NotificationSettingsUncheckedCreateNestedManyWithoutUserInput
    calendarEventHistory?: CalendarEventHistoryUncheckedCreateNestedManyWithoutUserInput
    expenseHistory?: ExpenseHistoryUncheckedCreateNestedManyWithoutUserInput
    messageReads?: MessageReadUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutChoreHistoryInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutChoreHistoryInput, UserUncheckedCreateWithoutChoreHistoryInput>
  }

  export type ChoreUpsertWithoutHistoryInput = {
    update: XOR<ChoreUpdateWithoutHistoryInput, ChoreUncheckedUpdateWithoutHistoryInput>
    create: XOR<ChoreCreateWithoutHistoryInput, ChoreUncheckedCreateWithoutHistoryInput>
    where?: ChoreWhereInput
  }

  export type ChoreUpdateToOneWithWhereWithoutHistoryInput = {
    where?: ChoreWhereInput
    data: XOR<ChoreUpdateWithoutHistoryInput, ChoreUncheckedUpdateWithoutHistoryInput>
  }

  export type ChoreUpdateWithoutHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumChoreStatusFieldUpdateOperationsInput | $Enums.ChoreStatus
    priority?: NullableIntFieldUpdateOperationsInput | number | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    household?: HouseholdUpdateOneRequiredWithoutChoresNestedInput
    subtasks?: SubtaskUpdateManyWithoutChoreNestedInput
    assignedUsers?: ChoreAssignmentUpdateManyWithoutChoreNestedInput
    event?: EventUpdateOneWithoutChoreNestedInput
    choreSwapRequests?: ChoreSwapRequestUpdateManyWithoutChoreNestedInput
    recurrenceRule?: RecurrenceRuleUpdateOneWithoutChoresNestedInput
  }

  export type ChoreUncheckedUpdateWithoutHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumChoreStatusFieldUpdateOperationsInput | $Enums.ChoreStatus
    priority?: NullableIntFieldUpdateOperationsInput | number | null
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    recurrenceRuleId?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtasks?: SubtaskUncheckedUpdateManyWithoutChoreNestedInput
    assignedUsers?: ChoreAssignmentUncheckedUpdateManyWithoutChoreNestedInput
    choreSwapRequests?: ChoreSwapRequestUncheckedUpdateManyWithoutChoreNestedInput
  }

  export type UserUpsertWithoutChoreHistoryInput = {
    update: XOR<UserUpdateWithoutChoreHistoryInput, UserUncheckedUpdateWithoutChoreHistoryInput>
    create: XOR<UserCreateWithoutChoreHistoryInput, UserUncheckedCreateWithoutChoreHistoryInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutChoreHistoryInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutChoreHistoryInput, UserUncheckedUpdateWithoutChoreHistoryInput>
  }

  export type UserUpdateWithoutChoreHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    profileImageURL?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deviceTokens?: UserUpdatedeviceTokensInput | string[]
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    households?: HouseholdMemberUpdateManyWithoutUserNestedInput
    messages?: MessageUpdateManyWithoutAuthorNestedInput
    threads?: ThreadUpdateManyWithoutAuthorNestedInput
    assignedChores?: ChoreAssignmentUpdateManyWithoutUserNestedInput
    expensesPaid?: ExpenseUpdateManyWithoutPaidByNestedInput
    expenseSplits?: ExpenseSplitUpdateManyWithoutUserNestedInput
    transactionsFrom?: TransactionUpdateManyWithoutFromUserNestedInput
    transactionsTo?: TransactionUpdateManyWithoutToUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    oauthIntegrations?: OAuthIntegrationUpdateManyWithoutUserNestedInput
    eventsCreated?: EventUpdateManyWithoutCreatedByNestedInput
    choreSwapRequestsInitiated?: ChoreSwapRequestUpdateManyWithoutRequestingUserNestedInput
    choreSwapRequestsReceived?: ChoreSwapRequestUpdateManyWithoutTargetUserNestedInput
    reactions?: ReactionUpdateManyWithoutUserNestedInput
    mentions?: MentionUpdateManyWithoutUserNestedInput
    notificationSettings?: NotificationSettingsUpdateManyWithoutUserNestedInput
    calendarEventHistory?: CalendarEventHistoryUpdateManyWithoutUserNestedInput
    expenseHistory?: ExpenseHistoryUpdateManyWithoutUserNestedInput
    messageReads?: MessageReadUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutChoreHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    profileImageURL?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deviceTokens?: UserUpdatedeviceTokensInput | string[]
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    households?: HouseholdMemberUncheckedUpdateManyWithoutUserNestedInput
    messages?: MessageUncheckedUpdateManyWithoutAuthorNestedInput
    threads?: ThreadUncheckedUpdateManyWithoutAuthorNestedInput
    assignedChores?: ChoreAssignmentUncheckedUpdateManyWithoutUserNestedInput
    expensesPaid?: ExpenseUncheckedUpdateManyWithoutPaidByNestedInput
    expenseSplits?: ExpenseSplitUncheckedUpdateManyWithoutUserNestedInput
    transactionsFrom?: TransactionUncheckedUpdateManyWithoutFromUserNestedInput
    transactionsTo?: TransactionUncheckedUpdateManyWithoutToUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    oauthIntegrations?: OAuthIntegrationUncheckedUpdateManyWithoutUserNestedInput
    eventsCreated?: EventUncheckedUpdateManyWithoutCreatedByNestedInput
    choreSwapRequestsInitiated?: ChoreSwapRequestUncheckedUpdateManyWithoutRequestingUserNestedInput
    choreSwapRequestsReceived?: ChoreSwapRequestUncheckedUpdateManyWithoutTargetUserNestedInput
    reactions?: ReactionUncheckedUpdateManyWithoutUserNestedInput
    mentions?: MentionUncheckedUpdateManyWithoutUserNestedInput
    notificationSettings?: NotificationSettingsUncheckedUpdateManyWithoutUserNestedInput
    calendarEventHistory?: CalendarEventHistoryUncheckedUpdateManyWithoutUserNestedInput
    expenseHistory?: ExpenseHistoryUncheckedUpdateManyWithoutUserNestedInput
    messageReads?: MessageReadUncheckedUpdateManyWithoutUserNestedInput
  }

  export type HouseholdCreateWithoutExpensesInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    currency?: string
    icon?: string | null
    timezone?: string
    language?: string
    deletedAt?: Date | string | null
    members?: HouseholdMemberCreateNestedManyWithoutHouseholdInput
    threads?: ThreadCreateNestedManyWithoutHouseholdInput
    chores?: ChoreCreateNestedManyWithoutHouseholdInput
    events?: EventCreateNestedManyWithoutHouseholdInput
    choreTemplates?: ChoreTemplateCreateNestedManyWithoutHouseholdInput
    notificationSettings?: NotificationSettingsCreateNestedManyWithoutHouseholdInput
  }

  export type HouseholdUncheckedCreateWithoutExpensesInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    currency?: string
    icon?: string | null
    timezone?: string
    language?: string
    deletedAt?: Date | string | null
    members?: HouseholdMemberUncheckedCreateNestedManyWithoutHouseholdInput
    threads?: ThreadUncheckedCreateNestedManyWithoutHouseholdInput
    chores?: ChoreUncheckedCreateNestedManyWithoutHouseholdInput
    events?: EventUncheckedCreateNestedManyWithoutHouseholdInput
    choreTemplates?: ChoreTemplateUncheckedCreateNestedManyWithoutHouseholdInput
    notificationSettings?: NotificationSettingsUncheckedCreateNestedManyWithoutHouseholdInput
  }

  export type HouseholdCreateOrConnectWithoutExpensesInput = {
    where: HouseholdWhereUniqueInput
    create: XOR<HouseholdCreateWithoutExpensesInput, HouseholdUncheckedCreateWithoutExpensesInput>
  }

  export type UserCreateWithoutExpensesPaidInput = {
    id?: string
    email: string
    passwordHash?: string | null
    name: string
    profileImageURL?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deviceTokens?: UserCreatedeviceTokensInput | string[]
    deletedAt?: Date | string | null
    households?: HouseholdMemberCreateNestedManyWithoutUserInput
    messages?: MessageCreateNestedManyWithoutAuthorInput
    threads?: ThreadCreateNestedManyWithoutAuthorInput
    assignedChores?: ChoreAssignmentCreateNestedManyWithoutUserInput
    expenseSplits?: ExpenseSplitCreateNestedManyWithoutUserInput
    transactionsFrom?: TransactionCreateNestedManyWithoutFromUserInput
    transactionsTo?: TransactionCreateNestedManyWithoutToUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    oauthIntegrations?: OAuthIntegrationCreateNestedManyWithoutUserInput
    eventsCreated?: EventCreateNestedManyWithoutCreatedByInput
    choreSwapRequestsInitiated?: ChoreSwapRequestCreateNestedManyWithoutRequestingUserInput
    choreSwapRequestsReceived?: ChoreSwapRequestCreateNestedManyWithoutTargetUserInput
    reactions?: ReactionCreateNestedManyWithoutUserInput
    mentions?: MentionCreateNestedManyWithoutUserInput
    choreHistory?: ChoreHistoryCreateNestedManyWithoutUserInput
    notificationSettings?: NotificationSettingsCreateNestedManyWithoutUserInput
    calendarEventHistory?: CalendarEventHistoryCreateNestedManyWithoutUserInput
    expenseHistory?: ExpenseHistoryCreateNestedManyWithoutUserInput
    messageReads?: MessageReadCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutExpensesPaidInput = {
    id?: string
    email: string
    passwordHash?: string | null
    name: string
    profileImageURL?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deviceTokens?: UserCreatedeviceTokensInput | string[]
    deletedAt?: Date | string | null
    households?: HouseholdMemberUncheckedCreateNestedManyWithoutUserInput
    messages?: MessageUncheckedCreateNestedManyWithoutAuthorInput
    threads?: ThreadUncheckedCreateNestedManyWithoutAuthorInput
    assignedChores?: ChoreAssignmentUncheckedCreateNestedManyWithoutUserInput
    expenseSplits?: ExpenseSplitUncheckedCreateNestedManyWithoutUserInput
    transactionsFrom?: TransactionUncheckedCreateNestedManyWithoutFromUserInput
    transactionsTo?: TransactionUncheckedCreateNestedManyWithoutToUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    oauthIntegrations?: OAuthIntegrationUncheckedCreateNestedManyWithoutUserInput
    eventsCreated?: EventUncheckedCreateNestedManyWithoutCreatedByInput
    choreSwapRequestsInitiated?: ChoreSwapRequestUncheckedCreateNestedManyWithoutRequestingUserInput
    choreSwapRequestsReceived?: ChoreSwapRequestUncheckedCreateNestedManyWithoutTargetUserInput
    reactions?: ReactionUncheckedCreateNestedManyWithoutUserInput
    mentions?: MentionUncheckedCreateNestedManyWithoutUserInput
    choreHistory?: ChoreHistoryUncheckedCreateNestedManyWithoutUserInput
    notificationSettings?: NotificationSettingsUncheckedCreateNestedManyWithoutUserInput
    calendarEventHistory?: CalendarEventHistoryUncheckedCreateNestedManyWithoutUserInput
    expenseHistory?: ExpenseHistoryUncheckedCreateNestedManyWithoutUserInput
    messageReads?: MessageReadUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutExpensesPaidInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutExpensesPaidInput, UserUncheckedCreateWithoutExpensesPaidInput>
  }

  export type ExpenseSplitCreateWithoutExpenseInput = {
    id?: string
    amount: number
    user: UserCreateNestedOneWithoutExpenseSplitsInput
  }

  export type ExpenseSplitUncheckedCreateWithoutExpenseInput = {
    id?: string
    userId: string
    amount: number
  }

  export type ExpenseSplitCreateOrConnectWithoutExpenseInput = {
    where: ExpenseSplitWhereUniqueInput
    create: XOR<ExpenseSplitCreateWithoutExpenseInput, ExpenseSplitUncheckedCreateWithoutExpenseInput>
  }

  export type ExpenseSplitCreateManyExpenseInputEnvelope = {
    data: ExpenseSplitCreateManyExpenseInput | ExpenseSplitCreateManyExpenseInput[]
    skipDuplicates?: boolean
  }

  export type TransactionCreateWithoutExpenseInput = {
    id?: string
    amount: number
    status?: $Enums.TransactionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    fromUser: UserCreateNestedOneWithoutTransactionsFromInput
    toUser: UserCreateNestedOneWithoutTransactionsToInput
  }

  export type TransactionUncheckedCreateWithoutExpenseInput = {
    id?: string
    fromUserId: string
    toUserId: string
    amount: number
    status?: $Enums.TransactionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type TransactionCreateOrConnectWithoutExpenseInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutExpenseInput, TransactionUncheckedCreateWithoutExpenseInput>
  }

  export type TransactionCreateManyExpenseInputEnvelope = {
    data: TransactionCreateManyExpenseInput | TransactionCreateManyExpenseInput[]
    skipDuplicates?: boolean
  }

  export type ReceiptCreateWithoutExpenseInput = {
    id?: string
    url: string
    fileType: string
    createdAt?: Date | string
  }

  export type ReceiptUncheckedCreateWithoutExpenseInput = {
    id?: string
    url: string
    fileType: string
    createdAt?: Date | string
  }

  export type ReceiptCreateOrConnectWithoutExpenseInput = {
    where: ReceiptWhereUniqueInput
    create: XOR<ReceiptCreateWithoutExpenseInput, ReceiptUncheckedCreateWithoutExpenseInput>
  }

  export type ReceiptCreateManyExpenseInputEnvelope = {
    data: ReceiptCreateManyExpenseInput | ReceiptCreateManyExpenseInput[]
    skipDuplicates?: boolean
  }

  export type ExpenseHistoryCreateWithoutExpenseInput = {
    id?: string
    action: $Enums.ExpenseAction
    changedAt?: Date | string
    user: UserCreateNestedOneWithoutExpenseHistoryInput
  }

  export type ExpenseHistoryUncheckedCreateWithoutExpenseInput = {
    id?: string
    action: $Enums.ExpenseAction
    changedById: string
    changedAt?: Date | string
  }

  export type ExpenseHistoryCreateOrConnectWithoutExpenseInput = {
    where: ExpenseHistoryWhereUniqueInput
    create: XOR<ExpenseHistoryCreateWithoutExpenseInput, ExpenseHistoryUncheckedCreateWithoutExpenseInput>
  }

  export type ExpenseHistoryCreateManyExpenseInputEnvelope = {
    data: ExpenseHistoryCreateManyExpenseInput | ExpenseHistoryCreateManyExpenseInput[]
    skipDuplicates?: boolean
  }

  export type HouseholdUpsertWithoutExpensesInput = {
    update: XOR<HouseholdUpdateWithoutExpensesInput, HouseholdUncheckedUpdateWithoutExpensesInput>
    create: XOR<HouseholdCreateWithoutExpensesInput, HouseholdUncheckedCreateWithoutExpensesInput>
    where?: HouseholdWhereInput
  }

  export type HouseholdUpdateToOneWithWhereWithoutExpensesInput = {
    where?: HouseholdWhereInput
    data: XOR<HouseholdUpdateWithoutExpensesInput, HouseholdUncheckedUpdateWithoutExpensesInput>
  }

  export type HouseholdUpdateWithoutExpensesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    members?: HouseholdMemberUpdateManyWithoutHouseholdNestedInput
    threads?: ThreadUpdateManyWithoutHouseholdNestedInput
    chores?: ChoreUpdateManyWithoutHouseholdNestedInput
    events?: EventUpdateManyWithoutHouseholdNestedInput
    choreTemplates?: ChoreTemplateUpdateManyWithoutHouseholdNestedInput
    notificationSettings?: NotificationSettingsUpdateManyWithoutHouseholdNestedInput
  }

  export type HouseholdUncheckedUpdateWithoutExpensesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    members?: HouseholdMemberUncheckedUpdateManyWithoutHouseholdNestedInput
    threads?: ThreadUncheckedUpdateManyWithoutHouseholdNestedInput
    chores?: ChoreUncheckedUpdateManyWithoutHouseholdNestedInput
    events?: EventUncheckedUpdateManyWithoutHouseholdNestedInput
    choreTemplates?: ChoreTemplateUncheckedUpdateManyWithoutHouseholdNestedInput
    notificationSettings?: NotificationSettingsUncheckedUpdateManyWithoutHouseholdNestedInput
  }

  export type UserUpsertWithoutExpensesPaidInput = {
    update: XOR<UserUpdateWithoutExpensesPaidInput, UserUncheckedUpdateWithoutExpensesPaidInput>
    create: XOR<UserCreateWithoutExpensesPaidInput, UserUncheckedCreateWithoutExpensesPaidInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutExpensesPaidInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutExpensesPaidInput, UserUncheckedUpdateWithoutExpensesPaidInput>
  }

  export type UserUpdateWithoutExpensesPaidInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    profileImageURL?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deviceTokens?: UserUpdatedeviceTokensInput | string[]
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    households?: HouseholdMemberUpdateManyWithoutUserNestedInput
    messages?: MessageUpdateManyWithoutAuthorNestedInput
    threads?: ThreadUpdateManyWithoutAuthorNestedInput
    assignedChores?: ChoreAssignmentUpdateManyWithoutUserNestedInput
    expenseSplits?: ExpenseSplitUpdateManyWithoutUserNestedInput
    transactionsFrom?: TransactionUpdateManyWithoutFromUserNestedInput
    transactionsTo?: TransactionUpdateManyWithoutToUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    oauthIntegrations?: OAuthIntegrationUpdateManyWithoutUserNestedInput
    eventsCreated?: EventUpdateManyWithoutCreatedByNestedInput
    choreSwapRequestsInitiated?: ChoreSwapRequestUpdateManyWithoutRequestingUserNestedInput
    choreSwapRequestsReceived?: ChoreSwapRequestUpdateManyWithoutTargetUserNestedInput
    reactions?: ReactionUpdateManyWithoutUserNestedInput
    mentions?: MentionUpdateManyWithoutUserNestedInput
    choreHistory?: ChoreHistoryUpdateManyWithoutUserNestedInput
    notificationSettings?: NotificationSettingsUpdateManyWithoutUserNestedInput
    calendarEventHistory?: CalendarEventHistoryUpdateManyWithoutUserNestedInput
    expenseHistory?: ExpenseHistoryUpdateManyWithoutUserNestedInput
    messageReads?: MessageReadUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutExpensesPaidInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    profileImageURL?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deviceTokens?: UserUpdatedeviceTokensInput | string[]
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    households?: HouseholdMemberUncheckedUpdateManyWithoutUserNestedInput
    messages?: MessageUncheckedUpdateManyWithoutAuthorNestedInput
    threads?: ThreadUncheckedUpdateManyWithoutAuthorNestedInput
    assignedChores?: ChoreAssignmentUncheckedUpdateManyWithoutUserNestedInput
    expenseSplits?: ExpenseSplitUncheckedUpdateManyWithoutUserNestedInput
    transactionsFrom?: TransactionUncheckedUpdateManyWithoutFromUserNestedInput
    transactionsTo?: TransactionUncheckedUpdateManyWithoutToUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    oauthIntegrations?: OAuthIntegrationUncheckedUpdateManyWithoutUserNestedInput
    eventsCreated?: EventUncheckedUpdateManyWithoutCreatedByNestedInput
    choreSwapRequestsInitiated?: ChoreSwapRequestUncheckedUpdateManyWithoutRequestingUserNestedInput
    choreSwapRequestsReceived?: ChoreSwapRequestUncheckedUpdateManyWithoutTargetUserNestedInput
    reactions?: ReactionUncheckedUpdateManyWithoutUserNestedInput
    mentions?: MentionUncheckedUpdateManyWithoutUserNestedInput
    choreHistory?: ChoreHistoryUncheckedUpdateManyWithoutUserNestedInput
    notificationSettings?: NotificationSettingsUncheckedUpdateManyWithoutUserNestedInput
    calendarEventHistory?: CalendarEventHistoryUncheckedUpdateManyWithoutUserNestedInput
    expenseHistory?: ExpenseHistoryUncheckedUpdateManyWithoutUserNestedInput
    messageReads?: MessageReadUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ExpenseSplitUpsertWithWhereUniqueWithoutExpenseInput = {
    where: ExpenseSplitWhereUniqueInput
    update: XOR<ExpenseSplitUpdateWithoutExpenseInput, ExpenseSplitUncheckedUpdateWithoutExpenseInput>
    create: XOR<ExpenseSplitCreateWithoutExpenseInput, ExpenseSplitUncheckedCreateWithoutExpenseInput>
  }

  export type ExpenseSplitUpdateWithWhereUniqueWithoutExpenseInput = {
    where: ExpenseSplitWhereUniqueInput
    data: XOR<ExpenseSplitUpdateWithoutExpenseInput, ExpenseSplitUncheckedUpdateWithoutExpenseInput>
  }

  export type ExpenseSplitUpdateManyWithWhereWithoutExpenseInput = {
    where: ExpenseSplitScalarWhereInput
    data: XOR<ExpenseSplitUpdateManyMutationInput, ExpenseSplitUncheckedUpdateManyWithoutExpenseInput>
  }

  export type TransactionUpsertWithWhereUniqueWithoutExpenseInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutExpenseInput, TransactionUncheckedUpdateWithoutExpenseInput>
    create: XOR<TransactionCreateWithoutExpenseInput, TransactionUncheckedCreateWithoutExpenseInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutExpenseInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutExpenseInput, TransactionUncheckedUpdateWithoutExpenseInput>
  }

  export type TransactionUpdateManyWithWhereWithoutExpenseInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutExpenseInput>
  }

  export type ReceiptUpsertWithWhereUniqueWithoutExpenseInput = {
    where: ReceiptWhereUniqueInput
    update: XOR<ReceiptUpdateWithoutExpenseInput, ReceiptUncheckedUpdateWithoutExpenseInput>
    create: XOR<ReceiptCreateWithoutExpenseInput, ReceiptUncheckedCreateWithoutExpenseInput>
  }

  export type ReceiptUpdateWithWhereUniqueWithoutExpenseInput = {
    where: ReceiptWhereUniqueInput
    data: XOR<ReceiptUpdateWithoutExpenseInput, ReceiptUncheckedUpdateWithoutExpenseInput>
  }

  export type ReceiptUpdateManyWithWhereWithoutExpenseInput = {
    where: ReceiptScalarWhereInput
    data: XOR<ReceiptUpdateManyMutationInput, ReceiptUncheckedUpdateManyWithoutExpenseInput>
  }

  export type ReceiptScalarWhereInput = {
    AND?: ReceiptScalarWhereInput | ReceiptScalarWhereInput[]
    OR?: ReceiptScalarWhereInput[]
    NOT?: ReceiptScalarWhereInput | ReceiptScalarWhereInput[]
    id?: StringFilter<"Receipt"> | string
    expenseId?: StringFilter<"Receipt"> | string
    url?: StringFilter<"Receipt"> | string
    fileType?: StringFilter<"Receipt"> | string
    createdAt?: DateTimeFilter<"Receipt"> | Date | string
  }

  export type ExpenseHistoryUpsertWithWhereUniqueWithoutExpenseInput = {
    where: ExpenseHistoryWhereUniqueInput
    update: XOR<ExpenseHistoryUpdateWithoutExpenseInput, ExpenseHistoryUncheckedUpdateWithoutExpenseInput>
    create: XOR<ExpenseHistoryCreateWithoutExpenseInput, ExpenseHistoryUncheckedCreateWithoutExpenseInput>
  }

  export type ExpenseHistoryUpdateWithWhereUniqueWithoutExpenseInput = {
    where: ExpenseHistoryWhereUniqueInput
    data: XOR<ExpenseHistoryUpdateWithoutExpenseInput, ExpenseHistoryUncheckedUpdateWithoutExpenseInput>
  }

  export type ExpenseHistoryUpdateManyWithWhereWithoutExpenseInput = {
    where: ExpenseHistoryScalarWhereInput
    data: XOR<ExpenseHistoryUpdateManyMutationInput, ExpenseHistoryUncheckedUpdateManyWithoutExpenseInput>
  }

  export type ExpenseCreateWithoutSplitsInput = {
    id?: string
    amount: number
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    dueDate?: Date | string | null
    deletedAt?: Date | string | null
    category: $Enums.ExpenseCategory
    household: HouseholdCreateNestedOneWithoutExpensesInput
    paidBy: UserCreateNestedOneWithoutExpensesPaidInput
    transactions?: TransactionCreateNestedManyWithoutExpenseInput
    receipts?: ReceiptCreateNestedManyWithoutExpenseInput
    history?: ExpenseHistoryCreateNestedManyWithoutExpenseInput
  }

  export type ExpenseUncheckedCreateWithoutSplitsInput = {
    id?: string
    householdId: string
    amount: number
    description: string
    paidById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    dueDate?: Date | string | null
    deletedAt?: Date | string | null
    category: $Enums.ExpenseCategory
    transactions?: TransactionUncheckedCreateNestedManyWithoutExpenseInput
    receipts?: ReceiptUncheckedCreateNestedManyWithoutExpenseInput
    history?: ExpenseHistoryUncheckedCreateNestedManyWithoutExpenseInput
  }

  export type ExpenseCreateOrConnectWithoutSplitsInput = {
    where: ExpenseWhereUniqueInput
    create: XOR<ExpenseCreateWithoutSplitsInput, ExpenseUncheckedCreateWithoutSplitsInput>
  }

  export type UserCreateWithoutExpenseSplitsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    name: string
    profileImageURL?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deviceTokens?: UserCreatedeviceTokensInput | string[]
    deletedAt?: Date | string | null
    households?: HouseholdMemberCreateNestedManyWithoutUserInput
    messages?: MessageCreateNestedManyWithoutAuthorInput
    threads?: ThreadCreateNestedManyWithoutAuthorInput
    assignedChores?: ChoreAssignmentCreateNestedManyWithoutUserInput
    expensesPaid?: ExpenseCreateNestedManyWithoutPaidByInput
    transactionsFrom?: TransactionCreateNestedManyWithoutFromUserInput
    transactionsTo?: TransactionCreateNestedManyWithoutToUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    oauthIntegrations?: OAuthIntegrationCreateNestedManyWithoutUserInput
    eventsCreated?: EventCreateNestedManyWithoutCreatedByInput
    choreSwapRequestsInitiated?: ChoreSwapRequestCreateNestedManyWithoutRequestingUserInput
    choreSwapRequestsReceived?: ChoreSwapRequestCreateNestedManyWithoutTargetUserInput
    reactions?: ReactionCreateNestedManyWithoutUserInput
    mentions?: MentionCreateNestedManyWithoutUserInput
    choreHistory?: ChoreHistoryCreateNestedManyWithoutUserInput
    notificationSettings?: NotificationSettingsCreateNestedManyWithoutUserInput
    calendarEventHistory?: CalendarEventHistoryCreateNestedManyWithoutUserInput
    expenseHistory?: ExpenseHistoryCreateNestedManyWithoutUserInput
    messageReads?: MessageReadCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutExpenseSplitsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    name: string
    profileImageURL?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deviceTokens?: UserCreatedeviceTokensInput | string[]
    deletedAt?: Date | string | null
    households?: HouseholdMemberUncheckedCreateNestedManyWithoutUserInput
    messages?: MessageUncheckedCreateNestedManyWithoutAuthorInput
    threads?: ThreadUncheckedCreateNestedManyWithoutAuthorInput
    assignedChores?: ChoreAssignmentUncheckedCreateNestedManyWithoutUserInput
    expensesPaid?: ExpenseUncheckedCreateNestedManyWithoutPaidByInput
    transactionsFrom?: TransactionUncheckedCreateNestedManyWithoutFromUserInput
    transactionsTo?: TransactionUncheckedCreateNestedManyWithoutToUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    oauthIntegrations?: OAuthIntegrationUncheckedCreateNestedManyWithoutUserInput
    eventsCreated?: EventUncheckedCreateNestedManyWithoutCreatedByInput
    choreSwapRequestsInitiated?: ChoreSwapRequestUncheckedCreateNestedManyWithoutRequestingUserInput
    choreSwapRequestsReceived?: ChoreSwapRequestUncheckedCreateNestedManyWithoutTargetUserInput
    reactions?: ReactionUncheckedCreateNestedManyWithoutUserInput
    mentions?: MentionUncheckedCreateNestedManyWithoutUserInput
    choreHistory?: ChoreHistoryUncheckedCreateNestedManyWithoutUserInput
    notificationSettings?: NotificationSettingsUncheckedCreateNestedManyWithoutUserInput
    calendarEventHistory?: CalendarEventHistoryUncheckedCreateNestedManyWithoutUserInput
    expenseHistory?: ExpenseHistoryUncheckedCreateNestedManyWithoutUserInput
    messageReads?: MessageReadUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutExpenseSplitsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutExpenseSplitsInput, UserUncheckedCreateWithoutExpenseSplitsInput>
  }

  export type ExpenseUpsertWithoutSplitsInput = {
    update: XOR<ExpenseUpdateWithoutSplitsInput, ExpenseUncheckedUpdateWithoutSplitsInput>
    create: XOR<ExpenseCreateWithoutSplitsInput, ExpenseUncheckedCreateWithoutSplitsInput>
    where?: ExpenseWhereInput
  }

  export type ExpenseUpdateToOneWithWhereWithoutSplitsInput = {
    where?: ExpenseWhereInput
    data: XOR<ExpenseUpdateWithoutSplitsInput, ExpenseUncheckedUpdateWithoutSplitsInput>
  }

  export type ExpenseUpdateWithoutSplitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: EnumExpenseCategoryFieldUpdateOperationsInput | $Enums.ExpenseCategory
    household?: HouseholdUpdateOneRequiredWithoutExpensesNestedInput
    paidBy?: UserUpdateOneRequiredWithoutExpensesPaidNestedInput
    transactions?: TransactionUpdateManyWithoutExpenseNestedInput
    receipts?: ReceiptUpdateManyWithoutExpenseNestedInput
    history?: ExpenseHistoryUpdateManyWithoutExpenseNestedInput
  }

  export type ExpenseUncheckedUpdateWithoutSplitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    paidById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: EnumExpenseCategoryFieldUpdateOperationsInput | $Enums.ExpenseCategory
    transactions?: TransactionUncheckedUpdateManyWithoutExpenseNestedInput
    receipts?: ReceiptUncheckedUpdateManyWithoutExpenseNestedInput
    history?: ExpenseHistoryUncheckedUpdateManyWithoutExpenseNestedInput
  }

  export type UserUpsertWithoutExpenseSplitsInput = {
    update: XOR<UserUpdateWithoutExpenseSplitsInput, UserUncheckedUpdateWithoutExpenseSplitsInput>
    create: XOR<UserCreateWithoutExpenseSplitsInput, UserUncheckedCreateWithoutExpenseSplitsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutExpenseSplitsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutExpenseSplitsInput, UserUncheckedUpdateWithoutExpenseSplitsInput>
  }

  export type UserUpdateWithoutExpenseSplitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    profileImageURL?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deviceTokens?: UserUpdatedeviceTokensInput | string[]
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    households?: HouseholdMemberUpdateManyWithoutUserNestedInput
    messages?: MessageUpdateManyWithoutAuthorNestedInput
    threads?: ThreadUpdateManyWithoutAuthorNestedInput
    assignedChores?: ChoreAssignmentUpdateManyWithoutUserNestedInput
    expensesPaid?: ExpenseUpdateManyWithoutPaidByNestedInput
    transactionsFrom?: TransactionUpdateManyWithoutFromUserNestedInput
    transactionsTo?: TransactionUpdateManyWithoutToUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    oauthIntegrations?: OAuthIntegrationUpdateManyWithoutUserNestedInput
    eventsCreated?: EventUpdateManyWithoutCreatedByNestedInput
    choreSwapRequestsInitiated?: ChoreSwapRequestUpdateManyWithoutRequestingUserNestedInput
    choreSwapRequestsReceived?: ChoreSwapRequestUpdateManyWithoutTargetUserNestedInput
    reactions?: ReactionUpdateManyWithoutUserNestedInput
    mentions?: MentionUpdateManyWithoutUserNestedInput
    choreHistory?: ChoreHistoryUpdateManyWithoutUserNestedInput
    notificationSettings?: NotificationSettingsUpdateManyWithoutUserNestedInput
    calendarEventHistory?: CalendarEventHistoryUpdateManyWithoutUserNestedInput
    expenseHistory?: ExpenseHistoryUpdateManyWithoutUserNestedInput
    messageReads?: MessageReadUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutExpenseSplitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    profileImageURL?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deviceTokens?: UserUpdatedeviceTokensInput | string[]
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    households?: HouseholdMemberUncheckedUpdateManyWithoutUserNestedInput
    messages?: MessageUncheckedUpdateManyWithoutAuthorNestedInput
    threads?: ThreadUncheckedUpdateManyWithoutAuthorNestedInput
    assignedChores?: ChoreAssignmentUncheckedUpdateManyWithoutUserNestedInput
    expensesPaid?: ExpenseUncheckedUpdateManyWithoutPaidByNestedInput
    transactionsFrom?: TransactionUncheckedUpdateManyWithoutFromUserNestedInput
    transactionsTo?: TransactionUncheckedUpdateManyWithoutToUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    oauthIntegrations?: OAuthIntegrationUncheckedUpdateManyWithoutUserNestedInput
    eventsCreated?: EventUncheckedUpdateManyWithoutCreatedByNestedInput
    choreSwapRequestsInitiated?: ChoreSwapRequestUncheckedUpdateManyWithoutRequestingUserNestedInput
    choreSwapRequestsReceived?: ChoreSwapRequestUncheckedUpdateManyWithoutTargetUserNestedInput
    reactions?: ReactionUncheckedUpdateManyWithoutUserNestedInput
    mentions?: MentionUncheckedUpdateManyWithoutUserNestedInput
    choreHistory?: ChoreHistoryUncheckedUpdateManyWithoutUserNestedInput
    notificationSettings?: NotificationSettingsUncheckedUpdateManyWithoutUserNestedInput
    calendarEventHistory?: CalendarEventHistoryUncheckedUpdateManyWithoutUserNestedInput
    expenseHistory?: ExpenseHistoryUncheckedUpdateManyWithoutUserNestedInput
    messageReads?: MessageReadUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ExpenseCreateWithoutTransactionsInput = {
    id?: string
    amount: number
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    dueDate?: Date | string | null
    deletedAt?: Date | string | null
    category: $Enums.ExpenseCategory
    household: HouseholdCreateNestedOneWithoutExpensesInput
    paidBy: UserCreateNestedOneWithoutExpensesPaidInput
    splits?: ExpenseSplitCreateNestedManyWithoutExpenseInput
    receipts?: ReceiptCreateNestedManyWithoutExpenseInput
    history?: ExpenseHistoryCreateNestedManyWithoutExpenseInput
  }

  export type ExpenseUncheckedCreateWithoutTransactionsInput = {
    id?: string
    householdId: string
    amount: number
    description: string
    paidById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    dueDate?: Date | string | null
    deletedAt?: Date | string | null
    category: $Enums.ExpenseCategory
    splits?: ExpenseSplitUncheckedCreateNestedManyWithoutExpenseInput
    receipts?: ReceiptUncheckedCreateNestedManyWithoutExpenseInput
    history?: ExpenseHistoryUncheckedCreateNestedManyWithoutExpenseInput
  }

  export type ExpenseCreateOrConnectWithoutTransactionsInput = {
    where: ExpenseWhereUniqueInput
    create: XOR<ExpenseCreateWithoutTransactionsInput, ExpenseUncheckedCreateWithoutTransactionsInput>
  }

  export type UserCreateWithoutTransactionsFromInput = {
    id?: string
    email: string
    passwordHash?: string | null
    name: string
    profileImageURL?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deviceTokens?: UserCreatedeviceTokensInput | string[]
    deletedAt?: Date | string | null
    households?: HouseholdMemberCreateNestedManyWithoutUserInput
    messages?: MessageCreateNestedManyWithoutAuthorInput
    threads?: ThreadCreateNestedManyWithoutAuthorInput
    assignedChores?: ChoreAssignmentCreateNestedManyWithoutUserInput
    expensesPaid?: ExpenseCreateNestedManyWithoutPaidByInput
    expenseSplits?: ExpenseSplitCreateNestedManyWithoutUserInput
    transactionsTo?: TransactionCreateNestedManyWithoutToUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    oauthIntegrations?: OAuthIntegrationCreateNestedManyWithoutUserInput
    eventsCreated?: EventCreateNestedManyWithoutCreatedByInput
    choreSwapRequestsInitiated?: ChoreSwapRequestCreateNestedManyWithoutRequestingUserInput
    choreSwapRequestsReceived?: ChoreSwapRequestCreateNestedManyWithoutTargetUserInput
    reactions?: ReactionCreateNestedManyWithoutUserInput
    mentions?: MentionCreateNestedManyWithoutUserInput
    choreHistory?: ChoreHistoryCreateNestedManyWithoutUserInput
    notificationSettings?: NotificationSettingsCreateNestedManyWithoutUserInput
    calendarEventHistory?: CalendarEventHistoryCreateNestedManyWithoutUserInput
    expenseHistory?: ExpenseHistoryCreateNestedManyWithoutUserInput
    messageReads?: MessageReadCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTransactionsFromInput = {
    id?: string
    email: string
    passwordHash?: string | null
    name: string
    profileImageURL?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deviceTokens?: UserCreatedeviceTokensInput | string[]
    deletedAt?: Date | string | null
    households?: HouseholdMemberUncheckedCreateNestedManyWithoutUserInput
    messages?: MessageUncheckedCreateNestedManyWithoutAuthorInput
    threads?: ThreadUncheckedCreateNestedManyWithoutAuthorInput
    assignedChores?: ChoreAssignmentUncheckedCreateNestedManyWithoutUserInput
    expensesPaid?: ExpenseUncheckedCreateNestedManyWithoutPaidByInput
    expenseSplits?: ExpenseSplitUncheckedCreateNestedManyWithoutUserInput
    transactionsTo?: TransactionUncheckedCreateNestedManyWithoutToUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    oauthIntegrations?: OAuthIntegrationUncheckedCreateNestedManyWithoutUserInput
    eventsCreated?: EventUncheckedCreateNestedManyWithoutCreatedByInput
    choreSwapRequestsInitiated?: ChoreSwapRequestUncheckedCreateNestedManyWithoutRequestingUserInput
    choreSwapRequestsReceived?: ChoreSwapRequestUncheckedCreateNestedManyWithoutTargetUserInput
    reactions?: ReactionUncheckedCreateNestedManyWithoutUserInput
    mentions?: MentionUncheckedCreateNestedManyWithoutUserInput
    choreHistory?: ChoreHistoryUncheckedCreateNestedManyWithoutUserInput
    notificationSettings?: NotificationSettingsUncheckedCreateNestedManyWithoutUserInput
    calendarEventHistory?: CalendarEventHistoryUncheckedCreateNestedManyWithoutUserInput
    expenseHistory?: ExpenseHistoryUncheckedCreateNestedManyWithoutUserInput
    messageReads?: MessageReadUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTransactionsFromInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTransactionsFromInput, UserUncheckedCreateWithoutTransactionsFromInput>
  }

  export type UserCreateWithoutTransactionsToInput = {
    id?: string
    email: string
    passwordHash?: string | null
    name: string
    profileImageURL?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deviceTokens?: UserCreatedeviceTokensInput | string[]
    deletedAt?: Date | string | null
    households?: HouseholdMemberCreateNestedManyWithoutUserInput
    messages?: MessageCreateNestedManyWithoutAuthorInput
    threads?: ThreadCreateNestedManyWithoutAuthorInput
    assignedChores?: ChoreAssignmentCreateNestedManyWithoutUserInput
    expensesPaid?: ExpenseCreateNestedManyWithoutPaidByInput
    expenseSplits?: ExpenseSplitCreateNestedManyWithoutUserInput
    transactionsFrom?: TransactionCreateNestedManyWithoutFromUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    oauthIntegrations?: OAuthIntegrationCreateNestedManyWithoutUserInput
    eventsCreated?: EventCreateNestedManyWithoutCreatedByInput
    choreSwapRequestsInitiated?: ChoreSwapRequestCreateNestedManyWithoutRequestingUserInput
    choreSwapRequestsReceived?: ChoreSwapRequestCreateNestedManyWithoutTargetUserInput
    reactions?: ReactionCreateNestedManyWithoutUserInput
    mentions?: MentionCreateNestedManyWithoutUserInput
    choreHistory?: ChoreHistoryCreateNestedManyWithoutUserInput
    notificationSettings?: NotificationSettingsCreateNestedManyWithoutUserInput
    calendarEventHistory?: CalendarEventHistoryCreateNestedManyWithoutUserInput
    expenseHistory?: ExpenseHistoryCreateNestedManyWithoutUserInput
    messageReads?: MessageReadCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTransactionsToInput = {
    id?: string
    email: string
    passwordHash?: string | null
    name: string
    profileImageURL?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deviceTokens?: UserCreatedeviceTokensInput | string[]
    deletedAt?: Date | string | null
    households?: HouseholdMemberUncheckedCreateNestedManyWithoutUserInput
    messages?: MessageUncheckedCreateNestedManyWithoutAuthorInput
    threads?: ThreadUncheckedCreateNestedManyWithoutAuthorInput
    assignedChores?: ChoreAssignmentUncheckedCreateNestedManyWithoutUserInput
    expensesPaid?: ExpenseUncheckedCreateNestedManyWithoutPaidByInput
    expenseSplits?: ExpenseSplitUncheckedCreateNestedManyWithoutUserInput
    transactionsFrom?: TransactionUncheckedCreateNestedManyWithoutFromUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    oauthIntegrations?: OAuthIntegrationUncheckedCreateNestedManyWithoutUserInput
    eventsCreated?: EventUncheckedCreateNestedManyWithoutCreatedByInput
    choreSwapRequestsInitiated?: ChoreSwapRequestUncheckedCreateNestedManyWithoutRequestingUserInput
    choreSwapRequestsReceived?: ChoreSwapRequestUncheckedCreateNestedManyWithoutTargetUserInput
    reactions?: ReactionUncheckedCreateNestedManyWithoutUserInput
    mentions?: MentionUncheckedCreateNestedManyWithoutUserInput
    choreHistory?: ChoreHistoryUncheckedCreateNestedManyWithoutUserInput
    notificationSettings?: NotificationSettingsUncheckedCreateNestedManyWithoutUserInput
    calendarEventHistory?: CalendarEventHistoryUncheckedCreateNestedManyWithoutUserInput
    expenseHistory?: ExpenseHistoryUncheckedCreateNestedManyWithoutUserInput
    messageReads?: MessageReadUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTransactionsToInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTransactionsToInput, UserUncheckedCreateWithoutTransactionsToInput>
  }

  export type ExpenseUpsertWithoutTransactionsInput = {
    update: XOR<ExpenseUpdateWithoutTransactionsInput, ExpenseUncheckedUpdateWithoutTransactionsInput>
    create: XOR<ExpenseCreateWithoutTransactionsInput, ExpenseUncheckedCreateWithoutTransactionsInput>
    where?: ExpenseWhereInput
  }

  export type ExpenseUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: ExpenseWhereInput
    data: XOR<ExpenseUpdateWithoutTransactionsInput, ExpenseUncheckedUpdateWithoutTransactionsInput>
  }

  export type ExpenseUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: EnumExpenseCategoryFieldUpdateOperationsInput | $Enums.ExpenseCategory
    household?: HouseholdUpdateOneRequiredWithoutExpensesNestedInput
    paidBy?: UserUpdateOneRequiredWithoutExpensesPaidNestedInput
    splits?: ExpenseSplitUpdateManyWithoutExpenseNestedInput
    receipts?: ReceiptUpdateManyWithoutExpenseNestedInput
    history?: ExpenseHistoryUpdateManyWithoutExpenseNestedInput
  }

  export type ExpenseUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    paidById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: EnumExpenseCategoryFieldUpdateOperationsInput | $Enums.ExpenseCategory
    splits?: ExpenseSplitUncheckedUpdateManyWithoutExpenseNestedInput
    receipts?: ReceiptUncheckedUpdateManyWithoutExpenseNestedInput
    history?: ExpenseHistoryUncheckedUpdateManyWithoutExpenseNestedInput
  }

  export type UserUpsertWithoutTransactionsFromInput = {
    update: XOR<UserUpdateWithoutTransactionsFromInput, UserUncheckedUpdateWithoutTransactionsFromInput>
    create: XOR<UserCreateWithoutTransactionsFromInput, UserUncheckedCreateWithoutTransactionsFromInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTransactionsFromInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTransactionsFromInput, UserUncheckedUpdateWithoutTransactionsFromInput>
  }

  export type UserUpdateWithoutTransactionsFromInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    profileImageURL?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deviceTokens?: UserUpdatedeviceTokensInput | string[]
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    households?: HouseholdMemberUpdateManyWithoutUserNestedInput
    messages?: MessageUpdateManyWithoutAuthorNestedInput
    threads?: ThreadUpdateManyWithoutAuthorNestedInput
    assignedChores?: ChoreAssignmentUpdateManyWithoutUserNestedInput
    expensesPaid?: ExpenseUpdateManyWithoutPaidByNestedInput
    expenseSplits?: ExpenseSplitUpdateManyWithoutUserNestedInput
    transactionsTo?: TransactionUpdateManyWithoutToUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    oauthIntegrations?: OAuthIntegrationUpdateManyWithoutUserNestedInput
    eventsCreated?: EventUpdateManyWithoutCreatedByNestedInput
    choreSwapRequestsInitiated?: ChoreSwapRequestUpdateManyWithoutRequestingUserNestedInput
    choreSwapRequestsReceived?: ChoreSwapRequestUpdateManyWithoutTargetUserNestedInput
    reactions?: ReactionUpdateManyWithoutUserNestedInput
    mentions?: MentionUpdateManyWithoutUserNestedInput
    choreHistory?: ChoreHistoryUpdateManyWithoutUserNestedInput
    notificationSettings?: NotificationSettingsUpdateManyWithoutUserNestedInput
    calendarEventHistory?: CalendarEventHistoryUpdateManyWithoutUserNestedInput
    expenseHistory?: ExpenseHistoryUpdateManyWithoutUserNestedInput
    messageReads?: MessageReadUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTransactionsFromInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    profileImageURL?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deviceTokens?: UserUpdatedeviceTokensInput | string[]
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    households?: HouseholdMemberUncheckedUpdateManyWithoutUserNestedInput
    messages?: MessageUncheckedUpdateManyWithoutAuthorNestedInput
    threads?: ThreadUncheckedUpdateManyWithoutAuthorNestedInput
    assignedChores?: ChoreAssignmentUncheckedUpdateManyWithoutUserNestedInput
    expensesPaid?: ExpenseUncheckedUpdateManyWithoutPaidByNestedInput
    expenseSplits?: ExpenseSplitUncheckedUpdateManyWithoutUserNestedInput
    transactionsTo?: TransactionUncheckedUpdateManyWithoutToUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    oauthIntegrations?: OAuthIntegrationUncheckedUpdateManyWithoutUserNestedInput
    eventsCreated?: EventUncheckedUpdateManyWithoutCreatedByNestedInput
    choreSwapRequestsInitiated?: ChoreSwapRequestUncheckedUpdateManyWithoutRequestingUserNestedInput
    choreSwapRequestsReceived?: ChoreSwapRequestUncheckedUpdateManyWithoutTargetUserNestedInput
    reactions?: ReactionUncheckedUpdateManyWithoutUserNestedInput
    mentions?: MentionUncheckedUpdateManyWithoutUserNestedInput
    choreHistory?: ChoreHistoryUncheckedUpdateManyWithoutUserNestedInput
    notificationSettings?: NotificationSettingsUncheckedUpdateManyWithoutUserNestedInput
    calendarEventHistory?: CalendarEventHistoryUncheckedUpdateManyWithoutUserNestedInput
    expenseHistory?: ExpenseHistoryUncheckedUpdateManyWithoutUserNestedInput
    messageReads?: MessageReadUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutTransactionsToInput = {
    update: XOR<UserUpdateWithoutTransactionsToInput, UserUncheckedUpdateWithoutTransactionsToInput>
    create: XOR<UserCreateWithoutTransactionsToInput, UserUncheckedCreateWithoutTransactionsToInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTransactionsToInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTransactionsToInput, UserUncheckedUpdateWithoutTransactionsToInput>
  }

  export type UserUpdateWithoutTransactionsToInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    profileImageURL?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deviceTokens?: UserUpdatedeviceTokensInput | string[]
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    households?: HouseholdMemberUpdateManyWithoutUserNestedInput
    messages?: MessageUpdateManyWithoutAuthorNestedInput
    threads?: ThreadUpdateManyWithoutAuthorNestedInput
    assignedChores?: ChoreAssignmentUpdateManyWithoutUserNestedInput
    expensesPaid?: ExpenseUpdateManyWithoutPaidByNestedInput
    expenseSplits?: ExpenseSplitUpdateManyWithoutUserNestedInput
    transactionsFrom?: TransactionUpdateManyWithoutFromUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    oauthIntegrations?: OAuthIntegrationUpdateManyWithoutUserNestedInput
    eventsCreated?: EventUpdateManyWithoutCreatedByNestedInput
    choreSwapRequestsInitiated?: ChoreSwapRequestUpdateManyWithoutRequestingUserNestedInput
    choreSwapRequestsReceived?: ChoreSwapRequestUpdateManyWithoutTargetUserNestedInput
    reactions?: ReactionUpdateManyWithoutUserNestedInput
    mentions?: MentionUpdateManyWithoutUserNestedInput
    choreHistory?: ChoreHistoryUpdateManyWithoutUserNestedInput
    notificationSettings?: NotificationSettingsUpdateManyWithoutUserNestedInput
    calendarEventHistory?: CalendarEventHistoryUpdateManyWithoutUserNestedInput
    expenseHistory?: ExpenseHistoryUpdateManyWithoutUserNestedInput
    messageReads?: MessageReadUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTransactionsToInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    profileImageURL?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deviceTokens?: UserUpdatedeviceTokensInput | string[]
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    households?: HouseholdMemberUncheckedUpdateManyWithoutUserNestedInput
    messages?: MessageUncheckedUpdateManyWithoutAuthorNestedInput
    threads?: ThreadUncheckedUpdateManyWithoutAuthorNestedInput
    assignedChores?: ChoreAssignmentUncheckedUpdateManyWithoutUserNestedInput
    expensesPaid?: ExpenseUncheckedUpdateManyWithoutPaidByNestedInput
    expenseSplits?: ExpenseSplitUncheckedUpdateManyWithoutUserNestedInput
    transactionsFrom?: TransactionUncheckedUpdateManyWithoutFromUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    oauthIntegrations?: OAuthIntegrationUncheckedUpdateManyWithoutUserNestedInput
    eventsCreated?: EventUncheckedUpdateManyWithoutCreatedByNestedInput
    choreSwapRequestsInitiated?: ChoreSwapRequestUncheckedUpdateManyWithoutRequestingUserNestedInput
    choreSwapRequestsReceived?: ChoreSwapRequestUncheckedUpdateManyWithoutTargetUserNestedInput
    reactions?: ReactionUncheckedUpdateManyWithoutUserNestedInput
    mentions?: MentionUncheckedUpdateManyWithoutUserNestedInput
    choreHistory?: ChoreHistoryUncheckedUpdateManyWithoutUserNestedInput
    notificationSettings?: NotificationSettingsUncheckedUpdateManyWithoutUserNestedInput
    calendarEventHistory?: CalendarEventHistoryUncheckedUpdateManyWithoutUserNestedInput
    expenseHistory?: ExpenseHistoryUncheckedUpdateManyWithoutUserNestedInput
    messageReads?: MessageReadUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ExpenseCreateWithoutReceiptsInput = {
    id?: string
    amount: number
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    dueDate?: Date | string | null
    deletedAt?: Date | string | null
    category: $Enums.ExpenseCategory
    household: HouseholdCreateNestedOneWithoutExpensesInput
    paidBy: UserCreateNestedOneWithoutExpensesPaidInput
    splits?: ExpenseSplitCreateNestedManyWithoutExpenseInput
    transactions?: TransactionCreateNestedManyWithoutExpenseInput
    history?: ExpenseHistoryCreateNestedManyWithoutExpenseInput
  }

  export type ExpenseUncheckedCreateWithoutReceiptsInput = {
    id?: string
    householdId: string
    amount: number
    description: string
    paidById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    dueDate?: Date | string | null
    deletedAt?: Date | string | null
    category: $Enums.ExpenseCategory
    splits?: ExpenseSplitUncheckedCreateNestedManyWithoutExpenseInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutExpenseInput
    history?: ExpenseHistoryUncheckedCreateNestedManyWithoutExpenseInput
  }

  export type ExpenseCreateOrConnectWithoutReceiptsInput = {
    where: ExpenseWhereUniqueInput
    create: XOR<ExpenseCreateWithoutReceiptsInput, ExpenseUncheckedCreateWithoutReceiptsInput>
  }

  export type ExpenseUpsertWithoutReceiptsInput = {
    update: XOR<ExpenseUpdateWithoutReceiptsInput, ExpenseUncheckedUpdateWithoutReceiptsInput>
    create: XOR<ExpenseCreateWithoutReceiptsInput, ExpenseUncheckedCreateWithoutReceiptsInput>
    where?: ExpenseWhereInput
  }

  export type ExpenseUpdateToOneWithWhereWithoutReceiptsInput = {
    where?: ExpenseWhereInput
    data: XOR<ExpenseUpdateWithoutReceiptsInput, ExpenseUncheckedUpdateWithoutReceiptsInput>
  }

  export type ExpenseUpdateWithoutReceiptsInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: EnumExpenseCategoryFieldUpdateOperationsInput | $Enums.ExpenseCategory
    household?: HouseholdUpdateOneRequiredWithoutExpensesNestedInput
    paidBy?: UserUpdateOneRequiredWithoutExpensesPaidNestedInput
    splits?: ExpenseSplitUpdateManyWithoutExpenseNestedInput
    transactions?: TransactionUpdateManyWithoutExpenseNestedInput
    history?: ExpenseHistoryUpdateManyWithoutExpenseNestedInput
  }

  export type ExpenseUncheckedUpdateWithoutReceiptsInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    paidById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: EnumExpenseCategoryFieldUpdateOperationsInput | $Enums.ExpenseCategory
    splits?: ExpenseSplitUncheckedUpdateManyWithoutExpenseNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutExpenseNestedInput
    history?: ExpenseHistoryUncheckedUpdateManyWithoutExpenseNestedInput
  }

  export type ExpenseCreateWithoutHistoryInput = {
    id?: string
    amount: number
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    dueDate?: Date | string | null
    deletedAt?: Date | string | null
    category: $Enums.ExpenseCategory
    household: HouseholdCreateNestedOneWithoutExpensesInput
    paidBy: UserCreateNestedOneWithoutExpensesPaidInput
    splits?: ExpenseSplitCreateNestedManyWithoutExpenseInput
    transactions?: TransactionCreateNestedManyWithoutExpenseInput
    receipts?: ReceiptCreateNestedManyWithoutExpenseInput
  }

  export type ExpenseUncheckedCreateWithoutHistoryInput = {
    id?: string
    householdId: string
    amount: number
    description: string
    paidById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    dueDate?: Date | string | null
    deletedAt?: Date | string | null
    category: $Enums.ExpenseCategory
    splits?: ExpenseSplitUncheckedCreateNestedManyWithoutExpenseInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutExpenseInput
    receipts?: ReceiptUncheckedCreateNestedManyWithoutExpenseInput
  }

  export type ExpenseCreateOrConnectWithoutHistoryInput = {
    where: ExpenseWhereUniqueInput
    create: XOR<ExpenseCreateWithoutHistoryInput, ExpenseUncheckedCreateWithoutHistoryInput>
  }

  export type UserCreateWithoutExpenseHistoryInput = {
    id?: string
    email: string
    passwordHash?: string | null
    name: string
    profileImageURL?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deviceTokens?: UserCreatedeviceTokensInput | string[]
    deletedAt?: Date | string | null
    households?: HouseholdMemberCreateNestedManyWithoutUserInput
    messages?: MessageCreateNestedManyWithoutAuthorInput
    threads?: ThreadCreateNestedManyWithoutAuthorInput
    assignedChores?: ChoreAssignmentCreateNestedManyWithoutUserInput
    expensesPaid?: ExpenseCreateNestedManyWithoutPaidByInput
    expenseSplits?: ExpenseSplitCreateNestedManyWithoutUserInput
    transactionsFrom?: TransactionCreateNestedManyWithoutFromUserInput
    transactionsTo?: TransactionCreateNestedManyWithoutToUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    oauthIntegrations?: OAuthIntegrationCreateNestedManyWithoutUserInput
    eventsCreated?: EventCreateNestedManyWithoutCreatedByInput
    choreSwapRequestsInitiated?: ChoreSwapRequestCreateNestedManyWithoutRequestingUserInput
    choreSwapRequestsReceived?: ChoreSwapRequestCreateNestedManyWithoutTargetUserInput
    reactions?: ReactionCreateNestedManyWithoutUserInput
    mentions?: MentionCreateNestedManyWithoutUserInput
    choreHistory?: ChoreHistoryCreateNestedManyWithoutUserInput
    notificationSettings?: NotificationSettingsCreateNestedManyWithoutUserInput
    calendarEventHistory?: CalendarEventHistoryCreateNestedManyWithoutUserInput
    messageReads?: MessageReadCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutExpenseHistoryInput = {
    id?: string
    email: string
    passwordHash?: string | null
    name: string
    profileImageURL?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deviceTokens?: UserCreatedeviceTokensInput | string[]
    deletedAt?: Date | string | null
    households?: HouseholdMemberUncheckedCreateNestedManyWithoutUserInput
    messages?: MessageUncheckedCreateNestedManyWithoutAuthorInput
    threads?: ThreadUncheckedCreateNestedManyWithoutAuthorInput
    assignedChores?: ChoreAssignmentUncheckedCreateNestedManyWithoutUserInput
    expensesPaid?: ExpenseUncheckedCreateNestedManyWithoutPaidByInput
    expenseSplits?: ExpenseSplitUncheckedCreateNestedManyWithoutUserInput
    transactionsFrom?: TransactionUncheckedCreateNestedManyWithoutFromUserInput
    transactionsTo?: TransactionUncheckedCreateNestedManyWithoutToUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    oauthIntegrations?: OAuthIntegrationUncheckedCreateNestedManyWithoutUserInput
    eventsCreated?: EventUncheckedCreateNestedManyWithoutCreatedByInput
    choreSwapRequestsInitiated?: ChoreSwapRequestUncheckedCreateNestedManyWithoutRequestingUserInput
    choreSwapRequestsReceived?: ChoreSwapRequestUncheckedCreateNestedManyWithoutTargetUserInput
    reactions?: ReactionUncheckedCreateNestedManyWithoutUserInput
    mentions?: MentionUncheckedCreateNestedManyWithoutUserInput
    choreHistory?: ChoreHistoryUncheckedCreateNestedManyWithoutUserInput
    notificationSettings?: NotificationSettingsUncheckedCreateNestedManyWithoutUserInput
    calendarEventHistory?: CalendarEventHistoryUncheckedCreateNestedManyWithoutUserInput
    messageReads?: MessageReadUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutExpenseHistoryInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutExpenseHistoryInput, UserUncheckedCreateWithoutExpenseHistoryInput>
  }

  export type ExpenseUpsertWithoutHistoryInput = {
    update: XOR<ExpenseUpdateWithoutHistoryInput, ExpenseUncheckedUpdateWithoutHistoryInput>
    create: XOR<ExpenseCreateWithoutHistoryInput, ExpenseUncheckedCreateWithoutHistoryInput>
    where?: ExpenseWhereInput
  }

  export type ExpenseUpdateToOneWithWhereWithoutHistoryInput = {
    where?: ExpenseWhereInput
    data: XOR<ExpenseUpdateWithoutHistoryInput, ExpenseUncheckedUpdateWithoutHistoryInput>
  }

  export type ExpenseUpdateWithoutHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: EnumExpenseCategoryFieldUpdateOperationsInput | $Enums.ExpenseCategory
    household?: HouseholdUpdateOneRequiredWithoutExpensesNestedInput
    paidBy?: UserUpdateOneRequiredWithoutExpensesPaidNestedInput
    splits?: ExpenseSplitUpdateManyWithoutExpenseNestedInput
    transactions?: TransactionUpdateManyWithoutExpenseNestedInput
    receipts?: ReceiptUpdateManyWithoutExpenseNestedInput
  }

  export type ExpenseUncheckedUpdateWithoutHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    paidById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: EnumExpenseCategoryFieldUpdateOperationsInput | $Enums.ExpenseCategory
    splits?: ExpenseSplitUncheckedUpdateManyWithoutExpenseNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutExpenseNestedInput
    receipts?: ReceiptUncheckedUpdateManyWithoutExpenseNestedInput
  }

  export type UserUpsertWithoutExpenseHistoryInput = {
    update: XOR<UserUpdateWithoutExpenseHistoryInput, UserUncheckedUpdateWithoutExpenseHistoryInput>
    create: XOR<UserCreateWithoutExpenseHistoryInput, UserUncheckedCreateWithoutExpenseHistoryInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutExpenseHistoryInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutExpenseHistoryInput, UserUncheckedUpdateWithoutExpenseHistoryInput>
  }

  export type UserUpdateWithoutExpenseHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    profileImageURL?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deviceTokens?: UserUpdatedeviceTokensInput | string[]
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    households?: HouseholdMemberUpdateManyWithoutUserNestedInput
    messages?: MessageUpdateManyWithoutAuthorNestedInput
    threads?: ThreadUpdateManyWithoutAuthorNestedInput
    assignedChores?: ChoreAssignmentUpdateManyWithoutUserNestedInput
    expensesPaid?: ExpenseUpdateManyWithoutPaidByNestedInput
    expenseSplits?: ExpenseSplitUpdateManyWithoutUserNestedInput
    transactionsFrom?: TransactionUpdateManyWithoutFromUserNestedInput
    transactionsTo?: TransactionUpdateManyWithoutToUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    oauthIntegrations?: OAuthIntegrationUpdateManyWithoutUserNestedInput
    eventsCreated?: EventUpdateManyWithoutCreatedByNestedInput
    choreSwapRequestsInitiated?: ChoreSwapRequestUpdateManyWithoutRequestingUserNestedInput
    choreSwapRequestsReceived?: ChoreSwapRequestUpdateManyWithoutTargetUserNestedInput
    reactions?: ReactionUpdateManyWithoutUserNestedInput
    mentions?: MentionUpdateManyWithoutUserNestedInput
    choreHistory?: ChoreHistoryUpdateManyWithoutUserNestedInput
    notificationSettings?: NotificationSettingsUpdateManyWithoutUserNestedInput
    calendarEventHistory?: CalendarEventHistoryUpdateManyWithoutUserNestedInput
    messageReads?: MessageReadUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutExpenseHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    profileImageURL?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deviceTokens?: UserUpdatedeviceTokensInput | string[]
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    households?: HouseholdMemberUncheckedUpdateManyWithoutUserNestedInput
    messages?: MessageUncheckedUpdateManyWithoutAuthorNestedInput
    threads?: ThreadUncheckedUpdateManyWithoutAuthorNestedInput
    assignedChores?: ChoreAssignmentUncheckedUpdateManyWithoutUserNestedInput
    expensesPaid?: ExpenseUncheckedUpdateManyWithoutPaidByNestedInput
    expenseSplits?: ExpenseSplitUncheckedUpdateManyWithoutUserNestedInput
    transactionsFrom?: TransactionUncheckedUpdateManyWithoutFromUserNestedInput
    transactionsTo?: TransactionUncheckedUpdateManyWithoutToUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    oauthIntegrations?: OAuthIntegrationUncheckedUpdateManyWithoutUserNestedInput
    eventsCreated?: EventUncheckedUpdateManyWithoutCreatedByNestedInput
    choreSwapRequestsInitiated?: ChoreSwapRequestUncheckedUpdateManyWithoutRequestingUserNestedInput
    choreSwapRequestsReceived?: ChoreSwapRequestUncheckedUpdateManyWithoutTargetUserNestedInput
    reactions?: ReactionUncheckedUpdateManyWithoutUserNestedInput
    mentions?: MentionUncheckedUpdateManyWithoutUserNestedInput
    choreHistory?: ChoreHistoryUncheckedUpdateManyWithoutUserNestedInput
    notificationSettings?: NotificationSettingsUncheckedUpdateManyWithoutUserNestedInput
    calendarEventHistory?: CalendarEventHistoryUncheckedUpdateManyWithoutUserNestedInput
    messageReads?: MessageReadUncheckedUpdateManyWithoutUserNestedInput
  }

  export type EventReminderCreateWithoutEventInput = {
    id?: string
    time: Date | string
    type: $Enums.EventReminderType
  }

  export type EventReminderUncheckedCreateWithoutEventInput = {
    id?: string
    time: Date | string
    type: $Enums.EventReminderType
  }

  export type EventReminderCreateOrConnectWithoutEventInput = {
    where: EventReminderWhereUniqueInput
    create: XOR<EventReminderCreateWithoutEventInput, EventReminderUncheckedCreateWithoutEventInput>
  }

  export type EventReminderCreateManyEventInputEnvelope = {
    data: EventReminderCreateManyEventInput | EventReminderCreateManyEventInput[]
    skipDuplicates?: boolean
  }

  export type HouseholdCreateWithoutEventsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    currency?: string
    icon?: string | null
    timezone?: string
    language?: string
    deletedAt?: Date | string | null
    members?: HouseholdMemberCreateNestedManyWithoutHouseholdInput
    threads?: ThreadCreateNestedManyWithoutHouseholdInput
    chores?: ChoreCreateNestedManyWithoutHouseholdInput
    expenses?: ExpenseCreateNestedManyWithoutHouseholdInput
    choreTemplates?: ChoreTemplateCreateNestedManyWithoutHouseholdInput
    notificationSettings?: NotificationSettingsCreateNestedManyWithoutHouseholdInput
  }

  export type HouseholdUncheckedCreateWithoutEventsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    currency?: string
    icon?: string | null
    timezone?: string
    language?: string
    deletedAt?: Date | string | null
    members?: HouseholdMemberUncheckedCreateNestedManyWithoutHouseholdInput
    threads?: ThreadUncheckedCreateNestedManyWithoutHouseholdInput
    chores?: ChoreUncheckedCreateNestedManyWithoutHouseholdInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutHouseholdInput
    choreTemplates?: ChoreTemplateUncheckedCreateNestedManyWithoutHouseholdInput
    notificationSettings?: NotificationSettingsUncheckedCreateNestedManyWithoutHouseholdInput
  }

  export type HouseholdCreateOrConnectWithoutEventsInput = {
    where: HouseholdWhereUniqueInput
    create: XOR<HouseholdCreateWithoutEventsInput, HouseholdUncheckedCreateWithoutEventsInput>
  }

  export type UserCreateWithoutEventsCreatedInput = {
    id?: string
    email: string
    passwordHash?: string | null
    name: string
    profileImageURL?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deviceTokens?: UserCreatedeviceTokensInput | string[]
    deletedAt?: Date | string | null
    households?: HouseholdMemberCreateNestedManyWithoutUserInput
    messages?: MessageCreateNestedManyWithoutAuthorInput
    threads?: ThreadCreateNestedManyWithoutAuthorInput
    assignedChores?: ChoreAssignmentCreateNestedManyWithoutUserInput
    expensesPaid?: ExpenseCreateNestedManyWithoutPaidByInput
    expenseSplits?: ExpenseSplitCreateNestedManyWithoutUserInput
    transactionsFrom?: TransactionCreateNestedManyWithoutFromUserInput
    transactionsTo?: TransactionCreateNestedManyWithoutToUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    oauthIntegrations?: OAuthIntegrationCreateNestedManyWithoutUserInput
    choreSwapRequestsInitiated?: ChoreSwapRequestCreateNestedManyWithoutRequestingUserInput
    choreSwapRequestsReceived?: ChoreSwapRequestCreateNestedManyWithoutTargetUserInput
    reactions?: ReactionCreateNestedManyWithoutUserInput
    mentions?: MentionCreateNestedManyWithoutUserInput
    choreHistory?: ChoreHistoryCreateNestedManyWithoutUserInput
    notificationSettings?: NotificationSettingsCreateNestedManyWithoutUserInput
    calendarEventHistory?: CalendarEventHistoryCreateNestedManyWithoutUserInput
    expenseHistory?: ExpenseHistoryCreateNestedManyWithoutUserInput
    messageReads?: MessageReadCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutEventsCreatedInput = {
    id?: string
    email: string
    passwordHash?: string | null
    name: string
    profileImageURL?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deviceTokens?: UserCreatedeviceTokensInput | string[]
    deletedAt?: Date | string | null
    households?: HouseholdMemberUncheckedCreateNestedManyWithoutUserInput
    messages?: MessageUncheckedCreateNestedManyWithoutAuthorInput
    threads?: ThreadUncheckedCreateNestedManyWithoutAuthorInput
    assignedChores?: ChoreAssignmentUncheckedCreateNestedManyWithoutUserInput
    expensesPaid?: ExpenseUncheckedCreateNestedManyWithoutPaidByInput
    expenseSplits?: ExpenseSplitUncheckedCreateNestedManyWithoutUserInput
    transactionsFrom?: TransactionUncheckedCreateNestedManyWithoutFromUserInput
    transactionsTo?: TransactionUncheckedCreateNestedManyWithoutToUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    oauthIntegrations?: OAuthIntegrationUncheckedCreateNestedManyWithoutUserInput
    choreSwapRequestsInitiated?: ChoreSwapRequestUncheckedCreateNestedManyWithoutRequestingUserInput
    choreSwapRequestsReceived?: ChoreSwapRequestUncheckedCreateNestedManyWithoutTargetUserInput
    reactions?: ReactionUncheckedCreateNestedManyWithoutUserInput
    mentions?: MentionUncheckedCreateNestedManyWithoutUserInput
    choreHistory?: ChoreHistoryUncheckedCreateNestedManyWithoutUserInput
    notificationSettings?: NotificationSettingsUncheckedCreateNestedManyWithoutUserInput
    calendarEventHistory?: CalendarEventHistoryUncheckedCreateNestedManyWithoutUserInput
    expenseHistory?: ExpenseHistoryUncheckedCreateNestedManyWithoutUserInput
    messageReads?: MessageReadUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutEventsCreatedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEventsCreatedInput, UserUncheckedCreateWithoutEventsCreatedInput>
  }

  export type ChoreCreateWithoutEventInput = {
    id?: string
    title: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dueDate?: Date | string | null
    status?: $Enums.ChoreStatus
    priority?: number | null
    deletedAt?: Date | string | null
    household: HouseholdCreateNestedOneWithoutChoresInput
    subtasks?: SubtaskCreateNestedManyWithoutChoreInput
    assignedUsers?: ChoreAssignmentCreateNestedManyWithoutChoreInput
    choreSwapRequests?: ChoreSwapRequestCreateNestedManyWithoutChoreInput
    recurrenceRule?: RecurrenceRuleCreateNestedOneWithoutChoresInput
    history?: ChoreHistoryCreateNestedManyWithoutChoreInput
  }

  export type ChoreUncheckedCreateWithoutEventInput = {
    id?: string
    householdId: string
    title: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dueDate?: Date | string | null
    status?: $Enums.ChoreStatus
    priority?: number | null
    recurrenceRuleId?: string | null
    deletedAt?: Date | string | null
    subtasks?: SubtaskUncheckedCreateNestedManyWithoutChoreInput
    assignedUsers?: ChoreAssignmentUncheckedCreateNestedManyWithoutChoreInput
    choreSwapRequests?: ChoreSwapRequestUncheckedCreateNestedManyWithoutChoreInput
    history?: ChoreHistoryUncheckedCreateNestedManyWithoutChoreInput
  }

  export type ChoreCreateOrConnectWithoutEventInput = {
    where: ChoreWhereUniqueInput
    create: XOR<ChoreCreateWithoutEventInput, ChoreUncheckedCreateWithoutEventInput>
  }

  export type RecurrenceRuleCreateWithoutEventsInput = {
    id?: string
    frequency: $Enums.RecurrenceFrequency
    interval?: number
    byWeekDay?: RecurrenceRuleCreatebyWeekDayInput | $Enums.DaysOfWeek[]
    byMonthDay?: RecurrenceRuleCreatebyMonthDayInput | number[]
    bySetPos?: number | null
    count?: number | null
    until?: Date | string | null
    customRuleString?: string | null
    chores?: ChoreCreateNestedManyWithoutRecurrenceRuleInput
  }

  export type RecurrenceRuleUncheckedCreateWithoutEventsInput = {
    id?: string
    frequency: $Enums.RecurrenceFrequency
    interval?: number
    byWeekDay?: RecurrenceRuleCreatebyWeekDayInput | $Enums.DaysOfWeek[]
    byMonthDay?: RecurrenceRuleCreatebyMonthDayInput | number[]
    bySetPos?: number | null
    count?: number | null
    until?: Date | string | null
    customRuleString?: string | null
    chores?: ChoreUncheckedCreateNestedManyWithoutRecurrenceRuleInput
  }

  export type RecurrenceRuleCreateOrConnectWithoutEventsInput = {
    where: RecurrenceRuleWhereUniqueInput
    create: XOR<RecurrenceRuleCreateWithoutEventsInput, RecurrenceRuleUncheckedCreateWithoutEventsInput>
  }

  export type CalendarEventHistoryCreateWithoutEventInput = {
    id?: string
    action: $Enums.CalendarEventAction
    changedAt?: Date | string
    user: UserCreateNestedOneWithoutCalendarEventHistoryInput
  }

  export type CalendarEventHistoryUncheckedCreateWithoutEventInput = {
    id?: string
    action: $Enums.CalendarEventAction
    changedById: string
    changedAt?: Date | string
  }

  export type CalendarEventHistoryCreateOrConnectWithoutEventInput = {
    where: CalendarEventHistoryWhereUniqueInput
    create: XOR<CalendarEventHistoryCreateWithoutEventInput, CalendarEventHistoryUncheckedCreateWithoutEventInput>
  }

  export type CalendarEventHistoryCreateManyEventInputEnvelope = {
    data: CalendarEventHistoryCreateManyEventInput | CalendarEventHistoryCreateManyEventInput[]
    skipDuplicates?: boolean
  }

  export type EventReminderUpsertWithWhereUniqueWithoutEventInput = {
    where: EventReminderWhereUniqueInput
    update: XOR<EventReminderUpdateWithoutEventInput, EventReminderUncheckedUpdateWithoutEventInput>
    create: XOR<EventReminderCreateWithoutEventInput, EventReminderUncheckedCreateWithoutEventInput>
  }

  export type EventReminderUpdateWithWhereUniqueWithoutEventInput = {
    where: EventReminderWhereUniqueInput
    data: XOR<EventReminderUpdateWithoutEventInput, EventReminderUncheckedUpdateWithoutEventInput>
  }

  export type EventReminderUpdateManyWithWhereWithoutEventInput = {
    where: EventReminderScalarWhereInput
    data: XOR<EventReminderUpdateManyMutationInput, EventReminderUncheckedUpdateManyWithoutEventInput>
  }

  export type EventReminderScalarWhereInput = {
    AND?: EventReminderScalarWhereInput | EventReminderScalarWhereInput[]
    OR?: EventReminderScalarWhereInput[]
    NOT?: EventReminderScalarWhereInput | EventReminderScalarWhereInput[]
    id?: StringFilter<"EventReminder"> | string
    eventId?: StringFilter<"EventReminder"> | string
    time?: DateTimeFilter<"EventReminder"> | Date | string
    type?: EnumEventReminderTypeFilter<"EventReminder"> | $Enums.EventReminderType
  }

  export type HouseholdUpsertWithoutEventsInput = {
    update: XOR<HouseholdUpdateWithoutEventsInput, HouseholdUncheckedUpdateWithoutEventsInput>
    create: XOR<HouseholdCreateWithoutEventsInput, HouseholdUncheckedCreateWithoutEventsInput>
    where?: HouseholdWhereInput
  }

  export type HouseholdUpdateToOneWithWhereWithoutEventsInput = {
    where?: HouseholdWhereInput
    data: XOR<HouseholdUpdateWithoutEventsInput, HouseholdUncheckedUpdateWithoutEventsInput>
  }

  export type HouseholdUpdateWithoutEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    members?: HouseholdMemberUpdateManyWithoutHouseholdNestedInput
    threads?: ThreadUpdateManyWithoutHouseholdNestedInput
    chores?: ChoreUpdateManyWithoutHouseholdNestedInput
    expenses?: ExpenseUpdateManyWithoutHouseholdNestedInput
    choreTemplates?: ChoreTemplateUpdateManyWithoutHouseholdNestedInput
    notificationSettings?: NotificationSettingsUpdateManyWithoutHouseholdNestedInput
  }

  export type HouseholdUncheckedUpdateWithoutEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    members?: HouseholdMemberUncheckedUpdateManyWithoutHouseholdNestedInput
    threads?: ThreadUncheckedUpdateManyWithoutHouseholdNestedInput
    chores?: ChoreUncheckedUpdateManyWithoutHouseholdNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutHouseholdNestedInput
    choreTemplates?: ChoreTemplateUncheckedUpdateManyWithoutHouseholdNestedInput
    notificationSettings?: NotificationSettingsUncheckedUpdateManyWithoutHouseholdNestedInput
  }

  export type UserUpsertWithoutEventsCreatedInput = {
    update: XOR<UserUpdateWithoutEventsCreatedInput, UserUncheckedUpdateWithoutEventsCreatedInput>
    create: XOR<UserCreateWithoutEventsCreatedInput, UserUncheckedCreateWithoutEventsCreatedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEventsCreatedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEventsCreatedInput, UserUncheckedUpdateWithoutEventsCreatedInput>
  }

  export type UserUpdateWithoutEventsCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    profileImageURL?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deviceTokens?: UserUpdatedeviceTokensInput | string[]
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    households?: HouseholdMemberUpdateManyWithoutUserNestedInput
    messages?: MessageUpdateManyWithoutAuthorNestedInput
    threads?: ThreadUpdateManyWithoutAuthorNestedInput
    assignedChores?: ChoreAssignmentUpdateManyWithoutUserNestedInput
    expensesPaid?: ExpenseUpdateManyWithoutPaidByNestedInput
    expenseSplits?: ExpenseSplitUpdateManyWithoutUserNestedInput
    transactionsFrom?: TransactionUpdateManyWithoutFromUserNestedInput
    transactionsTo?: TransactionUpdateManyWithoutToUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    oauthIntegrations?: OAuthIntegrationUpdateManyWithoutUserNestedInput
    choreSwapRequestsInitiated?: ChoreSwapRequestUpdateManyWithoutRequestingUserNestedInput
    choreSwapRequestsReceived?: ChoreSwapRequestUpdateManyWithoutTargetUserNestedInput
    reactions?: ReactionUpdateManyWithoutUserNestedInput
    mentions?: MentionUpdateManyWithoutUserNestedInput
    choreHistory?: ChoreHistoryUpdateManyWithoutUserNestedInput
    notificationSettings?: NotificationSettingsUpdateManyWithoutUserNestedInput
    calendarEventHistory?: CalendarEventHistoryUpdateManyWithoutUserNestedInput
    expenseHistory?: ExpenseHistoryUpdateManyWithoutUserNestedInput
    messageReads?: MessageReadUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutEventsCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    profileImageURL?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deviceTokens?: UserUpdatedeviceTokensInput | string[]
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    households?: HouseholdMemberUncheckedUpdateManyWithoutUserNestedInput
    messages?: MessageUncheckedUpdateManyWithoutAuthorNestedInput
    threads?: ThreadUncheckedUpdateManyWithoutAuthorNestedInput
    assignedChores?: ChoreAssignmentUncheckedUpdateManyWithoutUserNestedInput
    expensesPaid?: ExpenseUncheckedUpdateManyWithoutPaidByNestedInput
    expenseSplits?: ExpenseSplitUncheckedUpdateManyWithoutUserNestedInput
    transactionsFrom?: TransactionUncheckedUpdateManyWithoutFromUserNestedInput
    transactionsTo?: TransactionUncheckedUpdateManyWithoutToUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    oauthIntegrations?: OAuthIntegrationUncheckedUpdateManyWithoutUserNestedInput
    choreSwapRequestsInitiated?: ChoreSwapRequestUncheckedUpdateManyWithoutRequestingUserNestedInput
    choreSwapRequestsReceived?: ChoreSwapRequestUncheckedUpdateManyWithoutTargetUserNestedInput
    reactions?: ReactionUncheckedUpdateManyWithoutUserNestedInput
    mentions?: MentionUncheckedUpdateManyWithoutUserNestedInput
    choreHistory?: ChoreHistoryUncheckedUpdateManyWithoutUserNestedInput
    notificationSettings?: NotificationSettingsUncheckedUpdateManyWithoutUserNestedInput
    calendarEventHistory?: CalendarEventHistoryUncheckedUpdateManyWithoutUserNestedInput
    expenseHistory?: ExpenseHistoryUncheckedUpdateManyWithoutUserNestedInput
    messageReads?: MessageReadUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ChoreUpsertWithoutEventInput = {
    update: XOR<ChoreUpdateWithoutEventInput, ChoreUncheckedUpdateWithoutEventInput>
    create: XOR<ChoreCreateWithoutEventInput, ChoreUncheckedCreateWithoutEventInput>
    where?: ChoreWhereInput
  }

  export type ChoreUpdateToOneWithWhereWithoutEventInput = {
    where?: ChoreWhereInput
    data: XOR<ChoreUpdateWithoutEventInput, ChoreUncheckedUpdateWithoutEventInput>
  }

  export type ChoreUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumChoreStatusFieldUpdateOperationsInput | $Enums.ChoreStatus
    priority?: NullableIntFieldUpdateOperationsInput | number | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    household?: HouseholdUpdateOneRequiredWithoutChoresNestedInput
    subtasks?: SubtaskUpdateManyWithoutChoreNestedInput
    assignedUsers?: ChoreAssignmentUpdateManyWithoutChoreNestedInput
    choreSwapRequests?: ChoreSwapRequestUpdateManyWithoutChoreNestedInput
    recurrenceRule?: RecurrenceRuleUpdateOneWithoutChoresNestedInput
    history?: ChoreHistoryUpdateManyWithoutChoreNestedInput
  }

  export type ChoreUncheckedUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumChoreStatusFieldUpdateOperationsInput | $Enums.ChoreStatus
    priority?: NullableIntFieldUpdateOperationsInput | number | null
    recurrenceRuleId?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtasks?: SubtaskUncheckedUpdateManyWithoutChoreNestedInput
    assignedUsers?: ChoreAssignmentUncheckedUpdateManyWithoutChoreNestedInput
    choreSwapRequests?: ChoreSwapRequestUncheckedUpdateManyWithoutChoreNestedInput
    history?: ChoreHistoryUncheckedUpdateManyWithoutChoreNestedInput
  }

  export type RecurrenceRuleUpsertWithoutEventsInput = {
    update: XOR<RecurrenceRuleUpdateWithoutEventsInput, RecurrenceRuleUncheckedUpdateWithoutEventsInput>
    create: XOR<RecurrenceRuleCreateWithoutEventsInput, RecurrenceRuleUncheckedCreateWithoutEventsInput>
    where?: RecurrenceRuleWhereInput
  }

  export type RecurrenceRuleUpdateToOneWithWhereWithoutEventsInput = {
    where?: RecurrenceRuleWhereInput
    data: XOR<RecurrenceRuleUpdateWithoutEventsInput, RecurrenceRuleUncheckedUpdateWithoutEventsInput>
  }

  export type RecurrenceRuleUpdateWithoutEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    frequency?: EnumRecurrenceFrequencyFieldUpdateOperationsInput | $Enums.RecurrenceFrequency
    interval?: IntFieldUpdateOperationsInput | number
    byWeekDay?: RecurrenceRuleUpdatebyWeekDayInput | $Enums.DaysOfWeek[]
    byMonthDay?: RecurrenceRuleUpdatebyMonthDayInput | number[]
    bySetPos?: NullableIntFieldUpdateOperationsInput | number | null
    count?: NullableIntFieldUpdateOperationsInput | number | null
    until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customRuleString?: NullableStringFieldUpdateOperationsInput | string | null
    chores?: ChoreUpdateManyWithoutRecurrenceRuleNestedInput
  }

  export type RecurrenceRuleUncheckedUpdateWithoutEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    frequency?: EnumRecurrenceFrequencyFieldUpdateOperationsInput | $Enums.RecurrenceFrequency
    interval?: IntFieldUpdateOperationsInput | number
    byWeekDay?: RecurrenceRuleUpdatebyWeekDayInput | $Enums.DaysOfWeek[]
    byMonthDay?: RecurrenceRuleUpdatebyMonthDayInput | number[]
    bySetPos?: NullableIntFieldUpdateOperationsInput | number | null
    count?: NullableIntFieldUpdateOperationsInput | number | null
    until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customRuleString?: NullableStringFieldUpdateOperationsInput | string | null
    chores?: ChoreUncheckedUpdateManyWithoutRecurrenceRuleNestedInput
  }

  export type CalendarEventHistoryUpsertWithWhereUniqueWithoutEventInput = {
    where: CalendarEventHistoryWhereUniqueInput
    update: XOR<CalendarEventHistoryUpdateWithoutEventInput, CalendarEventHistoryUncheckedUpdateWithoutEventInput>
    create: XOR<CalendarEventHistoryCreateWithoutEventInput, CalendarEventHistoryUncheckedCreateWithoutEventInput>
  }

  export type CalendarEventHistoryUpdateWithWhereUniqueWithoutEventInput = {
    where: CalendarEventHistoryWhereUniqueInput
    data: XOR<CalendarEventHistoryUpdateWithoutEventInput, CalendarEventHistoryUncheckedUpdateWithoutEventInput>
  }

  export type CalendarEventHistoryUpdateManyWithWhereWithoutEventInput = {
    where: CalendarEventHistoryScalarWhereInput
    data: XOR<CalendarEventHistoryUpdateManyMutationInput, CalendarEventHistoryUncheckedUpdateManyWithoutEventInput>
  }

  export type EventCreateWithoutRemindersInput = {
    id?: string
    title: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    choreId?: string | null
    category?: $Enums.EventCategory
    isAllDay?: boolean
    location?: string | null
    isPrivate?: boolean
    status?: $Enums.EventStatus
    deletedAt?: Date | string | null
    household: HouseholdCreateNestedOneWithoutEventsInput
    createdBy: UserCreateNestedOneWithoutEventsCreatedInput
    chore?: ChoreCreateNestedOneWithoutEventInput
    recurrenceRule?: RecurrenceRuleCreateNestedOneWithoutEventsInput
    history?: CalendarEventHistoryCreateNestedManyWithoutEventInput
  }

  export type EventUncheckedCreateWithoutRemindersInput = {
    id?: string
    householdId: string
    title: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    choreId?: string | null
    recurrenceRuleId?: string | null
    category?: $Enums.EventCategory
    isAllDay?: boolean
    location?: string | null
    isPrivate?: boolean
    status?: $Enums.EventStatus
    deletedAt?: Date | string | null
    chore?: ChoreUncheckedCreateNestedOneWithoutEventInput
    history?: CalendarEventHistoryUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventCreateOrConnectWithoutRemindersInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutRemindersInput, EventUncheckedCreateWithoutRemindersInput>
  }

  export type EventUpsertWithoutRemindersInput = {
    update: XOR<EventUpdateWithoutRemindersInput, EventUncheckedUpdateWithoutRemindersInput>
    create: XOR<EventCreateWithoutRemindersInput, EventUncheckedCreateWithoutRemindersInput>
    where?: EventWhereInput
  }

  export type EventUpdateToOneWithWhereWithoutRemindersInput = {
    where?: EventWhereInput
    data: XOR<EventUpdateWithoutRemindersInput, EventUncheckedUpdateWithoutRemindersInput>
  }

  export type EventUpdateWithoutRemindersInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    choreId?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumEventCategoryFieldUpdateOperationsInput | $Enums.EventCategory
    isAllDay?: BoolFieldUpdateOperationsInput | boolean
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumEventStatusFieldUpdateOperationsInput | $Enums.EventStatus
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    household?: HouseholdUpdateOneRequiredWithoutEventsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutEventsCreatedNestedInput
    chore?: ChoreUpdateOneWithoutEventNestedInput
    recurrenceRule?: RecurrenceRuleUpdateOneWithoutEventsNestedInput
    history?: CalendarEventHistoryUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateWithoutRemindersInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    choreId?: NullableStringFieldUpdateOperationsInput | string | null
    recurrenceRuleId?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumEventCategoryFieldUpdateOperationsInput | $Enums.EventCategory
    isAllDay?: BoolFieldUpdateOperationsInput | boolean
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumEventStatusFieldUpdateOperationsInput | $Enums.EventStatus
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chore?: ChoreUncheckedUpdateOneWithoutEventNestedInput
    history?: CalendarEventHistoryUncheckedUpdateManyWithoutEventNestedInput
  }

  export type EventCreateWithoutHistoryInput = {
    id?: string
    title: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    choreId?: string | null
    category?: $Enums.EventCategory
    isAllDay?: boolean
    location?: string | null
    isPrivate?: boolean
    status?: $Enums.EventStatus
    deletedAt?: Date | string | null
    reminders?: EventReminderCreateNestedManyWithoutEventInput
    household: HouseholdCreateNestedOneWithoutEventsInput
    createdBy: UserCreateNestedOneWithoutEventsCreatedInput
    chore?: ChoreCreateNestedOneWithoutEventInput
    recurrenceRule?: RecurrenceRuleCreateNestedOneWithoutEventsInput
  }

  export type EventUncheckedCreateWithoutHistoryInput = {
    id?: string
    householdId: string
    title: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    choreId?: string | null
    recurrenceRuleId?: string | null
    category?: $Enums.EventCategory
    isAllDay?: boolean
    location?: string | null
    isPrivate?: boolean
    status?: $Enums.EventStatus
    deletedAt?: Date | string | null
    reminders?: EventReminderUncheckedCreateNestedManyWithoutEventInput
    chore?: ChoreUncheckedCreateNestedOneWithoutEventInput
  }

  export type EventCreateOrConnectWithoutHistoryInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutHistoryInput, EventUncheckedCreateWithoutHistoryInput>
  }

  export type UserCreateWithoutCalendarEventHistoryInput = {
    id?: string
    email: string
    passwordHash?: string | null
    name: string
    profileImageURL?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deviceTokens?: UserCreatedeviceTokensInput | string[]
    deletedAt?: Date | string | null
    households?: HouseholdMemberCreateNestedManyWithoutUserInput
    messages?: MessageCreateNestedManyWithoutAuthorInput
    threads?: ThreadCreateNestedManyWithoutAuthorInput
    assignedChores?: ChoreAssignmentCreateNestedManyWithoutUserInput
    expensesPaid?: ExpenseCreateNestedManyWithoutPaidByInput
    expenseSplits?: ExpenseSplitCreateNestedManyWithoutUserInput
    transactionsFrom?: TransactionCreateNestedManyWithoutFromUserInput
    transactionsTo?: TransactionCreateNestedManyWithoutToUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    oauthIntegrations?: OAuthIntegrationCreateNestedManyWithoutUserInput
    eventsCreated?: EventCreateNestedManyWithoutCreatedByInput
    choreSwapRequestsInitiated?: ChoreSwapRequestCreateNestedManyWithoutRequestingUserInput
    choreSwapRequestsReceived?: ChoreSwapRequestCreateNestedManyWithoutTargetUserInput
    reactions?: ReactionCreateNestedManyWithoutUserInput
    mentions?: MentionCreateNestedManyWithoutUserInput
    choreHistory?: ChoreHistoryCreateNestedManyWithoutUserInput
    notificationSettings?: NotificationSettingsCreateNestedManyWithoutUserInput
    expenseHistory?: ExpenseHistoryCreateNestedManyWithoutUserInput
    messageReads?: MessageReadCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCalendarEventHistoryInput = {
    id?: string
    email: string
    passwordHash?: string | null
    name: string
    profileImageURL?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deviceTokens?: UserCreatedeviceTokensInput | string[]
    deletedAt?: Date | string | null
    households?: HouseholdMemberUncheckedCreateNestedManyWithoutUserInput
    messages?: MessageUncheckedCreateNestedManyWithoutAuthorInput
    threads?: ThreadUncheckedCreateNestedManyWithoutAuthorInput
    assignedChores?: ChoreAssignmentUncheckedCreateNestedManyWithoutUserInput
    expensesPaid?: ExpenseUncheckedCreateNestedManyWithoutPaidByInput
    expenseSplits?: ExpenseSplitUncheckedCreateNestedManyWithoutUserInput
    transactionsFrom?: TransactionUncheckedCreateNestedManyWithoutFromUserInput
    transactionsTo?: TransactionUncheckedCreateNestedManyWithoutToUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    oauthIntegrations?: OAuthIntegrationUncheckedCreateNestedManyWithoutUserInput
    eventsCreated?: EventUncheckedCreateNestedManyWithoutCreatedByInput
    choreSwapRequestsInitiated?: ChoreSwapRequestUncheckedCreateNestedManyWithoutRequestingUserInput
    choreSwapRequestsReceived?: ChoreSwapRequestUncheckedCreateNestedManyWithoutTargetUserInput
    reactions?: ReactionUncheckedCreateNestedManyWithoutUserInput
    mentions?: MentionUncheckedCreateNestedManyWithoutUserInput
    choreHistory?: ChoreHistoryUncheckedCreateNestedManyWithoutUserInput
    notificationSettings?: NotificationSettingsUncheckedCreateNestedManyWithoutUserInput
    expenseHistory?: ExpenseHistoryUncheckedCreateNestedManyWithoutUserInput
    messageReads?: MessageReadUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCalendarEventHistoryInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCalendarEventHistoryInput, UserUncheckedCreateWithoutCalendarEventHistoryInput>
  }

  export type EventUpsertWithoutHistoryInput = {
    update: XOR<EventUpdateWithoutHistoryInput, EventUncheckedUpdateWithoutHistoryInput>
    create: XOR<EventCreateWithoutHistoryInput, EventUncheckedCreateWithoutHistoryInput>
    where?: EventWhereInput
  }

  export type EventUpdateToOneWithWhereWithoutHistoryInput = {
    where?: EventWhereInput
    data: XOR<EventUpdateWithoutHistoryInput, EventUncheckedUpdateWithoutHistoryInput>
  }

  export type EventUpdateWithoutHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    choreId?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumEventCategoryFieldUpdateOperationsInput | $Enums.EventCategory
    isAllDay?: BoolFieldUpdateOperationsInput | boolean
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumEventStatusFieldUpdateOperationsInput | $Enums.EventStatus
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminders?: EventReminderUpdateManyWithoutEventNestedInput
    household?: HouseholdUpdateOneRequiredWithoutEventsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutEventsCreatedNestedInput
    chore?: ChoreUpdateOneWithoutEventNestedInput
    recurrenceRule?: RecurrenceRuleUpdateOneWithoutEventsNestedInput
  }

  export type EventUncheckedUpdateWithoutHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    choreId?: NullableStringFieldUpdateOperationsInput | string | null
    recurrenceRuleId?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumEventCategoryFieldUpdateOperationsInput | $Enums.EventCategory
    isAllDay?: BoolFieldUpdateOperationsInput | boolean
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumEventStatusFieldUpdateOperationsInput | $Enums.EventStatus
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminders?: EventReminderUncheckedUpdateManyWithoutEventNestedInput
    chore?: ChoreUncheckedUpdateOneWithoutEventNestedInput
  }

  export type UserUpsertWithoutCalendarEventHistoryInput = {
    update: XOR<UserUpdateWithoutCalendarEventHistoryInput, UserUncheckedUpdateWithoutCalendarEventHistoryInput>
    create: XOR<UserCreateWithoutCalendarEventHistoryInput, UserUncheckedCreateWithoutCalendarEventHistoryInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCalendarEventHistoryInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCalendarEventHistoryInput, UserUncheckedUpdateWithoutCalendarEventHistoryInput>
  }

  export type UserUpdateWithoutCalendarEventHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    profileImageURL?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deviceTokens?: UserUpdatedeviceTokensInput | string[]
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    households?: HouseholdMemberUpdateManyWithoutUserNestedInput
    messages?: MessageUpdateManyWithoutAuthorNestedInput
    threads?: ThreadUpdateManyWithoutAuthorNestedInput
    assignedChores?: ChoreAssignmentUpdateManyWithoutUserNestedInput
    expensesPaid?: ExpenseUpdateManyWithoutPaidByNestedInput
    expenseSplits?: ExpenseSplitUpdateManyWithoutUserNestedInput
    transactionsFrom?: TransactionUpdateManyWithoutFromUserNestedInput
    transactionsTo?: TransactionUpdateManyWithoutToUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    oauthIntegrations?: OAuthIntegrationUpdateManyWithoutUserNestedInput
    eventsCreated?: EventUpdateManyWithoutCreatedByNestedInput
    choreSwapRequestsInitiated?: ChoreSwapRequestUpdateManyWithoutRequestingUserNestedInput
    choreSwapRequestsReceived?: ChoreSwapRequestUpdateManyWithoutTargetUserNestedInput
    reactions?: ReactionUpdateManyWithoutUserNestedInput
    mentions?: MentionUpdateManyWithoutUserNestedInput
    choreHistory?: ChoreHistoryUpdateManyWithoutUserNestedInput
    notificationSettings?: NotificationSettingsUpdateManyWithoutUserNestedInput
    expenseHistory?: ExpenseHistoryUpdateManyWithoutUserNestedInput
    messageReads?: MessageReadUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCalendarEventHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    profileImageURL?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deviceTokens?: UserUpdatedeviceTokensInput | string[]
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    households?: HouseholdMemberUncheckedUpdateManyWithoutUserNestedInput
    messages?: MessageUncheckedUpdateManyWithoutAuthorNestedInput
    threads?: ThreadUncheckedUpdateManyWithoutAuthorNestedInput
    assignedChores?: ChoreAssignmentUncheckedUpdateManyWithoutUserNestedInput
    expensesPaid?: ExpenseUncheckedUpdateManyWithoutPaidByNestedInput
    expenseSplits?: ExpenseSplitUncheckedUpdateManyWithoutUserNestedInput
    transactionsFrom?: TransactionUncheckedUpdateManyWithoutFromUserNestedInput
    transactionsTo?: TransactionUncheckedUpdateManyWithoutToUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    oauthIntegrations?: OAuthIntegrationUncheckedUpdateManyWithoutUserNestedInput
    eventsCreated?: EventUncheckedUpdateManyWithoutCreatedByNestedInput
    choreSwapRequestsInitiated?: ChoreSwapRequestUncheckedUpdateManyWithoutRequestingUserNestedInput
    choreSwapRequestsReceived?: ChoreSwapRequestUncheckedUpdateManyWithoutTargetUserNestedInput
    reactions?: ReactionUncheckedUpdateManyWithoutUserNestedInput
    mentions?: MentionUncheckedUpdateManyWithoutUserNestedInput
    choreHistory?: ChoreHistoryUncheckedUpdateManyWithoutUserNestedInput
    notificationSettings?: NotificationSettingsUncheckedUpdateManyWithoutUserNestedInput
    expenseHistory?: ExpenseHistoryUncheckedUpdateManyWithoutUserNestedInput
    messageReads?: MessageReadUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutNotificationsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    name: string
    profileImageURL?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deviceTokens?: UserCreatedeviceTokensInput | string[]
    deletedAt?: Date | string | null
    households?: HouseholdMemberCreateNestedManyWithoutUserInput
    messages?: MessageCreateNestedManyWithoutAuthorInput
    threads?: ThreadCreateNestedManyWithoutAuthorInput
    assignedChores?: ChoreAssignmentCreateNestedManyWithoutUserInput
    expensesPaid?: ExpenseCreateNestedManyWithoutPaidByInput
    expenseSplits?: ExpenseSplitCreateNestedManyWithoutUserInput
    transactionsFrom?: TransactionCreateNestedManyWithoutFromUserInput
    transactionsTo?: TransactionCreateNestedManyWithoutToUserInput
    oauthIntegrations?: OAuthIntegrationCreateNestedManyWithoutUserInput
    eventsCreated?: EventCreateNestedManyWithoutCreatedByInput
    choreSwapRequestsInitiated?: ChoreSwapRequestCreateNestedManyWithoutRequestingUserInput
    choreSwapRequestsReceived?: ChoreSwapRequestCreateNestedManyWithoutTargetUserInput
    reactions?: ReactionCreateNestedManyWithoutUserInput
    mentions?: MentionCreateNestedManyWithoutUserInput
    choreHistory?: ChoreHistoryCreateNestedManyWithoutUserInput
    notificationSettings?: NotificationSettingsCreateNestedManyWithoutUserInput
    calendarEventHistory?: CalendarEventHistoryCreateNestedManyWithoutUserInput
    expenseHistory?: ExpenseHistoryCreateNestedManyWithoutUserInput
    messageReads?: MessageReadCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    name: string
    profileImageURL?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deviceTokens?: UserCreatedeviceTokensInput | string[]
    deletedAt?: Date | string | null
    households?: HouseholdMemberUncheckedCreateNestedManyWithoutUserInput
    messages?: MessageUncheckedCreateNestedManyWithoutAuthorInput
    threads?: ThreadUncheckedCreateNestedManyWithoutAuthorInput
    assignedChores?: ChoreAssignmentUncheckedCreateNestedManyWithoutUserInput
    expensesPaid?: ExpenseUncheckedCreateNestedManyWithoutPaidByInput
    expenseSplits?: ExpenseSplitUncheckedCreateNestedManyWithoutUserInput
    transactionsFrom?: TransactionUncheckedCreateNestedManyWithoutFromUserInput
    transactionsTo?: TransactionUncheckedCreateNestedManyWithoutToUserInput
    oauthIntegrations?: OAuthIntegrationUncheckedCreateNestedManyWithoutUserInput
    eventsCreated?: EventUncheckedCreateNestedManyWithoutCreatedByInput
    choreSwapRequestsInitiated?: ChoreSwapRequestUncheckedCreateNestedManyWithoutRequestingUserInput
    choreSwapRequestsReceived?: ChoreSwapRequestUncheckedCreateNestedManyWithoutTargetUserInput
    reactions?: ReactionUncheckedCreateNestedManyWithoutUserInput
    mentions?: MentionUncheckedCreateNestedManyWithoutUserInput
    choreHistory?: ChoreHistoryUncheckedCreateNestedManyWithoutUserInput
    notificationSettings?: NotificationSettingsUncheckedCreateNestedManyWithoutUserInput
    calendarEventHistory?: CalendarEventHistoryUncheckedCreateNestedManyWithoutUserInput
    expenseHistory?: ExpenseHistoryUncheckedCreateNestedManyWithoutUserInput
    messageReads?: MessageReadUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    profileImageURL?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deviceTokens?: UserUpdatedeviceTokensInput | string[]
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    households?: HouseholdMemberUpdateManyWithoutUserNestedInput
    messages?: MessageUpdateManyWithoutAuthorNestedInput
    threads?: ThreadUpdateManyWithoutAuthorNestedInput
    assignedChores?: ChoreAssignmentUpdateManyWithoutUserNestedInput
    expensesPaid?: ExpenseUpdateManyWithoutPaidByNestedInput
    expenseSplits?: ExpenseSplitUpdateManyWithoutUserNestedInput
    transactionsFrom?: TransactionUpdateManyWithoutFromUserNestedInput
    transactionsTo?: TransactionUpdateManyWithoutToUserNestedInput
    oauthIntegrations?: OAuthIntegrationUpdateManyWithoutUserNestedInput
    eventsCreated?: EventUpdateManyWithoutCreatedByNestedInput
    choreSwapRequestsInitiated?: ChoreSwapRequestUpdateManyWithoutRequestingUserNestedInput
    choreSwapRequestsReceived?: ChoreSwapRequestUpdateManyWithoutTargetUserNestedInput
    reactions?: ReactionUpdateManyWithoutUserNestedInput
    mentions?: MentionUpdateManyWithoutUserNestedInput
    choreHistory?: ChoreHistoryUpdateManyWithoutUserNestedInput
    notificationSettings?: NotificationSettingsUpdateManyWithoutUserNestedInput
    calendarEventHistory?: CalendarEventHistoryUpdateManyWithoutUserNestedInput
    expenseHistory?: ExpenseHistoryUpdateManyWithoutUserNestedInput
    messageReads?: MessageReadUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    profileImageURL?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deviceTokens?: UserUpdatedeviceTokensInput | string[]
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    households?: HouseholdMemberUncheckedUpdateManyWithoutUserNestedInput
    messages?: MessageUncheckedUpdateManyWithoutAuthorNestedInput
    threads?: ThreadUncheckedUpdateManyWithoutAuthorNestedInput
    assignedChores?: ChoreAssignmentUncheckedUpdateManyWithoutUserNestedInput
    expensesPaid?: ExpenseUncheckedUpdateManyWithoutPaidByNestedInput
    expenseSplits?: ExpenseSplitUncheckedUpdateManyWithoutUserNestedInput
    transactionsFrom?: TransactionUncheckedUpdateManyWithoutFromUserNestedInput
    transactionsTo?: TransactionUncheckedUpdateManyWithoutToUserNestedInput
    oauthIntegrations?: OAuthIntegrationUncheckedUpdateManyWithoutUserNestedInput
    eventsCreated?: EventUncheckedUpdateManyWithoutCreatedByNestedInput
    choreSwapRequestsInitiated?: ChoreSwapRequestUncheckedUpdateManyWithoutRequestingUserNestedInput
    choreSwapRequestsReceived?: ChoreSwapRequestUncheckedUpdateManyWithoutTargetUserNestedInput
    reactions?: ReactionUncheckedUpdateManyWithoutUserNestedInput
    mentions?: MentionUncheckedUpdateManyWithoutUserNestedInput
    choreHistory?: ChoreHistoryUncheckedUpdateManyWithoutUserNestedInput
    notificationSettings?: NotificationSettingsUncheckedUpdateManyWithoutUserNestedInput
    calendarEventHistory?: CalendarEventHistoryUncheckedUpdateManyWithoutUserNestedInput
    expenseHistory?: ExpenseHistoryUncheckedUpdateManyWithoutUserNestedInput
    messageReads?: MessageReadUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutNotificationSettingsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    name: string
    profileImageURL?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deviceTokens?: UserCreatedeviceTokensInput | string[]
    deletedAt?: Date | string | null
    households?: HouseholdMemberCreateNestedManyWithoutUserInput
    messages?: MessageCreateNestedManyWithoutAuthorInput
    threads?: ThreadCreateNestedManyWithoutAuthorInput
    assignedChores?: ChoreAssignmentCreateNestedManyWithoutUserInput
    expensesPaid?: ExpenseCreateNestedManyWithoutPaidByInput
    expenseSplits?: ExpenseSplitCreateNestedManyWithoutUserInput
    transactionsFrom?: TransactionCreateNestedManyWithoutFromUserInput
    transactionsTo?: TransactionCreateNestedManyWithoutToUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    oauthIntegrations?: OAuthIntegrationCreateNestedManyWithoutUserInput
    eventsCreated?: EventCreateNestedManyWithoutCreatedByInput
    choreSwapRequestsInitiated?: ChoreSwapRequestCreateNestedManyWithoutRequestingUserInput
    choreSwapRequestsReceived?: ChoreSwapRequestCreateNestedManyWithoutTargetUserInput
    reactions?: ReactionCreateNestedManyWithoutUserInput
    mentions?: MentionCreateNestedManyWithoutUserInput
    choreHistory?: ChoreHistoryCreateNestedManyWithoutUserInput
    calendarEventHistory?: CalendarEventHistoryCreateNestedManyWithoutUserInput
    expenseHistory?: ExpenseHistoryCreateNestedManyWithoutUserInput
    messageReads?: MessageReadCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationSettingsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    name: string
    profileImageURL?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deviceTokens?: UserCreatedeviceTokensInput | string[]
    deletedAt?: Date | string | null
    households?: HouseholdMemberUncheckedCreateNestedManyWithoutUserInput
    messages?: MessageUncheckedCreateNestedManyWithoutAuthorInput
    threads?: ThreadUncheckedCreateNestedManyWithoutAuthorInput
    assignedChores?: ChoreAssignmentUncheckedCreateNestedManyWithoutUserInput
    expensesPaid?: ExpenseUncheckedCreateNestedManyWithoutPaidByInput
    expenseSplits?: ExpenseSplitUncheckedCreateNestedManyWithoutUserInput
    transactionsFrom?: TransactionUncheckedCreateNestedManyWithoutFromUserInput
    transactionsTo?: TransactionUncheckedCreateNestedManyWithoutToUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    oauthIntegrations?: OAuthIntegrationUncheckedCreateNestedManyWithoutUserInput
    eventsCreated?: EventUncheckedCreateNestedManyWithoutCreatedByInput
    choreSwapRequestsInitiated?: ChoreSwapRequestUncheckedCreateNestedManyWithoutRequestingUserInput
    choreSwapRequestsReceived?: ChoreSwapRequestUncheckedCreateNestedManyWithoutTargetUserInput
    reactions?: ReactionUncheckedCreateNestedManyWithoutUserInput
    mentions?: MentionUncheckedCreateNestedManyWithoutUserInput
    choreHistory?: ChoreHistoryUncheckedCreateNestedManyWithoutUserInput
    calendarEventHistory?: CalendarEventHistoryUncheckedCreateNestedManyWithoutUserInput
    expenseHistory?: ExpenseHistoryUncheckedCreateNestedManyWithoutUserInput
    messageReads?: MessageReadUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationSettingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationSettingsInput, UserUncheckedCreateWithoutNotificationSettingsInput>
  }

  export type HouseholdCreateWithoutNotificationSettingsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    currency?: string
    icon?: string | null
    timezone?: string
    language?: string
    deletedAt?: Date | string | null
    members?: HouseholdMemberCreateNestedManyWithoutHouseholdInput
    threads?: ThreadCreateNestedManyWithoutHouseholdInput
    chores?: ChoreCreateNestedManyWithoutHouseholdInput
    expenses?: ExpenseCreateNestedManyWithoutHouseholdInput
    events?: EventCreateNestedManyWithoutHouseholdInput
    choreTemplates?: ChoreTemplateCreateNestedManyWithoutHouseholdInput
  }

  export type HouseholdUncheckedCreateWithoutNotificationSettingsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    currency?: string
    icon?: string | null
    timezone?: string
    language?: string
    deletedAt?: Date | string | null
    members?: HouseholdMemberUncheckedCreateNestedManyWithoutHouseholdInput
    threads?: ThreadUncheckedCreateNestedManyWithoutHouseholdInput
    chores?: ChoreUncheckedCreateNestedManyWithoutHouseholdInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutHouseholdInput
    events?: EventUncheckedCreateNestedManyWithoutHouseholdInput
    choreTemplates?: ChoreTemplateUncheckedCreateNestedManyWithoutHouseholdInput
  }

  export type HouseholdCreateOrConnectWithoutNotificationSettingsInput = {
    where: HouseholdWhereUniqueInput
    create: XOR<HouseholdCreateWithoutNotificationSettingsInput, HouseholdUncheckedCreateWithoutNotificationSettingsInput>
  }

  export type UserUpsertWithoutNotificationSettingsInput = {
    update: XOR<UserUpdateWithoutNotificationSettingsInput, UserUncheckedUpdateWithoutNotificationSettingsInput>
    create: XOR<UserCreateWithoutNotificationSettingsInput, UserUncheckedCreateWithoutNotificationSettingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationSettingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationSettingsInput, UserUncheckedUpdateWithoutNotificationSettingsInput>
  }

  export type UserUpdateWithoutNotificationSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    profileImageURL?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deviceTokens?: UserUpdatedeviceTokensInput | string[]
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    households?: HouseholdMemberUpdateManyWithoutUserNestedInput
    messages?: MessageUpdateManyWithoutAuthorNestedInput
    threads?: ThreadUpdateManyWithoutAuthorNestedInput
    assignedChores?: ChoreAssignmentUpdateManyWithoutUserNestedInput
    expensesPaid?: ExpenseUpdateManyWithoutPaidByNestedInput
    expenseSplits?: ExpenseSplitUpdateManyWithoutUserNestedInput
    transactionsFrom?: TransactionUpdateManyWithoutFromUserNestedInput
    transactionsTo?: TransactionUpdateManyWithoutToUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    oauthIntegrations?: OAuthIntegrationUpdateManyWithoutUserNestedInput
    eventsCreated?: EventUpdateManyWithoutCreatedByNestedInput
    choreSwapRequestsInitiated?: ChoreSwapRequestUpdateManyWithoutRequestingUserNestedInput
    choreSwapRequestsReceived?: ChoreSwapRequestUpdateManyWithoutTargetUserNestedInput
    reactions?: ReactionUpdateManyWithoutUserNestedInput
    mentions?: MentionUpdateManyWithoutUserNestedInput
    choreHistory?: ChoreHistoryUpdateManyWithoutUserNestedInput
    calendarEventHistory?: CalendarEventHistoryUpdateManyWithoutUserNestedInput
    expenseHistory?: ExpenseHistoryUpdateManyWithoutUserNestedInput
    messageReads?: MessageReadUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    profileImageURL?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deviceTokens?: UserUpdatedeviceTokensInput | string[]
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    households?: HouseholdMemberUncheckedUpdateManyWithoutUserNestedInput
    messages?: MessageUncheckedUpdateManyWithoutAuthorNestedInput
    threads?: ThreadUncheckedUpdateManyWithoutAuthorNestedInput
    assignedChores?: ChoreAssignmentUncheckedUpdateManyWithoutUserNestedInput
    expensesPaid?: ExpenseUncheckedUpdateManyWithoutPaidByNestedInput
    expenseSplits?: ExpenseSplitUncheckedUpdateManyWithoutUserNestedInput
    transactionsFrom?: TransactionUncheckedUpdateManyWithoutFromUserNestedInput
    transactionsTo?: TransactionUncheckedUpdateManyWithoutToUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    oauthIntegrations?: OAuthIntegrationUncheckedUpdateManyWithoutUserNestedInput
    eventsCreated?: EventUncheckedUpdateManyWithoutCreatedByNestedInput
    choreSwapRequestsInitiated?: ChoreSwapRequestUncheckedUpdateManyWithoutRequestingUserNestedInput
    choreSwapRequestsReceived?: ChoreSwapRequestUncheckedUpdateManyWithoutTargetUserNestedInput
    reactions?: ReactionUncheckedUpdateManyWithoutUserNestedInput
    mentions?: MentionUncheckedUpdateManyWithoutUserNestedInput
    choreHistory?: ChoreHistoryUncheckedUpdateManyWithoutUserNestedInput
    calendarEventHistory?: CalendarEventHistoryUncheckedUpdateManyWithoutUserNestedInput
    expenseHistory?: ExpenseHistoryUncheckedUpdateManyWithoutUserNestedInput
    messageReads?: MessageReadUncheckedUpdateManyWithoutUserNestedInput
  }

  export type HouseholdUpsertWithoutNotificationSettingsInput = {
    update: XOR<HouseholdUpdateWithoutNotificationSettingsInput, HouseholdUncheckedUpdateWithoutNotificationSettingsInput>
    create: XOR<HouseholdCreateWithoutNotificationSettingsInput, HouseholdUncheckedCreateWithoutNotificationSettingsInput>
    where?: HouseholdWhereInput
  }

  export type HouseholdUpdateToOneWithWhereWithoutNotificationSettingsInput = {
    where?: HouseholdWhereInput
    data: XOR<HouseholdUpdateWithoutNotificationSettingsInput, HouseholdUncheckedUpdateWithoutNotificationSettingsInput>
  }

  export type HouseholdUpdateWithoutNotificationSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    members?: HouseholdMemberUpdateManyWithoutHouseholdNestedInput
    threads?: ThreadUpdateManyWithoutHouseholdNestedInput
    chores?: ChoreUpdateManyWithoutHouseholdNestedInput
    expenses?: ExpenseUpdateManyWithoutHouseholdNestedInput
    events?: EventUpdateManyWithoutHouseholdNestedInput
    choreTemplates?: ChoreTemplateUpdateManyWithoutHouseholdNestedInput
  }

  export type HouseholdUncheckedUpdateWithoutNotificationSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    members?: HouseholdMemberUncheckedUpdateManyWithoutHouseholdNestedInput
    threads?: ThreadUncheckedUpdateManyWithoutHouseholdNestedInput
    chores?: ChoreUncheckedUpdateManyWithoutHouseholdNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutHouseholdNestedInput
    events?: EventUncheckedUpdateManyWithoutHouseholdNestedInput
    choreTemplates?: ChoreTemplateUncheckedUpdateManyWithoutHouseholdNestedInput
  }

  export type UserCreateWithoutOauthIntegrationsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    name: string
    profileImageURL?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deviceTokens?: UserCreatedeviceTokensInput | string[]
    deletedAt?: Date | string | null
    households?: HouseholdMemberCreateNestedManyWithoutUserInput
    messages?: MessageCreateNestedManyWithoutAuthorInput
    threads?: ThreadCreateNestedManyWithoutAuthorInput
    assignedChores?: ChoreAssignmentCreateNestedManyWithoutUserInput
    expensesPaid?: ExpenseCreateNestedManyWithoutPaidByInput
    expenseSplits?: ExpenseSplitCreateNestedManyWithoutUserInput
    transactionsFrom?: TransactionCreateNestedManyWithoutFromUserInput
    transactionsTo?: TransactionCreateNestedManyWithoutToUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    eventsCreated?: EventCreateNestedManyWithoutCreatedByInput
    choreSwapRequestsInitiated?: ChoreSwapRequestCreateNestedManyWithoutRequestingUserInput
    choreSwapRequestsReceived?: ChoreSwapRequestCreateNestedManyWithoutTargetUserInput
    reactions?: ReactionCreateNestedManyWithoutUserInput
    mentions?: MentionCreateNestedManyWithoutUserInput
    choreHistory?: ChoreHistoryCreateNestedManyWithoutUserInput
    notificationSettings?: NotificationSettingsCreateNestedManyWithoutUserInput
    calendarEventHistory?: CalendarEventHistoryCreateNestedManyWithoutUserInput
    expenseHistory?: ExpenseHistoryCreateNestedManyWithoutUserInput
    messageReads?: MessageReadCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOauthIntegrationsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    name: string
    profileImageURL?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deviceTokens?: UserCreatedeviceTokensInput | string[]
    deletedAt?: Date | string | null
    households?: HouseholdMemberUncheckedCreateNestedManyWithoutUserInput
    messages?: MessageUncheckedCreateNestedManyWithoutAuthorInput
    threads?: ThreadUncheckedCreateNestedManyWithoutAuthorInput
    assignedChores?: ChoreAssignmentUncheckedCreateNestedManyWithoutUserInput
    expensesPaid?: ExpenseUncheckedCreateNestedManyWithoutPaidByInput
    expenseSplits?: ExpenseSplitUncheckedCreateNestedManyWithoutUserInput
    transactionsFrom?: TransactionUncheckedCreateNestedManyWithoutFromUserInput
    transactionsTo?: TransactionUncheckedCreateNestedManyWithoutToUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    eventsCreated?: EventUncheckedCreateNestedManyWithoutCreatedByInput
    choreSwapRequestsInitiated?: ChoreSwapRequestUncheckedCreateNestedManyWithoutRequestingUserInput
    choreSwapRequestsReceived?: ChoreSwapRequestUncheckedCreateNestedManyWithoutTargetUserInput
    reactions?: ReactionUncheckedCreateNestedManyWithoutUserInput
    mentions?: MentionUncheckedCreateNestedManyWithoutUserInput
    choreHistory?: ChoreHistoryUncheckedCreateNestedManyWithoutUserInput
    notificationSettings?: NotificationSettingsUncheckedCreateNestedManyWithoutUserInput
    calendarEventHistory?: CalendarEventHistoryUncheckedCreateNestedManyWithoutUserInput
    expenseHistory?: ExpenseHistoryUncheckedCreateNestedManyWithoutUserInput
    messageReads?: MessageReadUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOauthIntegrationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOauthIntegrationsInput, UserUncheckedCreateWithoutOauthIntegrationsInput>
  }

  export type UserUpsertWithoutOauthIntegrationsInput = {
    update: XOR<UserUpdateWithoutOauthIntegrationsInput, UserUncheckedUpdateWithoutOauthIntegrationsInput>
    create: XOR<UserCreateWithoutOauthIntegrationsInput, UserUncheckedCreateWithoutOauthIntegrationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOauthIntegrationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOauthIntegrationsInput, UserUncheckedUpdateWithoutOauthIntegrationsInput>
  }

  export type UserUpdateWithoutOauthIntegrationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    profileImageURL?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deviceTokens?: UserUpdatedeviceTokensInput | string[]
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    households?: HouseholdMemberUpdateManyWithoutUserNestedInput
    messages?: MessageUpdateManyWithoutAuthorNestedInput
    threads?: ThreadUpdateManyWithoutAuthorNestedInput
    assignedChores?: ChoreAssignmentUpdateManyWithoutUserNestedInput
    expensesPaid?: ExpenseUpdateManyWithoutPaidByNestedInput
    expenseSplits?: ExpenseSplitUpdateManyWithoutUserNestedInput
    transactionsFrom?: TransactionUpdateManyWithoutFromUserNestedInput
    transactionsTo?: TransactionUpdateManyWithoutToUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    eventsCreated?: EventUpdateManyWithoutCreatedByNestedInput
    choreSwapRequestsInitiated?: ChoreSwapRequestUpdateManyWithoutRequestingUserNestedInput
    choreSwapRequestsReceived?: ChoreSwapRequestUpdateManyWithoutTargetUserNestedInput
    reactions?: ReactionUpdateManyWithoutUserNestedInput
    mentions?: MentionUpdateManyWithoutUserNestedInput
    choreHistory?: ChoreHistoryUpdateManyWithoutUserNestedInput
    notificationSettings?: NotificationSettingsUpdateManyWithoutUserNestedInput
    calendarEventHistory?: CalendarEventHistoryUpdateManyWithoutUserNestedInput
    expenseHistory?: ExpenseHistoryUpdateManyWithoutUserNestedInput
    messageReads?: MessageReadUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOauthIntegrationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    profileImageURL?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deviceTokens?: UserUpdatedeviceTokensInput | string[]
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    households?: HouseholdMemberUncheckedUpdateManyWithoutUserNestedInput
    messages?: MessageUncheckedUpdateManyWithoutAuthorNestedInput
    threads?: ThreadUncheckedUpdateManyWithoutAuthorNestedInput
    assignedChores?: ChoreAssignmentUncheckedUpdateManyWithoutUserNestedInput
    expensesPaid?: ExpenseUncheckedUpdateManyWithoutPaidByNestedInput
    expenseSplits?: ExpenseSplitUncheckedUpdateManyWithoutUserNestedInput
    transactionsFrom?: TransactionUncheckedUpdateManyWithoutFromUserNestedInput
    transactionsTo?: TransactionUncheckedUpdateManyWithoutToUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    eventsCreated?: EventUncheckedUpdateManyWithoutCreatedByNestedInput
    choreSwapRequestsInitiated?: ChoreSwapRequestUncheckedUpdateManyWithoutRequestingUserNestedInput
    choreSwapRequestsReceived?: ChoreSwapRequestUncheckedUpdateManyWithoutTargetUserNestedInput
    reactions?: ReactionUncheckedUpdateManyWithoutUserNestedInput
    mentions?: MentionUncheckedUpdateManyWithoutUserNestedInput
    choreHistory?: ChoreHistoryUncheckedUpdateManyWithoutUserNestedInput
    notificationSettings?: NotificationSettingsUncheckedUpdateManyWithoutUserNestedInput
    calendarEventHistory?: CalendarEventHistoryUncheckedUpdateManyWithoutUserNestedInput
    expenseHistory?: ExpenseHistoryUncheckedUpdateManyWithoutUserNestedInput
    messageReads?: MessageReadUncheckedUpdateManyWithoutUserNestedInput
  }

  export type HouseholdMemberCreateManyUserInput = {
    id?: string
    householdId: string
    role?: $Enums.HouseholdRole
    joinedAt?: Date | string
    leftAt?: Date | string | null
    isInvited?: boolean
    isAccepted?: boolean
    isRejected?: boolean
    isSelected?: boolean
    lastAssignedChoreAt?: Date | string | null
  }

  export type MessageCreateManyAuthorInput = {
    id?: string
    threadId: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ThreadCreateManyAuthorInput = {
    id?: string
    householdId: string
    title?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ChoreAssignmentCreateManyUserInput = {
    id?: string
    choreId: string
    assignedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type ExpenseCreateManyPaidByInput = {
    id?: string
    householdId: string
    amount: number
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    dueDate?: Date | string | null
    deletedAt?: Date | string | null
    category: $Enums.ExpenseCategory
  }

  export type ExpenseSplitCreateManyUserInput = {
    id?: string
    expenseId: string
    amount: number
  }

  export type TransactionCreateManyFromUserInput = {
    id?: string
    expenseId: string
    toUserId: string
    amount: number
    status?: $Enums.TransactionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type TransactionCreateManyToUserInput = {
    id?: string
    expenseId: string
    fromUserId: string
    amount: number
    status?: $Enums.TransactionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type NotificationCreateManyUserInput = {
    id?: string
    type: $Enums.NotificationType
    message: string
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OAuthIntegrationCreateManyUserInput = {
    id?: string
    provider: $Enums.Provider
    accessToken: string
    refreshToken?: string | null
    expiresAt?: Date | string | null
  }

  export type EventCreateManyCreatedByInput = {
    id?: string
    householdId: string
    title: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    choreId?: string | null
    recurrenceRuleId?: string | null
    category?: $Enums.EventCategory
    isAllDay?: boolean
    location?: string | null
    isPrivate?: boolean
    status?: $Enums.EventStatus
    deletedAt?: Date | string | null
  }

  export type ChoreSwapRequestCreateManyRequestingUserInput = {
    id?: string
    choreId: string
    targetUserId: string
    status?: $Enums.ChoreSwapRequestStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChoreSwapRequestCreateManyTargetUserInput = {
    id?: string
    choreId: string
    requestingUserId: string
    status?: $Enums.ChoreSwapRequestStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReactionCreateManyUserInput = {
    id?: string
    messageId: string
    emoji: string
    type: $Enums.ReactionType
    createdAt?: Date | string
  }

  export type MentionCreateManyUserInput = {
    id?: string
    messageId: string
    mentionedAt?: Date | string
  }

  export type ChoreHistoryCreateManyUserInput = {
    id?: string
    choreId: string
    action: $Enums.ChoreAction
    changedAt?: Date | string
  }

  export type NotificationSettingsCreateManyUserInput = {
    id?: string
    householdId?: string | null
    messageNotif?: boolean
    mentionsNotif?: boolean
    reactionsNotif?: boolean
    choreNotif?: boolean
    financeNotif?: boolean
    calendarNotif?: boolean
    remindersNotif?: boolean
  }

  export type CalendarEventHistoryCreateManyUserInput = {
    id?: string
    eventId: string
    action: $Enums.CalendarEventAction
    changedAt?: Date | string
  }

  export type ExpenseHistoryCreateManyUserInput = {
    id?: string
    expenseId: string
    action: $Enums.ExpenseAction
    changedAt?: Date | string
  }

  export type MessageReadCreateManyUserInput = {
    id?: string
    messageId: string
    readAt?: Date | string
  }

  export type HouseholdMemberUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumHouseholdRoleFieldUpdateOperationsInput | $Enums.HouseholdRole
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isInvited?: BoolFieldUpdateOperationsInput | boolean
    isAccepted?: BoolFieldUpdateOperationsInput | boolean
    isRejected?: BoolFieldUpdateOperationsInput | boolean
    isSelected?: BoolFieldUpdateOperationsInput | boolean
    lastAssignedChoreAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    household?: HouseholdUpdateOneRequiredWithoutMembersNestedInput
    threads?: ThreadUpdateManyWithoutParticipantsNestedInput
  }

  export type HouseholdMemberUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    role?: EnumHouseholdRoleFieldUpdateOperationsInput | $Enums.HouseholdRole
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isInvited?: BoolFieldUpdateOperationsInput | boolean
    isAccepted?: BoolFieldUpdateOperationsInput | boolean
    isRejected?: BoolFieldUpdateOperationsInput | boolean
    isSelected?: BoolFieldUpdateOperationsInput | boolean
    lastAssignedChoreAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    threads?: ThreadUncheckedUpdateManyWithoutParticipantsNestedInput
  }

  export type HouseholdMemberUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    role?: EnumHouseholdRoleFieldUpdateOperationsInput | $Enums.HouseholdRole
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isInvited?: BoolFieldUpdateOperationsInput | boolean
    isAccepted?: BoolFieldUpdateOperationsInput | boolean
    isRejected?: BoolFieldUpdateOperationsInput | boolean
    isSelected?: BoolFieldUpdateOperationsInput | boolean
    lastAssignedChoreAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MessageUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    thread?: ThreadUpdateOneRequiredWithoutMessagesNestedInput
    attachments?: AttachmentUpdateManyWithoutMessageNestedInput
    reactions?: ReactionUpdateManyWithoutMessageNestedInput
    mentions?: MentionUpdateManyWithoutMessageNestedInput
    reads?: MessageReadUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    threadId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attachments?: AttachmentUncheckedUpdateManyWithoutMessageNestedInput
    reactions?: ReactionUncheckedUpdateManyWithoutMessageNestedInput
    mentions?: MentionUncheckedUpdateManyWithoutMessageNestedInput
    reads?: MessageReadUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateManyWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    threadId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ThreadUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    household?: HouseholdUpdateOneRequiredWithoutThreadsNestedInput
    messages?: MessageUpdateManyWithoutThreadNestedInput
    participants?: HouseholdMemberUpdateManyWithoutThreadsNestedInput
  }

  export type ThreadUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: MessageUncheckedUpdateManyWithoutThreadNestedInput
    participants?: HouseholdMemberUncheckedUpdateManyWithoutThreadsNestedInput
  }

  export type ThreadUncheckedUpdateManyWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ChoreAssignmentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chore?: ChoreUpdateOneRequiredWithoutAssignedUsersNestedInput
  }

  export type ChoreAssignmentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    choreId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ChoreAssignmentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    choreId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ExpenseUpdateWithoutPaidByInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: EnumExpenseCategoryFieldUpdateOperationsInput | $Enums.ExpenseCategory
    household?: HouseholdUpdateOneRequiredWithoutExpensesNestedInput
    splits?: ExpenseSplitUpdateManyWithoutExpenseNestedInput
    transactions?: TransactionUpdateManyWithoutExpenseNestedInput
    receipts?: ReceiptUpdateManyWithoutExpenseNestedInput
    history?: ExpenseHistoryUpdateManyWithoutExpenseNestedInput
  }

  export type ExpenseUncheckedUpdateWithoutPaidByInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: EnumExpenseCategoryFieldUpdateOperationsInput | $Enums.ExpenseCategory
    splits?: ExpenseSplitUncheckedUpdateManyWithoutExpenseNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutExpenseNestedInput
    receipts?: ReceiptUncheckedUpdateManyWithoutExpenseNestedInput
    history?: ExpenseHistoryUncheckedUpdateManyWithoutExpenseNestedInput
  }

  export type ExpenseUncheckedUpdateManyWithoutPaidByInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: EnumExpenseCategoryFieldUpdateOperationsInput | $Enums.ExpenseCategory
  }

  export type ExpenseSplitUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    expense?: ExpenseUpdateOneRequiredWithoutSplitsNestedInput
  }

  export type ExpenseSplitUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    expenseId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
  }

  export type ExpenseSplitUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    expenseId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
  }

  export type TransactionUpdateWithoutFromUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expense?: ExpenseUpdateOneRequiredWithoutTransactionsNestedInput
    toUser?: UserUpdateOneRequiredWithoutTransactionsToNestedInput
  }

  export type TransactionUncheckedUpdateWithoutFromUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    expenseId?: StringFieldUpdateOperationsInput | string
    toUserId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TransactionUncheckedUpdateManyWithoutFromUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    expenseId?: StringFieldUpdateOperationsInput | string
    toUserId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TransactionUpdateWithoutToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expense?: ExpenseUpdateOneRequiredWithoutTransactionsNestedInput
    fromUser?: UserUpdateOneRequiredWithoutTransactionsFromNestedInput
  }

  export type TransactionUncheckedUpdateWithoutToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    expenseId?: StringFieldUpdateOperationsInput | string
    fromUserId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TransactionUncheckedUpdateManyWithoutToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    expenseId?: StringFieldUpdateOperationsInput | string
    fromUserId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OAuthIntegrationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumProviderFieldUpdateOperationsInput | $Enums.Provider
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OAuthIntegrationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumProviderFieldUpdateOperationsInput | $Enums.Provider
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OAuthIntegrationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumProviderFieldUpdateOperationsInput | $Enums.Provider
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EventUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    choreId?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumEventCategoryFieldUpdateOperationsInput | $Enums.EventCategory
    isAllDay?: BoolFieldUpdateOperationsInput | boolean
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumEventStatusFieldUpdateOperationsInput | $Enums.EventStatus
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminders?: EventReminderUpdateManyWithoutEventNestedInput
    household?: HouseholdUpdateOneRequiredWithoutEventsNestedInput
    chore?: ChoreUpdateOneWithoutEventNestedInput
    recurrenceRule?: RecurrenceRuleUpdateOneWithoutEventsNestedInput
    history?: CalendarEventHistoryUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    choreId?: NullableStringFieldUpdateOperationsInput | string | null
    recurrenceRuleId?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumEventCategoryFieldUpdateOperationsInput | $Enums.EventCategory
    isAllDay?: BoolFieldUpdateOperationsInput | boolean
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumEventStatusFieldUpdateOperationsInput | $Enums.EventStatus
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminders?: EventReminderUncheckedUpdateManyWithoutEventNestedInput
    chore?: ChoreUncheckedUpdateOneWithoutEventNestedInput
    history?: CalendarEventHistoryUncheckedUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    choreId?: NullableStringFieldUpdateOperationsInput | string | null
    recurrenceRuleId?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumEventCategoryFieldUpdateOperationsInput | $Enums.EventCategory
    isAllDay?: BoolFieldUpdateOperationsInput | boolean
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumEventStatusFieldUpdateOperationsInput | $Enums.EventStatus
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ChoreSwapRequestUpdateWithoutRequestingUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumChoreSwapRequestStatusFieldUpdateOperationsInput | $Enums.ChoreSwapRequestStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    targetUser?: UserUpdateOneRequiredWithoutChoreSwapRequestsReceivedNestedInput
    chore?: ChoreUpdateOneRequiredWithoutChoreSwapRequestsNestedInput
  }

  export type ChoreSwapRequestUncheckedUpdateWithoutRequestingUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    choreId?: StringFieldUpdateOperationsInput | string
    targetUserId?: StringFieldUpdateOperationsInput | string
    status?: EnumChoreSwapRequestStatusFieldUpdateOperationsInput | $Enums.ChoreSwapRequestStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChoreSwapRequestUncheckedUpdateManyWithoutRequestingUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    choreId?: StringFieldUpdateOperationsInput | string
    targetUserId?: StringFieldUpdateOperationsInput | string
    status?: EnumChoreSwapRequestStatusFieldUpdateOperationsInput | $Enums.ChoreSwapRequestStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChoreSwapRequestUpdateWithoutTargetUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumChoreSwapRequestStatusFieldUpdateOperationsInput | $Enums.ChoreSwapRequestStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requestingUser?: UserUpdateOneRequiredWithoutChoreSwapRequestsInitiatedNestedInput
    chore?: ChoreUpdateOneRequiredWithoutChoreSwapRequestsNestedInput
  }

  export type ChoreSwapRequestUncheckedUpdateWithoutTargetUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    choreId?: StringFieldUpdateOperationsInput | string
    requestingUserId?: StringFieldUpdateOperationsInput | string
    status?: EnumChoreSwapRequestStatusFieldUpdateOperationsInput | $Enums.ChoreSwapRequestStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChoreSwapRequestUncheckedUpdateManyWithoutTargetUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    choreId?: StringFieldUpdateOperationsInput | string
    requestingUserId?: StringFieldUpdateOperationsInput | string
    status?: EnumChoreSwapRequestStatusFieldUpdateOperationsInput | $Enums.ChoreSwapRequestStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReactionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    emoji?: StringFieldUpdateOperationsInput | string
    type?: EnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: MessageUpdateOneRequiredWithoutReactionsNestedInput
  }

  export type ReactionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    emoji?: StringFieldUpdateOperationsInput | string
    type?: EnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReactionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    emoji?: StringFieldUpdateOperationsInput | string
    type?: EnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MentionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    mentionedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: MessageUpdateOneRequiredWithoutMentionsNestedInput
  }

  export type MentionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    mentionedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MentionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    mentionedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChoreHistoryUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumChoreActionFieldUpdateOperationsInput | $Enums.ChoreAction
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chore?: ChoreUpdateOneRequiredWithoutHistoryNestedInput
  }

  export type ChoreHistoryUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    choreId?: StringFieldUpdateOperationsInput | string
    action?: EnumChoreActionFieldUpdateOperationsInput | $Enums.ChoreAction
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChoreHistoryUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    choreId?: StringFieldUpdateOperationsInput | string
    action?: EnumChoreActionFieldUpdateOperationsInput | $Enums.ChoreAction
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationSettingsUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageNotif?: BoolFieldUpdateOperationsInput | boolean
    mentionsNotif?: BoolFieldUpdateOperationsInput | boolean
    reactionsNotif?: BoolFieldUpdateOperationsInput | boolean
    choreNotif?: BoolFieldUpdateOperationsInput | boolean
    financeNotif?: BoolFieldUpdateOperationsInput | boolean
    calendarNotif?: BoolFieldUpdateOperationsInput | boolean
    remindersNotif?: BoolFieldUpdateOperationsInput | boolean
    household?: HouseholdUpdateOneWithoutNotificationSettingsNestedInput
  }

  export type NotificationSettingsUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: NullableStringFieldUpdateOperationsInput | string | null
    messageNotif?: BoolFieldUpdateOperationsInput | boolean
    mentionsNotif?: BoolFieldUpdateOperationsInput | boolean
    reactionsNotif?: BoolFieldUpdateOperationsInput | boolean
    choreNotif?: BoolFieldUpdateOperationsInput | boolean
    financeNotif?: BoolFieldUpdateOperationsInput | boolean
    calendarNotif?: BoolFieldUpdateOperationsInput | boolean
    remindersNotif?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NotificationSettingsUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: NullableStringFieldUpdateOperationsInput | string | null
    messageNotif?: BoolFieldUpdateOperationsInput | boolean
    mentionsNotif?: BoolFieldUpdateOperationsInput | boolean
    reactionsNotif?: BoolFieldUpdateOperationsInput | boolean
    choreNotif?: BoolFieldUpdateOperationsInput | boolean
    financeNotif?: BoolFieldUpdateOperationsInput | boolean
    calendarNotif?: BoolFieldUpdateOperationsInput | boolean
    remindersNotif?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CalendarEventHistoryUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumCalendarEventActionFieldUpdateOperationsInput | $Enums.CalendarEventAction
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    event?: EventUpdateOneRequiredWithoutHistoryNestedInput
  }

  export type CalendarEventHistoryUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    action?: EnumCalendarEventActionFieldUpdateOperationsInput | $Enums.CalendarEventAction
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalendarEventHistoryUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    action?: EnumCalendarEventActionFieldUpdateOperationsInput | $Enums.CalendarEventAction
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseHistoryUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumExpenseActionFieldUpdateOperationsInput | $Enums.ExpenseAction
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expense?: ExpenseUpdateOneRequiredWithoutHistoryNestedInput
  }

  export type ExpenseHistoryUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    expenseId?: StringFieldUpdateOperationsInput | string
    action?: EnumExpenseActionFieldUpdateOperationsInput | $Enums.ExpenseAction
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseHistoryUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    expenseId?: StringFieldUpdateOperationsInput | string
    action?: EnumExpenseActionFieldUpdateOperationsInput | $Enums.ExpenseAction
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageReadUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: MessageUpdateOneRequiredWithoutReadsNestedInput
  }

  export type MessageReadUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageReadUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HouseholdMemberCreateManyHouseholdInput = {
    id?: string
    userId: string
    role?: $Enums.HouseholdRole
    joinedAt?: Date | string
    leftAt?: Date | string | null
    isInvited?: boolean
    isAccepted?: boolean
    isRejected?: boolean
    isSelected?: boolean
    lastAssignedChoreAt?: Date | string | null
  }

  export type ThreadCreateManyHouseholdInput = {
    id?: string
    authorId: string
    title?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ChoreCreateManyHouseholdInput = {
    id?: string
    title: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dueDate?: Date | string | null
    status?: $Enums.ChoreStatus
    priority?: number | null
    eventId?: string | null
    recurrenceRuleId?: string | null
    deletedAt?: Date | string | null
  }

  export type ExpenseCreateManyHouseholdInput = {
    id?: string
    amount: number
    description: string
    paidById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    dueDate?: Date | string | null
    deletedAt?: Date | string | null
    category: $Enums.ExpenseCategory
  }

  export type EventCreateManyHouseholdInput = {
    id?: string
    title: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    choreId?: string | null
    recurrenceRuleId?: string | null
    category?: $Enums.EventCategory
    isAllDay?: boolean
    location?: string | null
    isPrivate?: boolean
    status?: $Enums.EventStatus
    deletedAt?: Date | string | null
  }

  export type ChoreTemplateCreateManyHouseholdInput = {
    id?: string
    title: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationSettingsCreateManyHouseholdInput = {
    id?: string
    userId?: string | null
    messageNotif?: boolean
    mentionsNotif?: boolean
    reactionsNotif?: boolean
    choreNotif?: boolean
    financeNotif?: boolean
    calendarNotif?: boolean
    remindersNotif?: boolean
  }

  export type HouseholdMemberUpdateWithoutHouseholdInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumHouseholdRoleFieldUpdateOperationsInput | $Enums.HouseholdRole
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isInvited?: BoolFieldUpdateOperationsInput | boolean
    isAccepted?: BoolFieldUpdateOperationsInput | boolean
    isRejected?: BoolFieldUpdateOperationsInput | boolean
    isSelected?: BoolFieldUpdateOperationsInput | boolean
    lastAssignedChoreAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutHouseholdsNestedInput
    threads?: ThreadUpdateManyWithoutParticipantsNestedInput
  }

  export type HouseholdMemberUncheckedUpdateWithoutHouseholdInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumHouseholdRoleFieldUpdateOperationsInput | $Enums.HouseholdRole
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isInvited?: BoolFieldUpdateOperationsInput | boolean
    isAccepted?: BoolFieldUpdateOperationsInput | boolean
    isRejected?: BoolFieldUpdateOperationsInput | boolean
    isSelected?: BoolFieldUpdateOperationsInput | boolean
    lastAssignedChoreAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    threads?: ThreadUncheckedUpdateManyWithoutParticipantsNestedInput
  }

  export type HouseholdMemberUncheckedUpdateManyWithoutHouseholdInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumHouseholdRoleFieldUpdateOperationsInput | $Enums.HouseholdRole
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isInvited?: BoolFieldUpdateOperationsInput | boolean
    isAccepted?: BoolFieldUpdateOperationsInput | boolean
    isRejected?: BoolFieldUpdateOperationsInput | boolean
    isSelected?: BoolFieldUpdateOperationsInput | boolean
    lastAssignedChoreAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ThreadUpdateWithoutHouseholdInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    author?: UserUpdateOneRequiredWithoutThreadsNestedInput
    messages?: MessageUpdateManyWithoutThreadNestedInput
    participants?: HouseholdMemberUpdateManyWithoutThreadsNestedInput
  }

  export type ThreadUncheckedUpdateWithoutHouseholdInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: MessageUncheckedUpdateManyWithoutThreadNestedInput
    participants?: HouseholdMemberUncheckedUpdateManyWithoutThreadsNestedInput
  }

  export type ThreadUncheckedUpdateManyWithoutHouseholdInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ChoreUpdateWithoutHouseholdInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumChoreStatusFieldUpdateOperationsInput | $Enums.ChoreStatus
    priority?: NullableIntFieldUpdateOperationsInput | number | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtasks?: SubtaskUpdateManyWithoutChoreNestedInput
    assignedUsers?: ChoreAssignmentUpdateManyWithoutChoreNestedInput
    event?: EventUpdateOneWithoutChoreNestedInput
    choreSwapRequests?: ChoreSwapRequestUpdateManyWithoutChoreNestedInput
    recurrenceRule?: RecurrenceRuleUpdateOneWithoutChoresNestedInput
    history?: ChoreHistoryUpdateManyWithoutChoreNestedInput
  }

  export type ChoreUncheckedUpdateWithoutHouseholdInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumChoreStatusFieldUpdateOperationsInput | $Enums.ChoreStatus
    priority?: NullableIntFieldUpdateOperationsInput | number | null
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    recurrenceRuleId?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtasks?: SubtaskUncheckedUpdateManyWithoutChoreNestedInput
    assignedUsers?: ChoreAssignmentUncheckedUpdateManyWithoutChoreNestedInput
    choreSwapRequests?: ChoreSwapRequestUncheckedUpdateManyWithoutChoreNestedInput
    history?: ChoreHistoryUncheckedUpdateManyWithoutChoreNestedInput
  }

  export type ChoreUncheckedUpdateManyWithoutHouseholdInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumChoreStatusFieldUpdateOperationsInput | $Enums.ChoreStatus
    priority?: NullableIntFieldUpdateOperationsInput | number | null
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    recurrenceRuleId?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ExpenseUpdateWithoutHouseholdInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: EnumExpenseCategoryFieldUpdateOperationsInput | $Enums.ExpenseCategory
    paidBy?: UserUpdateOneRequiredWithoutExpensesPaidNestedInput
    splits?: ExpenseSplitUpdateManyWithoutExpenseNestedInput
    transactions?: TransactionUpdateManyWithoutExpenseNestedInput
    receipts?: ReceiptUpdateManyWithoutExpenseNestedInput
    history?: ExpenseHistoryUpdateManyWithoutExpenseNestedInput
  }

  export type ExpenseUncheckedUpdateWithoutHouseholdInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    paidById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: EnumExpenseCategoryFieldUpdateOperationsInput | $Enums.ExpenseCategory
    splits?: ExpenseSplitUncheckedUpdateManyWithoutExpenseNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutExpenseNestedInput
    receipts?: ReceiptUncheckedUpdateManyWithoutExpenseNestedInput
    history?: ExpenseHistoryUncheckedUpdateManyWithoutExpenseNestedInput
  }

  export type ExpenseUncheckedUpdateManyWithoutHouseholdInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    paidById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: EnumExpenseCategoryFieldUpdateOperationsInput | $Enums.ExpenseCategory
  }

  export type EventUpdateWithoutHouseholdInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    choreId?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumEventCategoryFieldUpdateOperationsInput | $Enums.EventCategory
    isAllDay?: BoolFieldUpdateOperationsInput | boolean
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumEventStatusFieldUpdateOperationsInput | $Enums.EventStatus
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminders?: EventReminderUpdateManyWithoutEventNestedInput
    createdBy?: UserUpdateOneRequiredWithoutEventsCreatedNestedInput
    chore?: ChoreUpdateOneWithoutEventNestedInput
    recurrenceRule?: RecurrenceRuleUpdateOneWithoutEventsNestedInput
    history?: CalendarEventHistoryUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateWithoutHouseholdInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    choreId?: NullableStringFieldUpdateOperationsInput | string | null
    recurrenceRuleId?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumEventCategoryFieldUpdateOperationsInput | $Enums.EventCategory
    isAllDay?: BoolFieldUpdateOperationsInput | boolean
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumEventStatusFieldUpdateOperationsInput | $Enums.EventStatus
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminders?: EventReminderUncheckedUpdateManyWithoutEventNestedInput
    chore?: ChoreUncheckedUpdateOneWithoutEventNestedInput
    history?: CalendarEventHistoryUncheckedUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateManyWithoutHouseholdInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    choreId?: NullableStringFieldUpdateOperationsInput | string | null
    recurrenceRuleId?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumEventCategoryFieldUpdateOperationsInput | $Enums.EventCategory
    isAllDay?: BoolFieldUpdateOperationsInput | boolean
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumEventStatusFieldUpdateOperationsInput | $Enums.EventStatus
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ChoreTemplateUpdateWithoutHouseholdInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subtasks?: SubtaskTemplateUpdateManyWithoutChoreTemplateNestedInput
  }

  export type ChoreTemplateUncheckedUpdateWithoutHouseholdInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subtasks?: SubtaskTemplateUncheckedUpdateManyWithoutChoreTemplateNestedInput
  }

  export type ChoreTemplateUncheckedUpdateManyWithoutHouseholdInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationSettingsUpdateWithoutHouseholdInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageNotif?: BoolFieldUpdateOperationsInput | boolean
    mentionsNotif?: BoolFieldUpdateOperationsInput | boolean
    reactionsNotif?: BoolFieldUpdateOperationsInput | boolean
    choreNotif?: BoolFieldUpdateOperationsInput | boolean
    financeNotif?: BoolFieldUpdateOperationsInput | boolean
    calendarNotif?: BoolFieldUpdateOperationsInput | boolean
    remindersNotif?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneWithoutNotificationSettingsNestedInput
  }

  export type NotificationSettingsUncheckedUpdateWithoutHouseholdInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    messageNotif?: BoolFieldUpdateOperationsInput | boolean
    mentionsNotif?: BoolFieldUpdateOperationsInput | boolean
    reactionsNotif?: BoolFieldUpdateOperationsInput | boolean
    choreNotif?: BoolFieldUpdateOperationsInput | boolean
    financeNotif?: BoolFieldUpdateOperationsInput | boolean
    calendarNotif?: BoolFieldUpdateOperationsInput | boolean
    remindersNotif?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NotificationSettingsUncheckedUpdateManyWithoutHouseholdInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    messageNotif?: BoolFieldUpdateOperationsInput | boolean
    mentionsNotif?: BoolFieldUpdateOperationsInput | boolean
    reactionsNotif?: BoolFieldUpdateOperationsInput | boolean
    choreNotif?: BoolFieldUpdateOperationsInput | boolean
    financeNotif?: BoolFieldUpdateOperationsInput | boolean
    calendarNotif?: BoolFieldUpdateOperationsInput | boolean
    remindersNotif?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ThreadUpdateWithoutParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    household?: HouseholdUpdateOneRequiredWithoutThreadsNestedInput
    author?: UserUpdateOneRequiredWithoutThreadsNestedInput
    messages?: MessageUpdateManyWithoutThreadNestedInput
  }

  export type ThreadUncheckedUpdateWithoutParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: MessageUncheckedUpdateManyWithoutThreadNestedInput
  }

  export type ThreadUncheckedUpdateManyWithoutParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ChoreCreateManyRecurrenceRuleInput = {
    id?: string
    householdId: string
    title: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dueDate?: Date | string | null
    status?: $Enums.ChoreStatus
    priority?: number | null
    eventId?: string | null
    deletedAt?: Date | string | null
  }

  export type EventCreateManyRecurrenceRuleInput = {
    id?: string
    householdId: string
    title: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    choreId?: string | null
    category?: $Enums.EventCategory
    isAllDay?: boolean
    location?: string | null
    isPrivate?: boolean
    status?: $Enums.EventStatus
    deletedAt?: Date | string | null
  }

  export type ChoreUpdateWithoutRecurrenceRuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumChoreStatusFieldUpdateOperationsInput | $Enums.ChoreStatus
    priority?: NullableIntFieldUpdateOperationsInput | number | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    household?: HouseholdUpdateOneRequiredWithoutChoresNestedInput
    subtasks?: SubtaskUpdateManyWithoutChoreNestedInput
    assignedUsers?: ChoreAssignmentUpdateManyWithoutChoreNestedInput
    event?: EventUpdateOneWithoutChoreNestedInput
    choreSwapRequests?: ChoreSwapRequestUpdateManyWithoutChoreNestedInput
    history?: ChoreHistoryUpdateManyWithoutChoreNestedInput
  }

  export type ChoreUncheckedUpdateWithoutRecurrenceRuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumChoreStatusFieldUpdateOperationsInput | $Enums.ChoreStatus
    priority?: NullableIntFieldUpdateOperationsInput | number | null
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtasks?: SubtaskUncheckedUpdateManyWithoutChoreNestedInput
    assignedUsers?: ChoreAssignmentUncheckedUpdateManyWithoutChoreNestedInput
    choreSwapRequests?: ChoreSwapRequestUncheckedUpdateManyWithoutChoreNestedInput
    history?: ChoreHistoryUncheckedUpdateManyWithoutChoreNestedInput
  }

  export type ChoreUncheckedUpdateManyWithoutRecurrenceRuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumChoreStatusFieldUpdateOperationsInput | $Enums.ChoreStatus
    priority?: NullableIntFieldUpdateOperationsInput | number | null
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EventUpdateWithoutRecurrenceRuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    choreId?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumEventCategoryFieldUpdateOperationsInput | $Enums.EventCategory
    isAllDay?: BoolFieldUpdateOperationsInput | boolean
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumEventStatusFieldUpdateOperationsInput | $Enums.EventStatus
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminders?: EventReminderUpdateManyWithoutEventNestedInput
    household?: HouseholdUpdateOneRequiredWithoutEventsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutEventsCreatedNestedInput
    chore?: ChoreUpdateOneWithoutEventNestedInput
    history?: CalendarEventHistoryUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateWithoutRecurrenceRuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    choreId?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumEventCategoryFieldUpdateOperationsInput | $Enums.EventCategory
    isAllDay?: BoolFieldUpdateOperationsInput | boolean
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumEventStatusFieldUpdateOperationsInput | $Enums.EventStatus
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminders?: EventReminderUncheckedUpdateManyWithoutEventNestedInput
    chore?: ChoreUncheckedUpdateOneWithoutEventNestedInput
    history?: CalendarEventHistoryUncheckedUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateManyWithoutRecurrenceRuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    choreId?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumEventCategoryFieldUpdateOperationsInput | $Enums.EventCategory
    isAllDay?: BoolFieldUpdateOperationsInput | boolean
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumEventStatusFieldUpdateOperationsInput | $Enums.EventStatus
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MessageCreateManyThreadInput = {
    id?: string
    authorId: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type MessageUpdateWithoutThreadInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    author?: UserUpdateOneRequiredWithoutMessagesNestedInput
    attachments?: AttachmentUpdateManyWithoutMessageNestedInput
    reactions?: ReactionUpdateManyWithoutMessageNestedInput
    mentions?: MentionUpdateManyWithoutMessageNestedInput
    reads?: MessageReadUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateWithoutThreadInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attachments?: AttachmentUncheckedUpdateManyWithoutMessageNestedInput
    reactions?: ReactionUncheckedUpdateManyWithoutMessageNestedInput
    mentions?: MentionUncheckedUpdateManyWithoutMessageNestedInput
    reads?: MessageReadUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateManyWithoutThreadInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type HouseholdMemberUpdateWithoutThreadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumHouseholdRoleFieldUpdateOperationsInput | $Enums.HouseholdRole
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isInvited?: BoolFieldUpdateOperationsInput | boolean
    isAccepted?: BoolFieldUpdateOperationsInput | boolean
    isRejected?: BoolFieldUpdateOperationsInput | boolean
    isSelected?: BoolFieldUpdateOperationsInput | boolean
    lastAssignedChoreAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutHouseholdsNestedInput
    household?: HouseholdUpdateOneRequiredWithoutMembersNestedInput
  }

  export type HouseholdMemberUncheckedUpdateWithoutThreadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    role?: EnumHouseholdRoleFieldUpdateOperationsInput | $Enums.HouseholdRole
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isInvited?: BoolFieldUpdateOperationsInput | boolean
    isAccepted?: BoolFieldUpdateOperationsInput | boolean
    isRejected?: BoolFieldUpdateOperationsInput | boolean
    isSelected?: BoolFieldUpdateOperationsInput | boolean
    lastAssignedChoreAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type HouseholdMemberUncheckedUpdateManyWithoutThreadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    householdId?: StringFieldUpdateOperationsInput | string
    role?: EnumHouseholdRoleFieldUpdateOperationsInput | $Enums.HouseholdRole
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isInvited?: BoolFieldUpdateOperationsInput | boolean
    isAccepted?: BoolFieldUpdateOperationsInput | boolean
    isRejected?: BoolFieldUpdateOperationsInput | boolean
    isSelected?: BoolFieldUpdateOperationsInput | boolean
    lastAssignedChoreAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AttachmentCreateManyMessageInput = {
    id?: string
    url: string
    fileType: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ReactionCreateManyMessageInput = {
    id?: string
    userId: string
    emoji: string
    type: $Enums.ReactionType
    createdAt?: Date | string
  }

  export type MentionCreateManyMessageInput = {
    id?: string
    userId: string
    mentionedAt?: Date | string
  }

  export type MessageReadCreateManyMessageInput = {
    id?: string
    userId: string
    readAt?: Date | string
  }

  export type AttachmentUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AttachmentUncheckedUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AttachmentUncheckedUpdateManyWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReactionUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    emoji?: StringFieldUpdateOperationsInput | string
    type?: EnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutReactionsNestedInput
  }

  export type ReactionUncheckedUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    emoji?: StringFieldUpdateOperationsInput | string
    type?: EnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReactionUncheckedUpdateManyWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    emoji?: StringFieldUpdateOperationsInput | string
    type?: EnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MentionUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    mentionedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMentionsNestedInput
  }

  export type MentionUncheckedUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    mentionedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MentionUncheckedUpdateManyWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    mentionedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageReadUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMessageReadsNestedInput
  }

  export type MessageReadUncheckedUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageReadUncheckedUpdateManyWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubtaskCreateManyChoreInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.SubtaskStatus
  }

  export type ChoreAssignmentCreateManyChoreInput = {
    id?: string
    userId: string
    assignedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type ChoreSwapRequestCreateManyChoreInput = {
    id?: string
    requestingUserId: string
    targetUserId: string
    status?: $Enums.ChoreSwapRequestStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChoreHistoryCreateManyChoreInput = {
    id?: string
    action: $Enums.ChoreAction
    changedById: string
    changedAt?: Date | string
  }

  export type SubtaskUpdateWithoutChoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSubtaskStatusFieldUpdateOperationsInput | $Enums.SubtaskStatus
  }

  export type SubtaskUncheckedUpdateWithoutChoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSubtaskStatusFieldUpdateOperationsInput | $Enums.SubtaskStatus
  }

  export type SubtaskUncheckedUpdateManyWithoutChoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSubtaskStatusFieldUpdateOperationsInput | $Enums.SubtaskStatus
  }

  export type ChoreAssignmentUpdateWithoutChoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutAssignedChoresNestedInput
  }

  export type ChoreAssignmentUncheckedUpdateWithoutChoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ChoreAssignmentUncheckedUpdateManyWithoutChoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ChoreSwapRequestUpdateWithoutChoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumChoreSwapRequestStatusFieldUpdateOperationsInput | $Enums.ChoreSwapRequestStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requestingUser?: UserUpdateOneRequiredWithoutChoreSwapRequestsInitiatedNestedInput
    targetUser?: UserUpdateOneRequiredWithoutChoreSwapRequestsReceivedNestedInput
  }

  export type ChoreSwapRequestUncheckedUpdateWithoutChoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestingUserId?: StringFieldUpdateOperationsInput | string
    targetUserId?: StringFieldUpdateOperationsInput | string
    status?: EnumChoreSwapRequestStatusFieldUpdateOperationsInput | $Enums.ChoreSwapRequestStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChoreSwapRequestUncheckedUpdateManyWithoutChoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestingUserId?: StringFieldUpdateOperationsInput | string
    targetUserId?: StringFieldUpdateOperationsInput | string
    status?: EnumChoreSwapRequestStatusFieldUpdateOperationsInput | $Enums.ChoreSwapRequestStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChoreHistoryUpdateWithoutChoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumChoreActionFieldUpdateOperationsInput | $Enums.ChoreAction
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutChoreHistoryNestedInput
  }

  export type ChoreHistoryUncheckedUpdateWithoutChoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumChoreActionFieldUpdateOperationsInput | $Enums.ChoreAction
    changedById?: StringFieldUpdateOperationsInput | string
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChoreHistoryUncheckedUpdateManyWithoutChoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumChoreActionFieldUpdateOperationsInput | $Enums.ChoreAction
    changedById?: StringFieldUpdateOperationsInput | string
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubtaskTemplateCreateManyChoreTemplateInput = {
    id?: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubtaskTemplateUpdateWithoutChoreTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubtaskTemplateUncheckedUpdateWithoutChoreTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubtaskTemplateUncheckedUpdateManyWithoutChoreTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseSplitCreateManyExpenseInput = {
    id?: string
    userId: string
    amount: number
  }

  export type TransactionCreateManyExpenseInput = {
    id?: string
    fromUserId: string
    toUserId: string
    amount: number
    status?: $Enums.TransactionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ReceiptCreateManyExpenseInput = {
    id?: string
    url: string
    fileType: string
    createdAt?: Date | string
  }

  export type ExpenseHistoryCreateManyExpenseInput = {
    id?: string
    action: $Enums.ExpenseAction
    changedById: string
    changedAt?: Date | string
  }

  export type ExpenseSplitUpdateWithoutExpenseInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    user?: UserUpdateOneRequiredWithoutExpenseSplitsNestedInput
  }

  export type ExpenseSplitUncheckedUpdateWithoutExpenseInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
  }

  export type ExpenseSplitUncheckedUpdateManyWithoutExpenseInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
  }

  export type TransactionUpdateWithoutExpenseInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fromUser?: UserUpdateOneRequiredWithoutTransactionsFromNestedInput
    toUser?: UserUpdateOneRequiredWithoutTransactionsToNestedInput
  }

  export type TransactionUncheckedUpdateWithoutExpenseInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromUserId?: StringFieldUpdateOperationsInput | string
    toUserId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TransactionUncheckedUpdateManyWithoutExpenseInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromUserId?: StringFieldUpdateOperationsInput | string
    toUserId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReceiptUpdateWithoutExpenseInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReceiptUncheckedUpdateWithoutExpenseInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReceiptUncheckedUpdateManyWithoutExpenseInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseHistoryUpdateWithoutExpenseInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumExpenseActionFieldUpdateOperationsInput | $Enums.ExpenseAction
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutExpenseHistoryNestedInput
  }

  export type ExpenseHistoryUncheckedUpdateWithoutExpenseInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumExpenseActionFieldUpdateOperationsInput | $Enums.ExpenseAction
    changedById?: StringFieldUpdateOperationsInput | string
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseHistoryUncheckedUpdateManyWithoutExpenseInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumExpenseActionFieldUpdateOperationsInput | $Enums.ExpenseAction
    changedById?: StringFieldUpdateOperationsInput | string
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventReminderCreateManyEventInput = {
    id?: string
    time: Date | string
    type: $Enums.EventReminderType
  }

  export type CalendarEventHistoryCreateManyEventInput = {
    id?: string
    action: $Enums.CalendarEventAction
    changedById: string
    changedAt?: Date | string
  }

  export type EventReminderUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumEventReminderTypeFieldUpdateOperationsInput | $Enums.EventReminderType
  }

  export type EventReminderUncheckedUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumEventReminderTypeFieldUpdateOperationsInput | $Enums.EventReminderType
  }

  export type EventReminderUncheckedUpdateManyWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumEventReminderTypeFieldUpdateOperationsInput | $Enums.EventReminderType
  }

  export type CalendarEventHistoryUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumCalendarEventActionFieldUpdateOperationsInput | $Enums.CalendarEventAction
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCalendarEventHistoryNestedInput
  }

  export type CalendarEventHistoryUncheckedUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumCalendarEventActionFieldUpdateOperationsInput | $Enums.CalendarEventAction
    changedById?: StringFieldUpdateOperationsInput | string
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalendarEventHistoryUncheckedUpdateManyWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumCalendarEventActionFieldUpdateOperationsInput | $Enums.CalendarEventAction
    changedById?: StringFieldUpdateOperationsInput | string
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HouseholdCountOutputTypeDefaultArgs instead
     */
    export type HouseholdCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HouseholdCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HouseholdMemberCountOutputTypeDefaultArgs instead
     */
    export type HouseholdMemberCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HouseholdMemberCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RecurrenceRuleCountOutputTypeDefaultArgs instead
     */
    export type RecurrenceRuleCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RecurrenceRuleCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ThreadCountOutputTypeDefaultArgs instead
     */
    export type ThreadCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ThreadCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MessageCountOutputTypeDefaultArgs instead
     */
    export type MessageCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MessageCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ChoreCountOutputTypeDefaultArgs instead
     */
    export type ChoreCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ChoreCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ChoreTemplateCountOutputTypeDefaultArgs instead
     */
    export type ChoreTemplateCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ChoreTemplateCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ExpenseCountOutputTypeDefaultArgs instead
     */
    export type ExpenseCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ExpenseCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EventCountOutputTypeDefaultArgs instead
     */
    export type EventCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EventCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HouseholdDefaultArgs instead
     */
    export type HouseholdArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HouseholdDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HouseholdMemberDefaultArgs instead
     */
    export type HouseholdMemberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HouseholdMemberDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RecurrenceRuleDefaultArgs instead
     */
    export type RecurrenceRuleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RecurrenceRuleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ThreadDefaultArgs instead
     */
    export type ThreadArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ThreadDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MessageDefaultArgs instead
     */
    export type MessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MessageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReactionDefaultArgs instead
     */
    export type ReactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReactionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MentionDefaultArgs instead
     */
    export type MentionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MentionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AttachmentDefaultArgs instead
     */
    export type AttachmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AttachmentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MessageReadDefaultArgs instead
     */
    export type MessageReadArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MessageReadDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ChoreDefaultArgs instead
     */
    export type ChoreArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ChoreDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SubtaskDefaultArgs instead
     */
    export type SubtaskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SubtaskDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ChoreAssignmentDefaultArgs instead
     */
    export type ChoreAssignmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ChoreAssignmentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ChoreSwapRequestDefaultArgs instead
     */
    export type ChoreSwapRequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ChoreSwapRequestDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ChoreTemplateDefaultArgs instead
     */
    export type ChoreTemplateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ChoreTemplateDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SubtaskTemplateDefaultArgs instead
     */
    export type SubtaskTemplateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SubtaskTemplateDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ChoreHistoryDefaultArgs instead
     */
    export type ChoreHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ChoreHistoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ExpenseDefaultArgs instead
     */
    export type ExpenseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ExpenseDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ExpenseSplitDefaultArgs instead
     */
    export type ExpenseSplitArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ExpenseSplitDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TransactionDefaultArgs instead
     */
    export type TransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TransactionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReceiptDefaultArgs instead
     */
    export type ReceiptArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReceiptDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ExpenseHistoryDefaultArgs instead
     */
    export type ExpenseHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ExpenseHistoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EventDefaultArgs instead
     */
    export type EventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EventDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EventReminderDefaultArgs instead
     */
    export type EventReminderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EventReminderDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CalendarEventHistoryDefaultArgs instead
     */
    export type CalendarEventHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CalendarEventHistoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotificationDefaultArgs instead
     */
    export type NotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotificationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotificationSettingsDefaultArgs instead
     */
    export type NotificationSettingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotificationSettingsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OAuthIntegrationDefaultArgs instead
     */
    export type OAuthIntegrationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OAuthIntegrationDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}